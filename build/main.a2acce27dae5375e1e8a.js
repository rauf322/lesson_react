/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/sass-loader/dist/cjs.js!./src/index.scss":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/sass-loader/dist/cjs.js!./src/index.scss ***!
  \*********************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `* {
  padding: 0;
  box-sizing: border-box;
  text-align: center;
  margin-top: 10px;
}

.app {
  font-size: 30px;
}

.button {
  background-color: #0000ff;
  color: white;
  border: 0;
  padding: 15px 20px;
  min-width: 150px;
  font-size: 16px;
  border-radius: 3px;
  cursor: pointer;
  transition: opacity 200ms ease-out;
  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
}`, "",{"version":3,"sources":["webpack://./src/index.scss"],"names":[],"mappings":"AAAA;EACE,UAAA;EACA,sBAAA;EACA,kBAAA;EACA,gBAAA;AACF;;AAEA;EACE,eAAA;AACF;;AAEA;EACE,yBAAA;EACA,YAAA;EACA,SAAA;EACA,kBAAA;EACA,gBAAA;EACA,eAAA;EACA,kBAAA;EACA,eAAA;EACA,kCAAA;EACA,0CAAA;AACF","sourcesContent":["* {\n  padding: 0;\n  box-sizing: border-box;\n  text-align: center;\n  margin-top: 10px;\n}\n\n.app {\n  font-size: 30px;\n}\n\n.button {\n  background-color: #0000ff;\n  color: white;\n  border: 0;\n  padding: 15px 20px;\n  min-width: 150px;\n  font-size: 16px;\n  border-radius: 3px;\n  cursor: pointer;\n  transition: opacity 200ms ease-out;\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-client.development.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-client.development.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

 true &&
  (function () {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
        (fiber = fiber.next), id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length) return value;
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0; i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length
        ? ((updated[newPath[index]] = updated[oldKey]),
          isArrayImpl(updated)
            ? updated.splice(oldKey, 1)
            : delete updated[oldKey])
        : (updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          ));
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return (
          isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key],
          updated
        );
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return !1;
    }
    function shouldErrorImpl() {
      return null;
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function warnInvalidHookAccess() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function warnInvalidContextAccess() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function noop$2() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function (value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject &&
        (updateContainerSync(element, root, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
      if (null !== resolveFamily) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPassiveEffects();
        scheduleFibersWithFamiliesRecursively(
          root.current,
          update,
          staleFamilies
        );
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(
        !node ||
        (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
      );
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return "number" === typeof owner.tag
        ? getComponentNameFromFiber(owner)
        : "string" === typeof owner.name
          ? owner.name
          : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return (type.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return (
            (fiber = type.render),
            (fiber = fiber.displayName || fiber.name || ""),
            type.displayName ||
              ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
          );
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" === typeof type)
            return type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (null != type)
            for (var i = type.length - 1; 0 <= i; i--)
              if ("string" === typeof type[i].name) return type[i].name;
          if (null !== fiber.return)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return (fiber = describeNativeComponentFrame(fiber.type, !1)), fiber;
        case 11:
          return (
            (fiber = describeNativeComponentFrame(fiber.type.render, !1)), fiber
          );
        case 1:
          return (fiber = describeNativeComponentFrame(fiber.type, !0)), fiber;
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "";
        do {
          info += describeFiber(workInProgress);
          var debugInfo = workInProgress._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--) {
              var entry = debugInfo[i];
              if ("string" === typeof entry.name) {
                var JSCompiler_temp_const = info,
                  env = entry.env;
                var JSCompiler_inline_result = describeBuiltInComponentFrame(
                  entry.name + (env ? " [" + env + "]" : "")
                );
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          workInProgress = workInProgress.return;
        } while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (null === current) return null;
      var owner = current._debugOwner;
      return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      return null === current ? "" : getStackByFiberInDevAndProd(current);
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      ReactSharedInternals.getCurrentStack =
        null === fiber ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = fiber;
      try {
        return callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        current = previousFiber;
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          (node = fiber),
            0 !== (node.flags & 4098) && (nearestMounted = node.return),
            (fiber = node.return);
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState &&
          ((fiber = fiber.alternate),
          null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return) (a = parentA), (b = parentB);
        else {
          for (var didFindChild = !1, _child = parentA.child; _child; ) {
            if (_child === a) {
              didFindChild = !0;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child; ) {
              if (_child === a) {
                didFindChild = !0;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (a.alternate !== b)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (3 !== a.tag)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0
        ? console.error("Unexpected pop.")
        : (fiber !== fiberStack[index$jscomp$0] &&
            console.error("Unexpected Fiber popped."),
          (cursor.current = valueStack[index$jscomp$0]),
          (valueStack[index$jscomp$0] = null),
          (fiberStack[index$jscomp$0] = null),
          index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      null === c &&
        console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        );
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance =
            nextRootInstance.documentElement)
            ? (nextRootInstance = nextRootInstance.namespaceURI)
              ? getOwnHostContext(nextRootInstance)
              : HostContextNamespaceNone
            : HostContextNamespaceNone;
          break;
        default:
          if (
            ((nextRootInstance =
              8 === nextRootContext
                ? nextRootInstance.parentNode
                : nextRootInstance),
            (nextRootContext = nextRootInstance.tagName),
            (nextRootInstance = nextRootInstance.namespaceURI))
          )
            (nextRootInstance = getOwnHostContext(nextRootInstance)),
              (nextRootInstance = getChildHostContextProd(
                nextRootInstance,
                nextRootContext
              ));
          else
            switch (nextRootContext) {
              case "svg":
                nextRootInstance = HostContextNamespaceSvg;
                break;
              case "math":
                nextRootInstance = HostContextNamespaceMath;
                break;
              default:
                nextRootInstance = HostContextNamespaceNone;
            }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState &&
        push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = { context: nextContext, ancestorInfo: type };
      context !== nextContext &&
        (push(contextFiberStackCursor, fiber, fiber),
        push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber &&
        (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber &&
        (pop(hostTransitionProviderCursor, fiber),
        (HostTransitionContext._currentValue = NotPendingTransition));
    }
    function typeName(value) {
      return (
        ("function" === typeof Symbol &&
          Symbol.toStringTag &&
          value[Symbol.toStringTag]) ||
        value.constructor.name ||
        "Object"
      );
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch (e) {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function injectInternals(internals) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) return !0;
      if (!hook.supportsFiber)
        return (
          console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ),
          !0
        );
      try {
        (rendererID = hook.inject(internals)), (injectedHook = hook);
      } catch (err) {
        console.error("React instrumentation encountered an error: %s.", err);
      }
      return hook.checkDCE ? !0 : !1;
    }
    function onCommitRoot$1(root, eventPriority) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
        try {
          var didError = 128 === (root.current.flags & 128);
          switch (eventPriority) {
            case DiscreteEventPriority:
              var schedulerPriority = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriority = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriority = NormalPriority$1;
              break;
            case IdleEventPriority:
              schedulerPriority = IdlePriority;
              break;
            default:
              schedulerPriority = NormalPriority$1;
          }
          injectedHook.onCommitFiberRoot(
            rendererID,
            root,
            schedulerPriority,
            didError
          );
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 &&
        unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markCommitStopped &&
        injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      null !== injectedProfilingHooks &&
        "function" ===
          typeof injectedProfilingHooks.markComponentRenderStarted &&
        injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      null !== injectedProfilingHooks &&
        "function" ===
          typeof injectedProfilingHooks.markComponentRenderStopped &&
        injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderStarted &&
        injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderStopped &&
        injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
    }
    function getLabelForLane(lane) {
      if (lane & 1) return "SyncHydrationLane";
      if (lane & 2) return "Sync";
      if (lane & 4) return "InputContinuousHydration";
      if (lane & 8) return "InputContinuous";
      if (lane & 16) return "DefaultHydration";
      if (lane & 32) return "Default";
      if (lane & 64) return "TransitionHydration";
      if (lane & 4194176) return "Transition";
      if (lane & 62914560) return "Retry";
      if (lane & 67108864) return "SelectiveHydration";
      if (lane & 134217728) return "IdleHydration";
      if (lane & 268435456) return "Idle";
      if (lane & 536870912) return "Offscreen";
      if (lane & 1073741824) return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194176;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            lanes
          );
      }
    }
    function getNextLanes(root, wipLanes) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes,
        warmLanes = root.warmLanes;
      root = 0 !== root.finishedLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes
        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
          0 !== pendingLanes
            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
            : ((pingedLanes &= nonIdlePendingLanes),
              0 !== pingedLanes
                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                : root ||
                  ((warmLanes = nonIdlePendingLanes & ~warmLanes),
                  0 !== warmLanes &&
                    (nextLanes = getHighestPriorityLanes(warmLanes)))))
        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
          0 !== nonIdlePendingLanes
            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
            : 0 !== pingedLanes
              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
              : root ||
                ((warmLanes = pendingLanes & ~warmLanes),
                0 !== warmLanes &&
                  (nextLanes = getHighestPriorityLanes(warmLanes))));
      return 0 === nextLanes
        ? 0
        : 0 !== wipLanes &&
            wipLanes !== nextLanes &&
            0 === (wipLanes & suspendedLanes) &&
            ((suspendedLanes = nextLanes & -nextLanes),
            (warmLanes = wipLanes & -wipLanes),
            suspendedLanes >= warmLanes ||
              (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))
          ? wipLanes
          : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return (
        0 ===
        (root.pendingLanes &
          ~(root.suspendedLanes & ~root.pingedLanes) &
          renderLanes)
      );
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
          return currentTime + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            -1
          );
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane &&
        ((root.suspendedLanes = 0),
        (root.pingedLanes = 0),
        (root.warmLanes = 0));
    }
    function markRootFinished(
      root,
      finishedLanes,
      remainingLanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    ) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (
        remainingLanes = previouslyPendingLanes & ~remainingLanes;
        0 < remainingLanes;

      ) {
        var index = 31 - clz32(remainingLanes),
          lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (null !== hiddenUpdatesForLane)
          for (
            hiddenUpdates[index] = null, index = 0;
            index < hiddenUpdatesForLane.length;
            index++
          ) {
            var update = hiddenUpdatesForLane[index];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes &&
        0 === updatedLanes &&
        0 !== root.tag &&
        (root.suspendedLanes |=
          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] =
        root.entanglements[spawnedLaneIndex] |
        1073741824 |
        (entangledLanes & 4194218);
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
      for (root = root.entanglements; rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes),
          lane = 1 << index;
        (lane & entangledLanes) | (root[index] & entangledLanes) &&
          (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent)
        for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
          var index = 31 - clz32(lanes),
            lane = 1 << index;
          root[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent)
        for (
          var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,
            memoizedUpdaters = root.memoizedUpdaters;
          0 < lanes;

        ) {
          var index = 31 - clz32(lanes);
          root = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size &&
            (index.forEach(function (fiber) {
              var alternate = fiber.alternate;
              (null !== alternate && memoizedUpdaters.has(alternate)) ||
                memoizedUpdaters.add(fiber);
            }),
            index.clear());
          lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes
        ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes
          ? 0 !== (lanes & 134217727)
            ? DefaultEventPriority
            : IdleEventPriority
          : ContinuousEventPriority
        : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority
        ? DefaultEventPriority
        : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return (ReactDOMSharedInternals.p = priority), fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (
          (targetInst =
            parentNode[internalContainerInstanceKey] ||
            parentNode[internalInstanceKey])
        ) {
          parentNode = targetInst.alternate;
          if (
            null !== targetInst.child ||
            (null !== parentNode && null !== parentNode.child)
          )
            for (
              targetNode = getParentSuspenseInstance(targetNode);
              null !== targetNode;

            ) {
              if ((parentNode = targetNode[internalInstanceKey]))
                return parentNode;
              targetNode = getParentSuspenseInstance(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (
        (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
      ) {
        var tag = node.tag;
        if (
          5 === tag ||
          6 === tag ||
          13 === tag ||
          26 === tag ||
          27 === tag ||
          3 === tag
        )
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
        return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources ||
        (resources = root[internalRootNodeResourcesKey] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] &&
        console.error(
          "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
          registrationName
        );
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      "onDoubleClick" === registrationName &&
        (possibleRegistrationNames.ondblclick = registrationName);
      for (
        registrationName = 0;
        registrationName < dependencies.length;
        registrationName++
      )
        allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] ||
        props.onChange ||
        props.onInput ||
        props.readOnly ||
        props.disabled ||
        null == props.value ||
        ("select" === tagName
          ? console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
            )
          : console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
            ));
      props.onChange ||
        props.readOnly ||
        props.disabled ||
        null == props.checked ||
        console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return !0;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return !1;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return (validatedAttributeNameCache[attributeName] = !0);
      illegalAttributeNameCache[attributeName] = !0;
      console.error("Invalid attribute name: `%s`", attributeName);
      return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (!1 === expected) return expected;
          }
          return void 0 === expected ? void 0 : null;
        }
        node = node.getAttribute(name);
        if ("" === node && !0 === expected) return !0;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix && "aria-" !== prefix) {
                node.removeAttribute(name);
                return;
              }
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (
        (elem = elem.nodeName) &&
        "input" === elem.toLowerCase() &&
        ("checkbox" === type || "radio" === type)
      );
    }
    function trackValueOnNode(node) {
      var valueField = isCheckable(node) ? "checked" : "value",
        descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
      checkFormFieldValueStringCoercion(node[valueField]);
      var currentValue = "" + node[valueField];
      if (
        !node.hasOwnProperty(valueField) &&
        "undefined" !== typeof descriptor &&
        "function" === typeof descriptor.get &&
        "function" === typeof descriptor.set
      ) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: !0,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node) return !1;
      var tracker = node._valueTracker;
      if (!tracker) return !0;
      var lastValue = tracker.getValue();
      var value = "";
      node &&
        (value = isCheckable(node)
          ? node.checked
            ? "true"
            : "false"
          : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function (ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function validateInputProps(element, props) {
      void 0 === props.checked ||
        void 0 === props.defaultChecked ||
        didWarnCheckedDefaultChecked ||
        (console.error(
          "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnCheckedDefaultChecked = !0));
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue$1 ||
        (console.error(
          "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnValueDefaultValue$1 = !0));
    }
    function updateInput(
      element,
      value,
      defaultValue,
      lastDefaultValue,
      checked,
      defaultChecked,
      type,
      name
    ) {
      element.name = "";
      null != type &&
      "function" !== typeof type &&
      "symbol" !== typeof type &&
      "boolean" !== typeof type
        ? (checkAttributeStringCoercion(type, "type"), (element.type = type))
        : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if ((0 === value && "" === element.value) || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) &&
            (element.value = "" + getToStringValue(value));
      else
        ("submit" !== type && "reset" !== type) ||
          element.removeAttribute("value");
      null != value
        ? setDefaultValue(element, type, getToStringValue(value))
        : null != defaultValue
          ? setDefaultValue(element, type, getToStringValue(defaultValue))
          : null != lastDefaultValue && element.removeAttribute("value");
      null == checked &&
        null != defaultChecked &&
        (element.defaultChecked = !!defaultChecked);
      null != checked &&
        (element.checked =
          checked &&
          "function" !== typeof checked &&
          "symbol" !== typeof checked);
      null != name &&
      "function" !== typeof name &&
      "symbol" !== typeof name &&
      "boolean" !== typeof name
        ? (checkAttributeStringCoercion(name, "name"),
          (element.name = "" + getToStringValue(name)))
        : element.removeAttribute("name");
    }
    function initInput(
      element,
      value,
      defaultValue,
      checked,
      defaultChecked,
      type,
      name,
      isHydrating
    ) {
      null != type &&
        "function" !== typeof type &&
        "symbol" !== typeof type &&
        "boolean" !== typeof type &&
        (checkAttributeStringCoercion(type, "type"), (element.type = type));
      if (null != value || null != defaultValue) {
        if (
          !(
            ("submit" !== type && "reset" !== type) ||
            (void 0 !== value && null !== value)
          )
        )
          return;
        defaultValue =
          null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked =
        "function" !== typeof checked &&
        "symbol" !== typeof checked &&
        !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name &&
        "function" !== typeof name &&
        "symbol" !== typeof name &&
        "boolean" !== typeof name &&
        (checkAttributeStringCoercion(name, "name"), (element.name = name));
    }
    function setDefaultValue(node, type, value) {
      ("number" === type && getActiveElement(node.ownerDocument) === node) ||
        node.defaultValue === "" + value ||
        (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      null == props.value &&
        ("object" === typeof props.children && null !== props.children
          ? React.Children.forEach(props.children, function (child) {
              null == child ||
                "string" === typeof child ||
                "number" === typeof child ||
                "bigint" === typeof child ||
                didWarnInvalidChild ||
                ((didWarnInvalidChild = !0),
                console.error(
                  "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
                ));
            })
          : null == props.dangerouslySetInnerHTML ||
            didWarnInvalidInnerHTML ||
            ((didWarnInvalidInnerHTML = !0),
            console.error(
              "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
            )));
      null == props.selected ||
        didWarnSelectedSetOnOption ||
        (console.error(
          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
        ),
        (didWarnSelectedSetOnOption = !0));
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName
        ? "\n\nCheck the render method of `" + ownerName + "`."
        : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = !0;
        for (propValue = 0; propValue < node.length; propValue++)
          (i = multiple.hasOwnProperty("$" + node[propValue].value)),
            node[propValue].selected !== i && (node[propValue].selected = i),
            i && setDefaultSelected && (node[propValue].defaultSelected = !0);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = !0;
            setDefaultSelected && (node[i].defaultSelected = !0);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = !0);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0; element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (null != props[propName]) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray
            ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              )
            : !props.multiple &&
              propNameIsArray &&
              console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
        }
      }
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue ||
        (console.error(
          "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
        ),
        (didWarnValueDefaultValue = !0));
    }
    function validateTextareaProps(element, props) {
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValDefaultVal ||
        (console.error(
          "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component"
        ),
        (didWarnValDefaultVal = !0));
      null != props.children &&
        null == props.value &&
        console.error(
          "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
        );
    }
    function updateTextarea(element, value, defaultValue) {
      if (
        null != value &&
        ((value = "" + getToStringValue(value)),
        value !== element.value && (element.value = value),
        null == defaultValue)
      ) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue =
        null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (isArrayImpl(children)) {
            if (1 < children.length)
              throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue &&
        "" !== children &&
        null !== children &&
        (element.value = children);
    }
    function findNotableNode(node, indent) {
      return void 0 === node.serverProps &&
        0 === node.serverTail.length &&
        1 === node.children.length &&
        3 < node.distanceFromLeaf &&
        node.distanceFromLeaf > 15 - indent
        ? findNotableNode(node.children[0], indent)
        : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        case 11:
          return (
            (fiber = fiber.type.render), fiber.displayName || fiber.name || null
          );
        case 1:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content)
        ? ((content = JSON.stringify(content)),
          content.length > maxLength - 2
            ? 8 > maxLength
              ? '{"..."}'
              : "{" + content.slice(0, maxLength - 7) + '..."}'
            : "{" + content + "}")
        : content.length > maxLength
          ? 5 > maxLength
            ? '{"..."}'
            : content.slice(0, maxLength - 3) + "..."
          : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (null === serverProps)
        return added(indent) + describeTextNode(clientText, maxLength) + "\n";
      if ("string" === typeof serverProps) {
        for (
          var firstDiff = 0;
          firstDiff < serverProps.length &&
          firstDiff < clientText.length &&
          serverProps.charCodeAt(firstDiff) ===
            clientText.charCodeAt(firstDiff);
          firstDiff++
        );
        firstDiff > maxLength - 8 &&
          10 < firstDiff &&
          ((clientText = "..." + clientText.slice(firstDiff - 8)),
          (serverProps = "..." + serverProps.slice(firstDiff - 8)));
        return (
          added(indent) +
          describeTextNode(clientText, maxLength) +
          "\n" +
          removed(indent) +
          describeTextNode(serverProps, maxLength) +
          "\n"
        );
      }
      return (
        indentation(indent) + describeTextNode(clientText, maxLength) + "\n"
      );
    }
    function objectName(object) {
      return Object.prototype.toString
        .call(object)
        .replace(/^\[object (.*)\]$/, function (m, p0) {
          return p0;
        });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return (
            (value = JSON.stringify(value)),
            value.length > maxLength
              ? 5 > maxLength
                ? '"..."'
                : value.slice(0, maxLength - 4) + '..."'
              : value
          );
        case "object":
          if (null === value) return "null";
          if (isArrayImpl(value)) return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type))
              ? "<" + maxLength + ">"
              : "<...>";
          var name = objectName(value);
          if ("Object" === name) {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' &&
                  (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(
                  value[propName],
                  15 > maxLength ? maxLength : 15
                );
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += "" === name ? "..." : ", ...";
                  break;
                }
                name +=
                  ("" === name ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name)
            ? "function " + maxLength
            : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return "string" !== typeof value || needsEscaping.test(value)
        ? "{" + describeValue(value, maxLength - 2) + "}"
        : value.length > maxLength - 2
          ? 5 > maxLength
            ? '"..."'
            : '"' + value.slice(0, maxLength - 5) + '..."'
          : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length,
        properties = [],
        propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && "children" !== propName) {
          var propValue = describePropValue(
            props[propName],
            120 - rowPrefix.length - propName.length - 1
          );
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return 0 === properties.length
        ? rowPrefix + "<" + type + ">\n"
        : 0 < remainingRowLength
          ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n"
          : rowPrefix +
            "<" +
            type +
            "\n" +
            rowPrefix +
            "  " +
            properties.join("\n" + rowPrefix + "  ") +
            "\n" +
            rowPrefix +
            ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "",
        remainingServerProperties = assign({}, serverObject),
        propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2,
            clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName)
            ? ((maxLength = describeValue(serverObject[propName], maxLength)),
              (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n"),
              (properties +=
                removed(indent) + propName + ": " + maxLength + "\n"))
            : (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n");
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) &&
          ((clientObject = describeValue(
            remainingServerProperties[_propName],
            120 - 2 * indent - _propName.length - 2
          )),
          (properties +=
            removed(indent) + _propName + ": " + clientObject + "\n"));
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "",
        serverPropNames = new Map();
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) &&
          serverPropNames.set(
            propName$jscomp$0.toLowerCase(),
            propName$jscomp$0
          );
      if (1 === serverPropNames.size && serverPropNames.has("children"))
        content += describeExpandedElement(
          type,
          clientProps,
          indentation(indent)
        );
      else {
        for (var _propName2 in clientProps)
          if (
            clientProps.hasOwnProperty(_propName2) &&
            "children" !== _propName2
          ) {
            var maxLength$jscomp$0 =
                120 - 2 * (indent + 1) - _propName2.length - 1,
              serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (void 0 !== serverPropName) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(
                propName$jscomp$0,
                maxLength$jscomp$0
              );
              maxLength$jscomp$0 = describePropValue(
                serverPropName,
                maxLength$jscomp$0
              );
              "object" === typeof propName$jscomp$0 &&
              null !== propName$jscomp$0 &&
              "object" === typeof serverPropName &&
              null !== serverPropName &&
              "Object" === objectName(propName$jscomp$0) &&
              "Object" === objectName(serverPropName) &&
              (2 < Object.keys(propName$jscomp$0).length ||
                2 < Object.keys(serverPropName).length ||
                -1 < clientPropValue.indexOf("...") ||
                -1 < maxLength$jscomp$0.indexOf("..."))
                ? (content +=
                    indentation(indent + 1) +
                    _propName2 +
                    "={{\n" +
                    describePropertiesDiff(
                      propName$jscomp$0,
                      serverPropName,
                      indent + 2
                    ) +
                    indentation(indent + 1) +
                    "}}\n")
                : ((content +=
                    added(indent + 1) +
                    _propName2 +
                    "=" +
                    clientPropValue +
                    "\n"),
                  (content +=
                    removed(indent + 1) +
                    _propName2 +
                    "=" +
                    maxLength$jscomp$0 +
                    "\n"));
            } else
              content +=
                indentation(indent + 1) +
                _propName2 +
                "=" +
                describePropValue(clientProps[_propName2], maxLength$jscomp$0) +
                "\n";
          }
        serverPropNames.forEach(function (propName) {
          if ("children" !== propName) {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content +=
              removed(indent + 1) +
              propName +
              "=" +
              describePropValue(serverProps[propName], maxLength) +
              "\n";
          }
        });
        content =
          "" === content
            ? indentation(indent) + "<" + type + ">\n"
            : indentation(indent) +
              "<" +
              type +
              "\n" +
              content +
              indentation(indent) +
              ">\n";
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (
        "string" === typeof type ||
        "number" === typeof type ||
        "bigint" === typeof type
      ) {
        serverPropNames = "";
        if (
          "string" === typeof clientProps ||
          "number" === typeof clientProps ||
          "bigint" === typeof clientProps
        )
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (
        "string" === typeof clientProps ||
        "number" === typeof clientProps ||
        "bigint" === typeof clientProps
      )
        content =
          null == type
            ? content + describeTextDiff("" + clientProps, null, indent + 1)
            : content + describeTextDiff("" + clientProps, void 0, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (null === type) {
        type = "";
        for (fiber = fiber.child; fiber; )
          (type += describeSiblingFiber(fiber, indent)),
            (fiber = fiber.sibling);
        return type;
      }
      return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (
        skipToNode !== node &&
        (1 !== node.children.length || node.children[0] !== skipToNode)
      )
        return (
          indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1)
        );
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0; i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          "string" === typeof serverComponentName &&
            ((skipToNode +=
              indentation(indent) + "<" + serverComponentName + ">\n"),
            indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (6 === node.fiber.tag)
        (debugInfo = describeTextDiff(i, node.serverProps, indent)), indent++;
      else if (
        ((serverComponentName = describeFiberType(node.fiber)),
        null !== serverComponentName)
      )
        if (void 0 === node.serverProps) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
            content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo =
            indentation(debugInfo) +
            "<" +
            serverComponentName +
            content +
            ">\n";
          indent++;
        } else
          null === node.serverProps
            ? ((debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              )),
              indent++)
            : "string" === typeof node.serverProps
              ? console.error(
                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
                )
              : ((debugInfo = describeElementDiff(
                  serverComponentName,
                  i,
                  node.serverProps,
                  indent
                )),
                indent++);
      var propName = "";
      i = node.fiber.child;
      for (
        serverComponentName = 0;
        i && serverComponentName < node.children.length;

      )
        (maxLength = node.children[serverComponentName]),
          maxLength.fiber === i
            ? ((propName += describeNode(maxLength, indent)),
              serverComponentName++)
            : (propName += describeSiblingFiber(i, indent)),
          (i = i.sibling);
      i &&
        0 < node.children.length &&
        (propName += indentation(indent) + "...\n");
      i = node.serverTail;
      null === node.serverProps && indent--;
      for (node = 0; node < i.length; node++)
        (serverComponentName = i[node]),
          (propName =
            "string" === typeof serverComponentName
              ? propName +
                (removed(indent) +
                  describeTextNode(serverComponentName, 120 - 2 * indent) +
                  "\n")
              : propName +
                describeExpandedElement(
                  serverComponentName.type,
                  serverComponentName.props,
                  removed(indent)
                ));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return "\n\n" + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
        fiber === ancestor && (distanceFromLeaf = 0),
          (node = {
            fiber: fiber,
            children: null !== node ? [node] : [],
            serverProps:
              fiber === child ? props : fiber === ancestor ? null : void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          }),
          distanceFromLeaf++,
          (fiber = fiber.return);
      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      oldInfo = assign({}, oldInfo || emptyAncestorInfoDev);
      var info = { tag: tag };
      -1 !== inScopeTags.indexOf(tag) &&
        ((oldInfo.aTagInScope = null),
        (oldInfo.buttonTagInScope = null),
        (oldInfo.nobrTagInScope = null));
      -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
      -1 !== specialTags.indexOf(tag) &&
        "address" !== tag &&
        "div" !== tag &&
        "p" !== tag &&
        ((oldInfo.listItemTagAutoclosing = null),
        (oldInfo.dlItemTagAutoclosing = null));
      oldInfo.current = info;
      "form" === tag && (oldInfo.formTag = info);
      "a" === tag && (oldInfo.aTagInScope = info);
      "button" === tag && (oldInfo.buttonTagInScope = info);
      "nobr" === tag && (oldInfo.nobrTagInScope = info);
      "p" === tag && (oldInfo.pTagInButtonScope = info);
      "li" === tag && (oldInfo.listItemTagAutoclosing = info);
      if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
      "#document" === tag || "html" === tag
        ? (oldInfo.containerTagInScope = null)
        : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
      return oldInfo;
    }
    function isTagValidWithParent(tag, parentTag) {
      switch (parentTag) {
        case "select":
          return (
            "hr" === tag ||
            "option" === tag ||
            "optgroup" === tag ||
            "#text" === tag
          );
        case "optgroup":
          return "option" === tag || "#text" === tag;
        case "option":
          return "#text" === tag;
        case "tr":
          return (
            "th" === tag ||
            "td" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "tbody":
        case "thead":
        case "tfoot":
          return (
            "tr" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "colgroup":
          return "col" === tag || "template" === tag;
        case "table":
          return (
            "caption" === tag ||
            "colgroup" === tag ||
            "tbody" === tag ||
            "tfoot" === tag ||
            "thead" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "head":
          return (
            "base" === tag ||
            "basefont" === tag ||
            "bgsound" === tag ||
            "link" === tag ||
            "meta" === tag ||
            "title" === tag ||
            "noscript" === tag ||
            "noframes" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "html":
          return "head" === tag || "body" === tag || "frameset" === tag;
        case "frameset":
          return "frame" === tag;
        case "#document":
          return "html" === tag;
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return (
            "h1" !== parentTag &&
            "h2" !== parentTag &&
            "h3" !== parentTag &&
            "h4" !== parentTag &&
            "h5" !== parentTag &&
            "h6" !== parentTag
          );
        case "rp":
        case "rt":
          return -1 === impliedEndTags.indexOf(parentTag);
        case "body":
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "head":
        case "html":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return null == parentTag;
      }
      return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (; parent; ) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName) return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(
        childTag,
        parentInfo && parentInfo.tag
      )
        ? null
        : parentInfo)
        ? null
        : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo) return !0;
      ancestorInfo = ancestorInfo.tag;
      var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
      if (didWarn[warnKey]) return !1;
      didWarn[warnKey] = !0;
      var ancestor = (warnKey = current)
        ? findAncestor(warnKey.return, ancestorInfo)
        : null;
      warnKey =
        null !== warnKey && null !== ancestor
          ? describeAncestors(ancestor, warnKey, null)
          : "";
      ancestor = "<" + childTag + ">";
      parentInfo
        ? ((parentInfo = ""),
          "table" === ancestorInfo &&
            "tr" === childTag &&
            (parentInfo +=
              " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
          console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            ancestor,
            ancestorInfo,
            parentInfo,
            warnKey
          ))
        : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            ancestor,
            ancestorInfo,
            warnKey
          );
      return !1;
    }
    function validateTextNesting(childText, parentTag) {
      if (isTagValidWithParent("#text", parentTag)) return !0;
      var warnKey = "#text|" + parentTag;
      if (didWarn[warnKey]) return !1;
      didWarn[warnKey] = !0;
      var ancestor = (warnKey = current)
        ? findAncestor(warnKey, parentTag)
        : null;
      warnKey =
        null !== warnKey && null !== ancestor
          ? describeAncestors(
              ancestor,
              warnKey,
              6 !== warnKey.tag ? { children: null } : null
            )
          : "";
      /\S/.test(childText)
        ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            warnKey
          )
        : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            warnKey
          );
      return !1;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          3 === firstChild.nodeType
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function (_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      isCustomProperty ||
        (-1 < styleName.indexOf("-")
          ? (warnedStyleNames.hasOwnProperty(styleName) &&
              warnedStyleNames[styleName]) ||
            ((warnedStyleNames[styleName] = !0),
            console.error(
              "Unsupported style property %s. Did you mean %s?",
              styleName,
              camelize(styleName.replace(msPattern, "ms-"))
            ))
          : badVendoredStyleNamePattern.test(styleName)
            ? (warnedStyleNames.hasOwnProperty(styleName) &&
                warnedStyleNames[styleName]) ||
              ((warnedStyleNames[styleName] = !0),
              console.error(
                "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                styleName,
                styleName.charAt(0).toUpperCase() + styleName.slice(1)
              ))
            : !badStyleValueWithSemicolonPattern.test(value) ||
              (warnedStyleValues.hasOwnProperty(value) &&
                warnedStyleValues[value]) ||
              ((warnedStyleValues[value] = !0),
              console.error(
                'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.',
                styleName,
                value.replace(badStyleValueWithSemicolonPattern, "")
              )),
        "number" === typeof value &&
          (isNaN(value)
            ? warnedForNaNValue ||
              ((warnedForNaNValue = !0),
              console.error(
                "`NaN` is an invalid value for the `%s` css style property.",
                styleName
              ))
            : isFinite(value) ||
              warnedForInfinityValue ||
              ((warnedForInfinityValue = !0),
              console.error(
                "`Infinity` is an invalid value for the `%s` css style property.",
                styleName
              ))));
      null == value || "boolean" === typeof value || "" === value
        ? isCustomProperty
          ? style.setProperty(styleName, "")
          : "float" === styleName
            ? (style.cssFloat = "")
            : (style[styleName] = "")
        : isCustomProperty
          ? style.setProperty(styleName, value)
          : "number" !== typeof value ||
              0 === value ||
              unitlessNumbers.has(styleName)
            ? "float" === styleName
              ? (style.cssFloat = value)
              : (checkCSSPropertyStringCoercion(value, styleName),
                (style[styleName] = ("" + value).trim()))
            : (style[styleName] = value + "px");
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      styles && Object.freeze(styles);
      node = node.style;
      if (null != prevStyles) {
        if (styles) {
          var expandedUpdates = {};
          if (prevStyles)
            for (var key in prevStyles)
              if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                for (
                  var longhands = shorthandToLonghand[key] || [key], i = 0;
                  i < longhands.length;
                  i++
                )
                  expandedUpdates[longhands[i]] = key;
          for (var _key in styles)
            if (
              styles.hasOwnProperty(_key) &&
              (!prevStyles || prevStyles[_key] !== styles[_key])
            )
              for (
                key = shorthandToLonghand[_key] || [_key], longhands = 0;
                longhands < key.length;
                longhands++
              )
                expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles)
            for (
              key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0],
                longhands = 0;
              longhands < key.length;
              longhands++
            )
              _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates)
            if (
              ((key = expandedUpdates[_key2]),
              (longhands = _key[_key2]) &&
                key !== longhands &&
                ((i = key + "," + longhands), !key$jscomp$0[i]))
            ) {
              key$jscomp$0[i] = !0;
              i = console;
              var value = styles[key];
              i.error.call(
                i,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                null == value || "boolean" === typeof value || "" === value
                  ? "Removing"
                  : "Updating",
                key,
                longhands
              );
            }
        }
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) ||
            (null != styles && styles.hasOwnProperty(styleName)) ||
            (0 === styleName.indexOf("--")
              ? node.setProperty(styleName, "")
              : "float" === styleName
                ? (node.cssFloat = "")
                : (node[styleName] = ""));
        for (var _styleName in styles)
          (_key2 = styles[_styleName]),
            styles.hasOwnProperty(_styleName) &&
              prevStyles[_styleName] !== _key2 &&
              setValueForStyle(node, _styleName, _key2);
      } else
        for (expandedUpdates in styles)
          styles.hasOwnProperty(expandedUpdates) &&
            setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return !1;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (
        hasOwnProperty.call(warnedProperties$1, name) &&
        warnedProperties$1[name]
      )
        return !0;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ),
            (warnedProperties$1[name] = !0)
          );
        if (name !== tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ),
            (warnedProperties$1[name] = !0)
          );
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return (warnedProperties$1[name] = !0), !1;
        name !== tagName &&
          (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ),
          (warnedProperties$1[name] = !0));
      }
      return !0;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [],
        key;
      for (key in props)
        validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === invalidProps.length
        ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          )
        : 1 < invalidProps.length &&
          console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
        return !0;
      var lowerCasedName = name.toLowerCase();
      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
        return (
          console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "function" === typeof value &&
        (("form" === tagName && "action" === name) ||
          ("input" === tagName && "formAction" === name) ||
          ("button" === tagName && "formAction" === name))
      )
        return !0;
      if (null != eventRegistry) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return !0;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName)
          ? tagName[lowerCasedName]
          : null;
        if (null != eventRegistry)
          return (
            console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ),
            (warnedProperties[name] = !0)
          );
        if (EVENT_NAME_REGEX.test(name))
          return (
            console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ),
            (warnedProperties[name] = !0)
          );
      } else if (EVENT_NAME_REGEX.test(name))
        return (
          INVALID_EVENT_NAME_REGEX.test(name) &&
            console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ),
          (warnedProperties[name] = !0)
        );
      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
      if ("innerhtml" === lowerCasedName)
        return (
          console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ),
          (warnedProperties[name] = !0)
        );
      if ("aria" === lowerCasedName)
        return (
          console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "is" === lowerCasedName &&
        null !== value &&
        void 0 !== value &&
        "string" !== typeof value
      )
        return (
          console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ),
          (warnedProperties[name] = !0)
        );
      if ("number" === typeof value && isNaN(value))
        return (
          console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ),
          (warnedProperties[name] = !0)
        );
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (
          ((lowerCasedName = possibleStandardNames[lowerCasedName]),
          lowerCasedName !== name)
        )
          return (
            console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ),
            (warnedProperties[name] = !0)
          );
      } else if (name !== lowerCasedName)
        return (
          console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ),
          (warnedProperties[name] = !0)
        );
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                return !0;
              value
                ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  )
                : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
              return (warnedProperties[name] = !0);
          }
        case "function":
        case "symbol":
          return (warnedProperties[name] = !0), !1;
        case "string":
          if ("false" === value || "true" === value) {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              value,
              name,
              "false" === value
                ? "The browser will interpret it as a truthy value."
                : 'Although this works, it will not work as expected if you pass the string "false".',
              name,
              value
            );
            warnedProperties[name] = !0;
          }
      }
      return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [],
        key;
      for (key in props)
        validateProperty(type, key, props[key], eventRegistry) ||
          unknownProps.push(key);
      props = unknownProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === unknownProps.length
        ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          )
        : 1 < unknownProps.length &&
          console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url)
        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
        : url;
    }
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement &&
        (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (
          ((target = internalInstance.stateNode), internalInstance.type)
        ) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              checkAttributeStringCoercion(internalInstance, "name");
              props = props.querySelectorAll(
                'input[name="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) +
                  '"][type="radio"]'
              );
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              ) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              )
                (otherNode = props[internalInstance]),
                  otherNode.form === target.form &&
                    updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            (internalInstance = props.value),
              null != internalInstance &&
                updateOptions(target, !!props.multiple, internalInstance, !1);
        }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = !0;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (
          ((isInsideEventHandler = !1),
          null !== restoreTarget || null !== restoreQueue)
        )
          if (
            (flushSyncWork$1(),
            restoreTarget &&
              ((a = restoreTarget),
              (fn = restoreQueue),
              (restoreQueue = restoreTarget = null),
              restoreStateOfTarget(a),
              fn))
          )
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) ||
            ((inst = inst.type),
            (props = !(
              "button" === inst ||
              "input" === inst ||
              "select" === inst ||
              "textarea" === inst
            )));
          inst = !props;
          break a;
        default:
          inst = !1;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          "Expected `" +
            registrationName +
            "` listener to be a function, instead got a value of `" +
            typeof stateNode +
            "` type."
        );
      return stateNode;
    }
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (
        start = 0;
        start < startLength && startValue[start] === endValue[start];
        start++
      );
      var minEnd = startLength - start;
      for (
        end = 1;
        end <= minEnd &&
        startValue[startLength - end] === endValue[endLength - end];
        end++
      );
      return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent
        ? ((nativeEvent = nativeEvent.charCode),
          0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
        : (nativeEvent = keyCode);
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(
        reactName,
        reactEventType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) &&
            ((reactName = Interface[propName]),
            (this[propName] = reactName
              ? reactName(nativeEvent)
              : nativeEvent[propName]));
        this.isDefaultPrevented = (
          null != nativeEvent.defaultPrevented
            ? nativeEvent.defaultPrevented
            : !1 === nativeEvent.returnValue
        )
          ? functionThatReturnsTrue
          : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event &&
            (event.preventDefault
              ? event.preventDefault()
              : "unknown" !== typeof event.returnValue &&
                (event.returnValue = !1),
            (this.isDefaultPrevented = functionThatReturnsTrue));
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event &&
            (event.stopPropagation
              ? event.stopPropagation()
              : "unknown" !== typeof event.cancelBubble &&
                (event.cancelBubble = !0),
            (this.isPropagationStopped = functionThatReturnsTrue));
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState
        ? nativeEvent.getModifierState(keyArg)
        : (keyArg = modifierKeyToProp[keyArg])
          ? !!nativeEvent[keyArg]
          : !1;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent
        ? nativeEvent.data
        : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE) return null;
          hasSpaceKeypress = !0;
          return SPACEBAR_CHAR;
        case "textInput":
          return (
            (domEventName = nativeEvent.data),
            domEventName === SPACEBAR_CHAR && hasSpaceKeypress
              ? null
              : domEventName
          );
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName ||
          (!canUseCompositionEvent &&
            isFallbackCompositionEnd(domEventName, nativeEvent))
          ? ((domEventName = getData()),
            (fallbackText = startText = root = null),
            (isComposing = !1),
            domEventName)
          : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(
              nativeEvent.ctrlKey ||
              nativeEvent.altKey ||
              nativeEvent.metaKey
            ) ||
            (nativeEvent.ctrlKey && nativeEvent.altKey)
          ) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale
            ? null
            : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName
        ? !!supportedInputTypes[elem.type]
        : "textarea" === nodeName
          ? !0
          : !1;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM) return !1;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported ||
        ((isSupported = document.createElement("div")),
        isSupported.setAttribute(eventNameSuffix, "return;"),
        (isSupported = "function" === typeof isSupported[eventNameSuffix]));
      return isSupported;
    }
    function createAndAccumulateChangeEvent(
      dispatchQueue,
      inst,
      nativeEvent,
      target
    ) {
      restoreTarget
        ? restoreQueue
          ? restoreQueue.push(target)
          : (restoreQueue = [target])
        : (restoreTarget = target);
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length &&
        ((nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 &&
        (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
        (activeElementInst$1 = activeElement$1 = null));
    }
    function handlePropertyChange(nativeEvent) {
      if (
        "value" === nativeEvent.propertyName &&
        getInstIfValueChanged(activeElementInst$1)
      ) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(
      domEventName,
      target,
      targetInst
    ) {
      "focusin" === domEventName
        ? (stopWatchingForValueChange(),
          (activeElement$1 = target),
          (activeElementInst$1 = targetInst),
          activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
        : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (
        "selectionchange" === domEventName ||
        "keyup" === domEventName ||
        "keydown" === domEventName
      )
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return !0;
      if (
        "object" !== typeof objA ||
        null === objA ||
        "object" !== typeof objB ||
        null === objB
      )
        return !1;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return !1;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (
          !hasOwnProperty.call(objB, currentKey) ||
          !objectIs(objA[currentKey], objB[currentKey])
        )
          return !1;
      }
      return !0;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset)
            return { node: node, offset: offset - root };
          root = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode
        ? outerNode === innerNode
          ? !0
          : outerNode && 3 === outerNode.nodeType
            ? !1
            : innerNode && 3 === innerNode.nodeType
              ? containsNode(outerNode, innerNode.parentNode)
              : "contains" in outerNode
                ? outerNode.contains(innerNode)
                : outerNode.compareDocumentPosition
                  ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                  : !1
        : !1;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo =
        null != containerInfo &&
        null != containerInfo.ownerDocument &&
        null != containerInfo.ownerDocument.defaultView
          ? containerInfo.ownerDocument.defaultView
          : window;
      for (
        var element = getActiveElement(containerInfo.document);
        element instanceof containerInfo.HTMLIFrameElement;

      ) {
        try {
          var JSCompiler_inline_result =
            "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = !1;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return (
        nodeName &&
        (("input" === nodeName &&
          ("text" === elem.type ||
            "search" === elem.type ||
            "tel" === elem.type ||
            "url" === elem.type ||
            "password" === elem.type)) ||
          "textarea" === nodeName ||
          "true" === elem.contentEditable)
      );
    }
    function restoreSelection(priorSelectionInformation, containerInfo) {
      var curFocusedElem = getActiveElementDeep(containerInfo);
      containerInfo = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (
        curFocusedElem !== containerInfo &&
        containerInfo &&
        containerInfo.ownerDocument &&
        containsNode(containerInfo.ownerDocument.documentElement, containerInfo)
      ) {
        if (
          null !== priorSelectionRange &&
          hasSelectionCapabilities(containerInfo)
        )
          if (
            ((priorSelectionInformation = priorSelectionRange.start),
            (curFocusedElem = priorSelectionRange.end),
            void 0 === curFocusedElem &&
              (curFocusedElem = priorSelectionInformation),
            "selectionStart" in containerInfo)
          )
            (containerInfo.selectionStart = priorSelectionInformation),
              (containerInfo.selectionEnd = Math.min(
                curFocusedElem,
                containerInfo.value.length
              ));
          else if (
            ((curFocusedElem =
              ((priorSelectionInformation =
                containerInfo.ownerDocument || document) &&
                priorSelectionInformation.defaultView) ||
              window),
            curFocusedElem.getSelection)
          ) {
            curFocusedElem = curFocusedElem.getSelection();
            var length = containerInfo.textContent.length,
              start = Math.min(priorSelectionRange.start, length);
            priorSelectionRange =
              void 0 === priorSelectionRange.end
                ? start
                : Math.min(priorSelectionRange.end, length);
            !curFocusedElem.extend &&
              start > priorSelectionRange &&
              ((length = priorSelectionRange),
              (priorSelectionRange = start),
              (start = length));
            length = getNodeForCharacterOffset(containerInfo, start);
            var endMarker = getNodeForCharacterOffset(
              containerInfo,
              priorSelectionRange
            );
            length &&
              endMarker &&
              (1 !== curFocusedElem.rangeCount ||
                curFocusedElem.anchorNode !== length.node ||
                curFocusedElem.anchorOffset !== length.offset ||
                curFocusedElem.focusNode !== endMarker.node ||
                curFocusedElem.focusOffset !== endMarker.offset) &&
              ((priorSelectionInformation =
                priorSelectionInformation.createRange()),
              priorSelectionInformation.setStart(length.node, length.offset),
              curFocusedElem.removeAllRanges(),
              start > priorSelectionRange
                ? (curFocusedElem.addRange(priorSelectionInformation),
                  curFocusedElem.extend(endMarker.node, endMarker.offset))
                : (priorSelectionInformation.setEnd(
                    endMarker.node,
                    endMarker.offset
                  ),
                  curFocusedElem.addRange(priorSelectionInformation)));
          }
        priorSelectionInformation = [];
        for (
          curFocusedElem = containerInfo;
          (curFocusedElem = curFocusedElem.parentNode);

        )
          1 === curFocusedElem.nodeType &&
            priorSelectionInformation.push({
              element: curFocusedElem,
              left: curFocusedElem.scrollLeft,
              top: curFocusedElem.scrollTop
            });
        "function" === typeof containerInfo.focus && containerInfo.focus();
        for (
          containerInfo = 0;
          containerInfo < priorSelectionInformation.length;
          containerInfo++
        )
          (curFocusedElem = priorSelectionInformation[containerInfo]),
            (curFocusedElem.element.scrollLeft = curFocusedElem.left),
            (curFocusedElem.element.scrollTop = curFocusedElem.top);
      }
    }
    function constructSelectEvent(
      dispatchQueue,
      nativeEvent,
      nativeEventTarget
    ) {
      var doc =
        nativeEventTarget.window === nativeEventTarget
          ? nativeEventTarget.document
          : 9 === nativeEventTarget.nodeType
            ? nativeEventTarget
            : nativeEventTarget.ownerDocument;
      mouseDown ||
        null == activeElement ||
        activeElement !== getActiveElement(doc) ||
        ((doc = activeElement),
        "selectionStart" in doc && hasSelectionCapabilities(doc)
          ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
          : ((doc = (
              (doc.ownerDocument && doc.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (doc = {
              anchorNode: doc.anchorNode,
              anchorOffset: doc.anchorOffset,
              focusNode: doc.focusNode,
              focusOffset: doc.focusOffset
            })),
        (lastSelection && shallowEqual(lastSelection, doc)) ||
          ((lastSelection = doc),
          (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
          0 < doc.length &&
            ((nativeEvent = new SyntheticEvent(
              "onSelect",
              "select",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({ event: nativeEvent, listeners: doc }),
            (nativeEvent.target = activeElement))));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function finishQueueingConcurrentUpdates() {
      for (
        var endIndex = concurrentQueuesIndex,
          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
        i < endIndex;

      ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
        (parent.childLanes |= lane),
          (alternate = parent.alternate),
          null !== alternate && (alternate.childLanes |= lane),
          22 === parent.tag &&
            ((sourceFiber = parent.stateNode),
            null === sourceFiber ||
              sourceFiber._visibility & OffscreenVisible ||
              (isHidden = !0)),
          (sourceFiber = parent),
          (parent = parent.return);
      isHidden &&
        null !== update &&
        3 === sourceFiber.tag &&
        ((parent = sourceFiber.stateNode),
        (isHidden = 31 - clz32(lane)),
        (parent = parent.hiddenUpdates),
        (sourceFiber = parent[isHidden]),
        null === sourceFiber
          ? (parent[isHidden] = [update])
          : sourceFiber.push(update),
        (update.lane = lane | 536870912));
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw (
          ((nestedPassiveUpdateCount = nestedUpdateCount = 0),
          (rootWithPassiveNestedUpdates = rootWithNestedUpdates = null),
          Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          ))
        );
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT &&
        ((nestedPassiveUpdateCount = 0),
        (rootWithPassiveNestedUpdates = null),
        console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        ));
      null === sourceFiber.alternate &&
        0 !== (sourceFiber.flags & 4098) &&
        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return; null !== parent; )
        null === node.alternate &&
          0 !== (node.flags & 4098) &&
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),
          (node = parent),
          (parent = node.return);
      return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family
        ? null !== type &&
          void 0 !== type &&
          "function" === typeof type.render &&
          ((family = resolveFunctionForHotReloading(type.render)),
          type.render !== family)
          ? ((family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }),
            void 0 !== type.displayName &&
              (family.displayName = type.displayName),
            family)
          : type
        : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (null === resolveFamily) return !1;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = !1,
        $$typeofNextType =
          "object" === typeof element && null !== element
            ? element.$$typeof
            : null;
      switch (fiber.tag) {
        case 1:
          "function" === typeof element && (needsCompareFamilies = !0);
          break;
        case 0:
          "function" === typeof element
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        default:
          return !1;
      }
      return needsCompareFamilies &&
        ((fiber = resolveFamily(prevType)),
        void 0 !== fiber && fiber === resolveFamily(element))
        ? !0
        : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      null !== resolveFamily &&
        "function" === typeof WeakSet &&
        (null === failedBoundaries && (failedBoundaries = new WeakSet()),
        failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(
      fiber,
      updatedFamilies,
      staleFamilies
    ) {
      var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type,
        candidateType = null;
      switch (tag) {
        case 0:
        case 15:
        case 1:
          candidateType = type;
          break;
        case 11:
          candidateType = type.render;
      }
      if (null === resolveFamily)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var needsRender = !1;
      type = !1;
      null !== candidateType &&
        ((candidateType = resolveFamily(candidateType)),
        void 0 !== candidateType &&
          (staleFamilies.has(candidateType)
            ? (type = !0)
            : updatedFamilies.has(candidateType) &&
              (1 === tag ? (type = !0) : (needsRender = !0))));
      null !== failedBoundaries &&
        (failedBoundaries.has(fiber) ||
          (null !== alternate && failedBoundaries.has(alternate))) &&
        (type = !0);
      type && (fiber._debugNeedsRemount = !0);
      if (type || needsRender)
        (alternate = enqueueConcurrentRenderForLane(fiber, 2)),
          null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
      null === child ||
        type ||
        scheduleFibersWithFamiliesRecursively(
          child,
          updatedFamilies,
          staleFamilies
        );
      null !== sibling &&
        scheduleFibersWithFamiliesRecursively(
          sibling,
          updatedFamilies,
          staleFamilies
        );
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
      }
    }
    function startEffectTimer() {
      profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child; )
        (fiber.actualDuration += child.actualDuration), (child = child.sibling);
    }
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - (baseLength % 5);
        length = (
          baseIdWithLeadingBit &
          ((1 << numberOfOverflowBits) - 1)
        ).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId =
          (1 << (32 - clz32(totalChildren) + baseLength)) |
          (index << baseLength) |
          baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else
        (treeContextId =
          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
          (treeContextOverflow = workInProgress);
    }
    function pushMaterializedTreeId(workInProgress) {
      warnIfNotHydrating();
      null !== workInProgress.return &&
        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider; )
        (treeForkProvider = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null),
          (treeForkCount = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null);
      for (; workInProgress === treeContextProvider; )
        (treeContextProvider = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextOverflow = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextId = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null);
    }
    function warnIfNotHydrating() {
      isHydrating ||
        console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (null === fiber.return) {
        if (null === hydrationDiffRootDEV)
          hydrationDiffRootDEV = {
            fiber: fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf &&
            (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(
        fiber.return,
        distanceFromLeaf + 1
      ).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return (
          (siblings = siblings[siblings.length - 1]),
          siblings.distanceFromLeaf > distanceFromLeaf &&
            (siblings.distanceFromLeaf = distanceFromLeaf),
          siblings
        );
      distanceFromLeaf = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV ||
        ((fiber = buildHydrationDiffNode(fiber, 0)),
        (fiber.serverProps = null),
        null !== rejectedCandidate &&
          ((rejectedCandidate =
            describeHydratableInstanceForDevWarnings(rejectedCandidate)),
          fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var diff = "",
        diffRoot = hydrationDiffRootDEV;
      null !== diffRoot &&
        ((hydrationDiffRootDEV = null), (diff = describeDiff(diffRoot)));
      queueHydrationError(
        createCapturedValueAtFiber(
          Error(
            "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" +
              diff
          ),
          fiber
        )
      );
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var type = fiber.type,
        props = fiber.memoizedProps;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(
            didHydrate,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            !0
          );
          track(didHydrate);
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props),
            listenToNonDelegatedEvent("invalid", didHydrate),
            validateTextareaProps(didHydrate, props),
            initTextarea(
              didHydrate,
              props.value,
              props.defaultValue,
              props.children
            ),
            track(didHydrate);
      }
      type = props.children;
      ("string" !== typeof type &&
        "number" !== typeof type &&
        "bigint" !== typeof type) ||
      didHydrate.textContent === "" + type ||
      !0 === props.suppressHydrationWarning ||
      checkForUnmatchedText(didHydrate.textContent, type)
        ? (null != props.popover &&
            (listenToNonDelegatedEvent("beforetoggle", didHydrate),
            listenToNonDelegatedEvent("toggle", didHydrate)),
          null != props.onScroll &&
            listenToNonDelegatedEvent("scroll", didHydrate),
          null != props.onScrollEnd &&
            listenToNonDelegatedEvent("scrollend", didHydrate),
          null != props.onClick && (didHydrate.onclick = noop$1),
          (didHydrate = !0))
        : (didHydrate = !1);
      didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 3:
          case 27:
            rootOrSingletonContext = !0;
            return;
          case 5:
          case 13:
            rootOrSingletonContext = !1;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1;
      if (!isHydrating)
        return popToNextHostParent(fiber), (isHydrating = !0), !1;
      var shouldClear = !1,
        JSCompiler_temp;
      if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {
        if ((JSCompiler_temp = 5 === fiber.tag))
          (JSCompiler_temp = fiber.type),
            (JSCompiler_temp =
              !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
              shouldSetTextContent(fiber.type, fiber.memoizedProps));
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && (shouldClear = !0);
      if (shouldClear && nextHydratableInstance) {
        for (shouldClear = nextHydratableInstance; shouldClear; ) {
          JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
          var description =
            describeHydratableInstanceForDevWarnings(shouldClear);
          JSCompiler_temp.serverTail.push(description);
          shouldClear =
            "Suspense" === description.type
              ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear)
              : getNextHydratable(shouldClear.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (13 === fiber.tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        nextHydratableInstance =
          getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else
        nextHydratableInstance = hydrationParentFiber
          ? getNextHydratable(fiber.stateNode.nextSibling)
          : null;
      return !0;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = !1;
    }
    function queueHydrationError(error) {
      null === hydrationErrors
        ? (hydrationErrors = [error])
        : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      null !== diffRoot &&
        ((hydrationDiffRootDEV = null),
        (diffRoot = describeDiff(diffRoot)),
        console.error(
          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
          "https://react.dev/link/hydration-mismatch",
          diffRoot
        ));
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {}
    function trackUsedThenable(thenableState, thenable, index) {
      null !== ReactSharedInternals.actQueue &&
        (ReactSharedInternals.didUsePromise = !0);
      var trackedThenables = thenableState.thenables;
      index = trackedThenables[index];
      void 0 === index
        ? trackedThenables.push(thenable)
        : index !== thenable &&
          (thenableState.didWarnAboutUncachedPromise ||
            ((thenableState.didWarnAboutUncachedPromise = !0),
            console.error(
              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
            )),
          thenable.then(noop$3, noop$3),
          (thenable = index));
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
        default:
          if ("string" === typeof thenable.status)
            thenable.then(noop$3, noop$3);
          else {
            thenableState = workInProgressRoot;
            if (
              null !== thenableState &&
              100 < thenableState.shellSuspendCounter
            )
              throw Error(
                "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(
              function (fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function (error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw (
                ((thenableState = thenable.reason),
                checkIfUseWrappedInAsyncCatch(thenableState),
                thenableState)
              );
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = !0;
          throw SuspenseException;
      }
    }
    function getSuspendedThenable() {
      if (null === suspendedThenable)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = !1;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      null != debugInfo &&
        (currentDebugInfo =
          null === previousDebugInfo
            ? debugInfo
            : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          null === fiber &&
            ((fiber = createFiberFromElement(element, returnFiber.mode, 0)),
            (fiber._debugInfo = currentDebugInfo),
            (fiber.return = returnFiber));
          runWithFiberInDEV(
            fiber,
            function (erroredKey) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                erroredKey
              );
            },
            key
          );
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(
          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
        );
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        "Objects are not valid as a React child (found: " +
          ("[object Object]" === returnFiber
            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
            : returnFiber) +
          "). If you meant to render a collection of children, use an array instead."
      );
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] ||
        ((ownerHasFunctionTypeWarning[parentName] = !0),
        (invalidChild =
          invalidChild.displayName || invalidChild.name || "Component"),
        3 === returnFiber.tag
          ? console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
              invalidChild,
              invalidChild,
              invalidChild
            )
          : console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
              invalidChild,
              invalidChild,
              parentName,
              invalidChild,
              parentName
            ));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] ||
        ((ownerHasSymbolTypeWarning[parentName] = !0),
        (invalidChild = String(invalidChild)),
        3 === returnFiber.tag
          ? console.error(
              "Symbols are not valid as a React child.\n  root.render(%s)",
              invalidChild
            )
          : console.error(
              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
              parentName,
              invalidChild,
              parentName
            ));
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions
            ? ((returnFiber.deletions = [childToDelete]),
              (returnFiber.flags |= 16))
            : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key
            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
            : existingChildren.set(currentFirstChild.index, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return (newFiber.flags |= 1048576), lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return (
            (newIndex = newIndex.index),
            newIndex < lastPlacedIndex
              ? ((newFiber.flags |= 33554434), lastPlacedIndex)
              : newIndex
          );
        newFiber.flags |= 33554434;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects &&
          null === newFiber.alternate &&
          (newFiber.flags |= 33554434);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return (
            (current = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, textContent);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return (
            (current = updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            )),
            validateFragmentProps(element, current, returnFiber),
            current
          );
        if (
          null !== current &&
          (current.elementType === elementType ||
            isCompatibleFamilyForHotReloading(current, element) ||
            ("object" === typeof elementType &&
              null !== elementType &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              callLazyInitInDEV(elementType) === current.type))
        )
          return (
            (current = useFiber(current, element.props)),
            coerceRef(current, element),
            (current.return = returnFiber),
            (current._debugOwner = element._owner),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current, element);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (
          null === current ||
          4 !== current.tag ||
          current.stateNode.containerInfo !== portal.containerInfo ||
          current.stateNode.implementation !== portal.implementation
        )
          return (
            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
            (current.return = returnFiber),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return (
            (current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, fragment);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            (newChild._debugOwner = returnFiber),
            (newChild._debugInfo = currentDebugInfo),
            newChild
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (lanes = createFiberFromElement(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = pushDebugInfo(newChild._debugInfo)),
                (lanes._debugInfo = currentDebugInfo),
                (currentDebugInfo = returnFiber),
                lanes
              );
            case REACT_PORTAL_TYPE:
              return (
                (newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                (newChild.return = returnFiber),
                (newChild._debugInfo = currentDebugInfo),
                newChild
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (lanes = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              )),
              (lanes.return = returnFiber),
              (lanes._debugOwner = returnFiber),
              (returnFiber = pushDebugInfo(newChild._debugInfo)),
              (lanes._debugInfo = currentDebugInfo),
              (currentDebugInfo = returnFiber),
              lanes
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = createChild(
                returnFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return null !== key
            ? null
            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key
                ? ((key = pushDebugInfo(newChild._debugInfo)),
                  (returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  )),
                  (currentDebugInfo = key),
                  returnFiber)
                : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key
                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                : null;
            case REACT_LAZY_TYPE:
              return (
                (key = pushDebugInfo(newChild._debugInfo)),
                (newChild = callLazyInitInDEV(newChild)),
                (returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = key),
                returnFiber
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (null !== key) return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(
              returnFiber,
              oldFiber,
              newChild,
              lanes,
              null
            );
            currentDebugInfo = key;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (key = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = key),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChild,
        lanes
      ) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (newIdx =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                (existingChildren = pushDebugInfo(newChild._debugInfo)),
                (returnFiber = updateElement(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = existingChildren),
                returnFiber
              );
            case REACT_PORTAL_TYPE:
              return (
                (existingChildren =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                updatePortal(returnFiber, existingChildren, newChild, lanes)
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (newIdx = existingChildren.get(newIdx) || null),
              (existingChildren = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFragment(
                returnFiber,
                newIdx,
                newChild,
                lanes,
                null
              )),
              (currentDebugInfo = existingChildren),
              returnFiber
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo7 = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo7),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
        if ("object" !== typeof child || null === child) return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress, child);
            var key = child.key;
            if ("string" !== typeof key) break;
            if (null === knownKeys) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress, function () {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                key
              );
            });
            break;
          case REACT_LAZY_TYPE:
            (child = callLazyInitInDEV(child)),
              warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        for (
          var knownKeys = null,
            resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null;
          null !== oldFiber && newIdx < newChildren.length;
          newIdx++
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            newChildren[newIdx],
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          newIdx < newChildren.length;
          newIdx++
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        if (null == newChildren)
          throw Error("An iterable object provided no iterator.");
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null,
            knownKeys = null,
            step = newChildren.next();
          null !== oldFiber && !step.done;
          newIdx++, step = newChildren.next()
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            step.value,
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            (oldFiber = createChild(returnFiber, step.value, lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          !step.done;
          newIdx++, step = newChildren.next()
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            step.value,
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      ) {
        "object" === typeof newChild &&
          null !== newChild &&
          newChild.type === REACT_FRAGMENT_TYPE &&
          null === newChild.key &&
          (validateFragmentProps(newChild, null, returnFiber),
          (newChild = newChild.props.children));
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (
                      currentFirstChild.elementType === key ||
                      isCompatibleFamilyForHotReloading(
                        currentFirstChild,
                        newChild
                      ) ||
                      ("object" === typeof key &&
                        null !== key &&
                        key.$$typeof === REACT_LAZY_TYPE &&
                        callLazyInitInDEV(key) === currentFirstChild.type)
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE
                  ? ((lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    )),
                    (lanes.return = returnFiber),
                    (lanes._debugOwner = returnFiber),
                    (lanes._debugInfo = currentDebugInfo),
                    validateFragmentProps(newChild, lanes, returnFiber),
                    (returnFiber = lanes))
                  : ((lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    )),
                    coerceRef(lanes, newChild),
                    (lanes.return = returnFiber),
                    (lanes._debugInfo = currentDebugInfo),
                    (returnFiber = lanes));
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (
                  newChild = prevDebugInfo.key;
                  null !== currentFirstChild;

                ) {
                  if (currentFirstChild.key === newChild)
                    if (
                      4 === currentFirstChild.tag &&
                      currentFirstChild.stateNode.containerInfo ===
                        prevDebugInfo.containerInfo &&
                      currentFirstChild.stateNode.implementation ===
                        prevDebugInfo.implementation
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        prevDebugInfo.children || []
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                );
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return (
                (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
                (newChild = callLazyInitInDEV(newChild)),
                (returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = prevDebugInfo),
                returnFiber
              );
          }
          if (isArrayImpl(newChild))
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if ("function" !== typeof key)
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (
                0 !== returnFiber.tag ||
                "[object GeneratorFunction]" !==
                  Object.prototype.toString.call(returnFiber.type) ||
                "[object Generator]" !==
                  Object.prototype.toString.call(newChildren)
              )
                didWarnAboutGenerators ||
                  console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ),
                  (didWarnAboutGenerators = !0);
            } else
              newChild.entries !== key ||
                didWarnAboutMaps ||
                (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ),
                (didWarnAboutMaps = !0));
            returnFiber = reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChildren,
              lanes
            );
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (prevDebugInfo = "" + newChild),
            null !== currentFirstChild && 6 === currentFirstChild.tag
              ? (deleteRemainingChildren(
                  returnFiber,
                  currentFirstChild.sibling
                ),
                (lanes = useFiber(currentFirstChild, prevDebugInfo)),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : (deleteRemainingChildren(returnFiber, currentFirstChild),
                (lanes = createFiberFromText(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                )),
                (lanes.return = returnFiber),
                (lanes._debugOwner = returnFiber),
                (lanes._debugInfo = currentDebugInfo),
                (returnFiber = lanes)),
            placeSingleChild(returnFiber)
          );
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException) throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = (fiber._debugInfo = currentDebugInfo);
          fiber._debugOwner = returnFiber._debugOwner;
          if (null != debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if ("string" === typeof debugInfo[i].stack) {
                fiber._debugOwner = debugInfo[i];
                break;
              }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(
        currentTreeHiddenStackCursor,
        currentTreeHiddenStackCursor.current,
        fiber
      );
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(
        suspenseStackCursor,
        suspenseStackCursor.current & SubtreeSuspenseContextMask,
        handler
      );
      push(suspenseHandlerStackCursor, handler, handler);
      null === shellBoundary &&
        (null === current || null !== currentTreeHiddenStackCursor.current
          ? (shellBoundary = handler)
          : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (
          (push(suspenseStackCursor, suspenseStackCursor.current, fiber),
          push(suspenseHandlerStackCursor, fiber, fiber),
          null === shellBoundary)
        ) {
          var current = fiber.alternate;
          null !== current &&
            null !== current.memoizedState &&
            (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(
        suspenseHandlerStackCursor,
        suspenseHandlerStackCursor.current,
        fiber
      );
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (
            null !== state &&
            ((state = state.dehydrated),
            null === state ||
              state.data === SUSPENSE_PENDING_START_DATA ||
              state.data === SUSPENSE_FALLBACK_START_DATA)
          )
            return node;
        } else if (
          19 === node.tag &&
          void 0 !== node.memoizedProps.revealOrder
        ) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted &&
        console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        );
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount &&
        console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        );
      0 === cache.refCount &&
        scheduleCallback$2(NormalPriority, function () {
          cache.controller.abort();
        });
    }
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = (currentEntangledListeners = []);
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (
        0 === --currentEntangledPendingCount &&
        null !== currentEntangledListeners
      ) {
        null !== currentEntangledActionThenable &&
          (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          }
        };
      thenable.then(
        function () {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function (error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender
        ? cacheResumedFromPreviousRender
        : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool
        ? push(resumedCache, resumedCache.current, offscreenWorkInProgress)
        : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool
        ? null
        : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      null === hookTypesDev
        ? (hookTypesDev = [hookName])
        : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (
        null !== hookTypesDev &&
        (hookTypesUpdateIndexDev++,
        hookTypesDev[hookTypesUpdateIndexDev] !== hookName)
      ) {
        var componentName = getComponentNameFromFiber(
          currentlyRenderingFiber$1
        );
        if (
          !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
          (didWarnAboutMismatchedHooksForComponent.add(componentName),
          null !== hookTypesDev)
        ) {
          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i],
              newHookName =
                i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (
              oldHookName = i + 1 + ". " + oldHookName;
              30 > oldHookName.length;

            )
              oldHookName += " ";
            oldHookName += newHookName + "\n";
            table += oldHookName;
          }
          console.error(
            "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
            componentName,
            table
          );
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      void 0 === deps ||
        null === deps ||
        isArrayImpl(deps) ||
        console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          currentHookNameInDev,
          typeof deps
        );
    }
    function warnOnUseFormStateInDev() {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
      didWarnAboutUseFormState.has(componentName) ||
        (didWarnAboutUseFormState.add(componentName),
        console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          componentName
        ));
    }
    function throwInvalidHookError() {
      throw Error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies) return !1;
      if (null === prevDeps)
        return (
          console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            currentHookNameInDev
          ),
          !1
        );
      nextDeps.length !== prevDeps.length &&
        console.error(
          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
          currentHookNameInDev,
          "[" + prevDeps.join(", ") + "]",
          "[" + nextDeps.join(", ") + "]"
        );
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
      return !0;
    }
    function renderWithHooks(
      current,
      workInProgress,
      Component,
      props,
      secondArg,
      nextRenderLanes
    ) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber$1 = workInProgress;
      hookTypesDev = null !== current ? current._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      if (
        "[object AsyncFunction]" ===
          Object.prototype.toString.call(Component) ||
        "[object AsyncGeneratorFunction]" ===
          Object.prototype.toString.call(Component)
      )
        (nextRenderLanes = getComponentNameFromFiber(
          currentlyRenderingFiber$1
        )),
          didWarnAboutAsyncClientComponent.has(nextRenderLanes) ||
            (didWarnAboutAsyncClientComponent.add(nextRenderLanes),
            console.error(
              "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            ));
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H =
        null !== current && null !== current.memoizedState
          ? HooksDispatcherOnUpdateInDEV
          : null !== hookTypesDev
            ? HooksDispatcherOnMountWithHookTypesInDEV
            : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes =
        (workInProgress.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = !1;
      didScheduleRenderPhaseUpdateDuringThisPass &&
        (children = renderWithHooksAgain(
          workInProgress,
          Component,
          props,
          secondArg
        ));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(!0);
        try {
          children = renderWithHooksAgain(
            workInProgress,
            Component,
            props,
            secondArg
          );
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      finishRenderingHooks(current, workInProgress);
      return children;
    }
    function finishRenderingHooks(current, workInProgress) {
      workInProgress._debugHookTypes = hookTypesDev;
      null === workInProgress.dependencies
        ? null !== thenableState &&
          (workInProgress.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          })
        : (workInProgress.dependencies._debugThenableState = thenableState);
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks =
        null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      hookTypesDev =
        currentHookNameInDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber$1 =
          null;
      hookTypesUpdateIndexDev = -1;
      null !== current &&
        (current.flags & 31457280) !== (workInProgress.flags & 31457280) &&
        console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        );
      didScheduleRenderPhaseUpdate = !1;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      null === current ||
        didReceiveUpdate ||
        ((current = current.dependencies),
        null !== current &&
          checkIfContextChanged(current) &&
          (didReceiveUpdate = !0));
      needsToResetSuspendedThenableDEV
        ? ((needsToResetSuspendedThenableDEV = !1), (current = !0))
        : (current = !1);
      current &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Unknown"),
        didWarnAboutUseWrappedInTryCatch.has(workInProgress) ||
          didWarnAboutAsyncClientComponent.has(workInProgress) ||
          (didWarnAboutUseWrappedInTryCatch.add(workInProgress),
          console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber$1 = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        numberOfReRenders += 1;
        ignorePreviousDependencies = !1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable =
        "function" === typeof maybeThenable.then
          ? useThenable(maybeThenable)
          : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !==
        dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags =
        (workInProgress.mode & StrictEffectsMode) !== NoMode
          ? workInProgress.flags & -201328645
          : workInProgress.flags & -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (
          workInProgress = workInProgress.memoizedState;
          null !== workInProgress;

        ) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = 0;
      hookTypesDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber$1 =
          null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook
        ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
        : (workInProgressHook = workInProgressHook.next = hook);
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber$1.alternate;
        nextCurrentHook =
          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook =
        null === workInProgressHook
          ? currentlyRenderingFiber$1.memoizedState
          : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        (workInProgressHook = nextWorkInProgressHook),
          (currentHook = nextCurrentHook);
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber$1.alternate)
            throw Error(
              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
            );
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook
          ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =
              nextCurrentHook)
          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
      }
      return workInProgressHook;
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber$1;
      null ===
        (null === workInProgressHook
          ? index.memoizedState
          : workInProgressHook.next) &&
        ((index = index.alternate),
        (ReactSharedInternals.H =
          null !== index && null !== index.memoizedState
            ? HooksDispatcherOnUpdateInDEV
            : HooksDispatcherOnMountInDEV));
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber$1.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber$1.alternate;
        null !== current &&
          ((current = current.updateQueue),
          null !== current &&
            ((current = current.memoCache),
            null != current &&
              (memoCache = {
                data: current.data.map(function (array) {
                  return array.slice();
                }),
                index: 0
              })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue &&
        ((updateQueue = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber$1.updateQueue = updateQueue));
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue || ignorePreviousDependencies)
        for (
          updateQueue = memoCache.data[memoCache.index] = Array(size),
            current = 0;
          current < size;
          current++
        )
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size &&
          console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            updateQueue.length,
            size
          );
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber$1,
        reducer
      );
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue !== baseQueue &&
          console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          );
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = (baseFirst = null),
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction = !1;
        do {
          var updateLane = update.lane & -536870913;
          if (
            updateLane !== update.lane
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast &&
                (newBaseQueueLast = newBaseQueueLast.next =
                  {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }),
                updateLane === currentEntangledLane &&
                  (didReadFromEntangledAsyncAction = !0);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane &&
                (didReadFromEntangledAsyncAction = !0);
              continue;
            } else
              (updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                    (baseFirst = pendingQueue))
                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                (currentlyRenderingFiber$1.lanes |= revertLane),
                (workInProgressRootSkippedLanes |= revertLane);
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV &&
              reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState
              ? update.eagerState
              : reducer(pendingQueue, updateLane);
          } else
            (revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }),
              null === newBaseQueueLast
                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                  (baseFirst = pendingQueue))
                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
              (currentlyRenderingFiber$1.lanes |= updateLane),
              (workInProgressRootSkippedLanes |= updateLane);
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast
          ? (baseFirst = pendingQueue)
          : (newBaseQueueLast.next = newBaseQueueFirst);
        if (
          !objectIs(pendingQueue, hook.memoizedState) &&
          ((didReceiveUpdate = !0),
          didReadFromEntangledAsyncAction &&
            ((reducer = currentEntangledActionThenable), null !== reducer))
        )
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
        do
          (newState = reducer(newState, update.action)), (update = update.next);
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber$1,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot ||
          nextSnapshot === getServerSnapshot() ||
          (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot ||
          ((getServerSnapshot = getSnapshot()),
          objectIs(nextSnapshot, getServerSnapshot) ||
            (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ),
            (didWarnUncachedGetSnapshot = !0)));
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        0 !== (workInProgressRootRenderLanes & 60) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot: getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(
        subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
        [subscribe]
      );
      fiber.flags |= 2048;
      pushEffect(
        HasEffect | Passive,
        updateStoreInstance.bind(
          null,
          fiber,
          getServerSnapshot,
          nextSnapshot,
          getSnapshot
        ),
        { destroy: void 0 },
        null
      );
      return nextSnapshot;
    }
    function updateSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      var fiber = currentlyRenderingFiber$1,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        getServerSnapshot = getServerSnapshot();
      } else if (
        ((getServerSnapshot = getSnapshot()), !didWarnUncachedGetSnapshot)
      ) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) ||
          (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      }
      if (
        (cachedSnapshot = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        ))
      )
        (hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0);
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (
        hook.getSnapshot !== getSnapshot ||
        cachedSnapshot ||
        (null !== workInProgressHook &&
          workInProgressHook.memoizedState.tag & HasEffect)
      ) {
        fiber.flags |= 2048;
        pushEffect(
          HasEffect | Passive,
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          { destroy: void 0 },
          null
        );
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        isHydrating$jscomp$0 ||
          0 !== (renderLanes & 60) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber$1.updateQueue;
      null === getSnapshot
        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber$1.updateQueue = getSnapshot),
          (getSnapshot.stores = [fiber]))
        : ((renderedSnapshot = getSnapshot.stores),
          null === renderedSnapshot
            ? (getSnapshot.stores = [fiber])
            : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(
          null,
          currentlyRenderingFiber$1,
          queue
        );
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber$1,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(
      fiber,
      actionQueue,
      setPendingState,
      setState,
      payload
    ) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T
          ? setPendingState(!0)
          : (actionNode.isTransition = !1);
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState
          ? ((actionNode.next = actionQueue.pending = actionNode),
            runActionStateAction(actionQueue, actionNode))
          : ((actionNode.next = setPendingState.next),
            (actionQueue.pending = setPendingState.next = actionNode));
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        ReactSharedInternals.T._updatedFibers = new Set();
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          (ReactSharedInternals.T = prevTransition),
            null === prevTransition &&
              currentTransition._updatedFibers &&
              ((actionQueue = currentTransition._updatedFibers.size),
              currentTransition._updatedFibers.clear(),
              10 < actionQueue &&
                console.warn(
                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
                ));
        }
      } else
        try {
          (currentTransition = action(prevState, payload)),
            handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$3) {
          onActionError(actionQueue, node, error$3);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
        ? (returnValue.then(
            function (nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function (error) {
              return onActionError(actionQueue, node, error);
            }
          ),
          node.isTransition ||
            console.error(
              "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
            ))
        : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode &&
        ((nextState = actionNode.next),
        nextState === actionNode
          ? (actionQueue.pending = null)
          : ((nextState = nextState.next),
            (actionNode.next = nextState),
            runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          (actionNode.status = "rejected"),
            (actionNode.reason = error),
            notifyActionListeners(actionNode),
            (actionNode = actionNode.next);
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var isMatching = currentlyRenderingFiber$1;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (
                    var inRootOrSingleton = rootOrSingletonContext;
                    8 !== markerInstance.nodeType;

                  ) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(
                      markerInstance.nextSibling
                    );
                    if (null === markerInstance) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance =
                    inRootOrSingleton === FORM_STATE_IS_MATCHING ||
                    inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING
                      ? markerInstance
                      : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(
                    markerInstance.nextSibling
                  );
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = !1;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber$1,
        isMatching
      );
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(!1);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber$1,
        !1,
        isMatching.queue
      );
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber$1,
        markerInstance,
        inRootOrSingleton,
        ssrFormState
      );
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, !1];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      currentStateHook =
        "object" === typeof currentStateHook &&
        null !== currentStateHook &&
        "function" === typeof currentStateHook.then
          ? useThenable(currentStateHook)
          : currentStateHook;
      var actionQueueHook = updateWorkInProgressHook(),
        actionQueue = actionQueueHook.queue,
        dispatch = actionQueue.dispatch;
      action !== actionQueueHook.memoizedState &&
        ((currentlyRenderingFiber$1.flags |= 2048),
        pushEffect(
          HasEffect | Passive,
          actionStateActionEffect.bind(null, actionQueue, action),
          { destroy: void 0 },
          null
        ));
      return [currentStateHook, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, !1];
    }
    function pushEffect(tag, create, inst, deps) {
      tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };
      create = currentlyRenderingFiber$1.updateQueue;
      null === create &&
        ((create = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber$1.updateQueue = create));
      inst = create.lastEffect;
      null === inst
        ? (create.lastEffect = tag.next = tag)
        : ((deps = inst.next),
          (inst.next = tag),
          (tag.next = deps),
          (create.lastEffect = tag));
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber$1.flags |= fiberFlags;
      hook.memoizedState = pushEffect(
        HasEffect | hookFlags,
        create,
        { destroy: void 0 },
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook &&
      null !== deps &&
      areHookInputsEqual(deps, currentHook.memoizedState.deps)
        ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))
        : ((currentlyRenderingFiber$1.flags |= fiberFlags),
          (hook.memoizedState = pushEffect(
            HasEffect | hookFlags,
            create,
            inst,
            deps
          )));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode &&
      (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode
        ? mountEffectImpl(142608384, Passive, create, deps)
        : mountEffectImpl(8390656, Passive, create, deps);
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 67108864);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return (
          ref.hasOwnProperty("current") ||
            console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ),
          (create = create()),
          (ref.current = create),
          function () {
            ref.current = null;
          }
        );
    }
    function mountImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 67108864);
      mountEffectImpl(
        fiberFlags,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function updateImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(
        4,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook
        ? mountDeferredValueImpl(hook, value, initialValue)
        : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
        return (hook.memoizedState = value);
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return (
          (hook = mountDeferredValueImpl(hook, value, initialValue)),
          objectIs(hook, prevValue) || (didReceiveUpdate = !0),
          hook
        );
      if (0 === (renderLanes & 42))
        return (didReceiveUpdate = !0), (hook.memoizedState = value);
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(
      fiber,
      queue,
      pendingState,
      finishedState,
      callback
    ) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p =
        0 !== previousPriority && previousPriority < ContinuousEventPriority
          ? previousPriority
          : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        if (
          null !== returnValue &&
          "object" === typeof returnValue &&
          "function" === typeof returnValue.then
        ) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function () {}, status: "rejected", reason: error },
          requestUpdateLane(fiber)
        );
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition),
          null === prevTransition &&
            currentTransition._updatedFibers &&
            ((fiber = currentTransition._updatedFibers.size),
            currentTransition._updatedFibers.clear(),
            10 < fiber &&
              console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        NotPendingTransition,
        null === action
          ? noop$2
          : function () {
              requestFormReset$1(formFiber);
              return action(formData);
            }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      null === ReactSharedInternals.T &&
        console.error(
          "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
        );
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(
        formFiber,
        resetStateQueue,
        {},
        requestUpdateLane(formFiber)
      );
    }
    function mountTransition() {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber$1,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + treeId;
        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += ":";
      } else
        (treeId = globalClientIdCounter++),
          (identifierPrefix =
            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
      return (hook.memoizedState = identifierPrefix);
    }
    function mountRefresh() {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber$1
      ));
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider);
            fiber = createUpdate(lane);
            var root = enqueueUpdate(provider, fiber, lane);
            null !== root &&
              (scheduleUpdateOnFiber(root, provider, lane),
              entangleTransitions(root, provider, lane));
            provider = createCache();
            null !== seedKey &&
              void 0 !== seedKey &&
              null !== root &&
              console.error(
                "The seed argument is not enabled outside experimental channels."
              );
            fiber.payload = { cache: provider };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(
      fiber,
      queue,
      action,
      JSCompiler_OptimizeArgumentsArray_p0
    ) {
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
      action = {
        lane: JSCompiler_OptimizeArgumentsArray_p0,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber)
        ? enqueueRenderPhaseUpdate(queue, action)
        : ((action = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            JSCompiler_OptimizeArgumentsArray_p0
          )),
          null !== action &&
            (scheduleUpdateOnFiber(
              action,
              fiber,
              JSCompiler_OptimizeArgumentsArray_p0
            ),
            entangleTransitionUpdate(
              action,
              queue,
              JSCompiler_OptimizeArgumentsArray_p0
            )));
      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
    }
    function dispatchSetState(
      fiber,
      queue,
      action,
      JSCompiler_OptimizeArgumentsArray_p1
    ) {
      "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
      dispatchSetStateInternal(
        fiber,
        queue,
        action,
        JSCompiler_OptimizeArgumentsArray_p1
      );
      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (
          0 === fiber.lanes &&
          (null === alternate || 0 === alternate.lanes) &&
          ((alternate = queue.lastRenderedReducer), null !== alternate)
        ) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return (
                enqueueUpdate$1(fiber, queue, update, 0),
                null === workInProgressRoot &&
                  finishQueueingConcurrentUpdates(),
                !1
              );
          } catch (error) {
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return (
            scheduleUpdateOnFiber(action, fiber, lane),
            entangleTransitionUpdate(action, queue, lane),
            !0
          );
      }
      return !1;
    }
    function dispatchOptimisticSetState(
      fiber,
      throwIfDuringRender,
      queue,
      action
    ) {
      null === ReactSharedInternals.T &&
        0 === currentEntangledLane &&
        console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        (throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        )),
          null !== throwIfDuringRender &&
            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return (
        fiber === currentlyRenderingFiber$1 ||
        (null !== alternate && alternate === currentlyRenderingFiber$1)
      );
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass =
        didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194176)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (null !== callback && "function" !== typeof callback) {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) ||
          (didWarnOnInvalidCallback.add(key),
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
      }
    }
    function applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      nextProps
    ) {
      var prevState = workInProgress.memoizedState,
        partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === partialState &&
        ((ctor = getComponentNameFromType(ctor) || "Component"),
        didWarnAboutUndefinedDerivedState.has(ctor) ||
          (didWarnAboutUndefinedDerivedState.add(ctor),
          console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
      prevState =
        null === partialState || void 0 === partialState
          ? prevState
          : assign({}, prevState, partialState);
      workInProgress.memoizedState = prevState;
      0 === workInProgress.lanes &&
        (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextContext
    ) {
      var instance = workInProgress.stateNode;
      if ("function" === typeof instance.shouldComponentUpdate) {
        oldProps = instance.shouldComponentUpdate(
          newProps,
          newState,
          nextContext
        );
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        void 0 === oldProps &&
          console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            getComponentNameFromType(ctor) || "Component"
          );
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent
        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
        : !0;
    }
    function callComponentWillReceiveProps(
      workInProgress,
      instance,
      newProps,
      nextContext
    ) {
      var oldState = instance.state;
      "function" === typeof instance.componentWillReceiveProps &&
        instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Component"),
        didWarnAboutStateAssignmentForComponent.has(workInProgress) ||
          (didWarnAboutStateAssignmentForComponent.add(workInProgress),
          console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress
          )),
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if ((Component = Component.defaultProps)) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          void 0 === newProps[_propName] &&
            (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error, errorInfo) {
      reportGlobalError(error);
      error = componentName
        ? "An error occurred in the <" + componentName + "> component."
        : "An error occurred in one of your React components.";
      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
        componentStack =
          null != errorInfo.componentStack ? errorInfo.componentStack : "";
      ReactSharedInternals.getCurrentStack = function () {
        return componentStack;
      };
      try {
        console.warn(
          "%s\n\n%s\n",
          error,
          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
        );
      } finally {
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function defaultOnCaughtError(error, errorInfo) {
      var componentNameMessage = componentName
          ? "The above error occurred in the <" + componentName + "> component."
          : "The above error occurred in one of your React components.",
        recreateMessage =
          "React will try to recreate this component tree from scratch using the error boundary you provided, " +
          ((errorBoundaryName || "Anonymous") + "."),
        prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
        componentStack =
          null != errorInfo.componentStack ? errorInfo.componentStack : "";
      ReactSharedInternals.getCurrentStack = function () {
        return componentStack;
      };
      try {
        "object" === typeof error &&
        null !== error &&
        "string" === typeof error.environmentName
          ? bindToConsole(
              "error",
              [
                "%o\n\n%s\n\n%s\n",
                error,
                componentNameMessage,
                recreateMessage
              ],
              error.environmentName
            )()
          : console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
      } finally {
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (null !== ReactSharedInternals.actQueue)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e$4) {
        setTimeout(function () {
          throw e$4;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$5) {
        setTimeout(function () {
          throw e$5;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function () {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
        };
      }
      var inst = fiber.stateNode;
      null !== inst &&
        "function" === typeof inst.componentDidCatch &&
        (update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
          "function" !== typeof getDerivedStateFromError &&
            (null === legacyErrorBoundariesThatAlreadyFailed
              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
              : legacyErrorBoundariesThatAlreadyFailed.add(this));
          callComponentDidCatchInDEV(this, errorInfo);
          "function" === typeof getDerivedStateFromError ||
            (0 === (fiber.lanes & 2) &&
              console.error(
                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
                getComponentNameFromFiber(fiber) || "Unknown"
              ));
        });
    }
    function throwException(
      root,
      returnFiber,
      sourceFiber,
      value,
      rootRenderLanes
    ) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (
        null !== value &&
        "object" === typeof value &&
        "function" === typeof value.then
      ) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber &&
          propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            !0
          );
        isHydrating && (didSuspendOrErrorDEV = !0);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return (
                null === shellBoundary
                  ? renderDidSuspendDelayIfPossible()
                  : null === sourceFiber.alternate &&
                    workInProgressRootExitStatus === RootInProgress &&
                    (workInProgressRootExitStatus = RootSuspended),
                (sourceFiber.flags &= -257),
                (sourceFiber.flags |= 65536),
                (sourceFiber.lanes = rootRenderLanes),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? (sourceFiber.updateQueue = new Set([value]))
                      : returnFiber.add(value),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
            case 22:
              return (
                (sourceFiber.flags |= 65536),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? ((returnFiber = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([value])
                        }),
                        (sourceFiber.updateQueue = returnFiber))
                      : ((sourceFiber = returnFiber.retryQueue),
                        null === sourceFiber
                          ? (returnFiber.retryQueue = new Set([value]))
                          : sourceFiber.add(value)),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
          }
          throw Error(
            "Unexpected Suspense handler tag (" +
              sourceFiber.tag +
              "). This is a bug in React."
          );
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return !1;
      }
      if (isHydrating)
        return (
          (didSuspendOrErrorDEV = !0),
          (returnFiber = suspenseHandlerStackCursor.current),
          null !== returnFiber
            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
              (returnFiber.flags |= 65536),
              (returnFiber.lanes = rootRenderLanes),
              value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ))
            : (value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ),
              (root = root.current.alternate),
              (root.flags |= 65536),
              (rootRenderLanes &= -rootRenderLanes),
              (root.lanes |= rootRenderLanes),
              (value = createCapturedValueAtFiber(value, sourceFiber)),
              (rootRenderLanes = createRootErrorUpdate(
                root.stateNode,
                value,
                rootRenderLanes
              )),
              enqueueCapturedUpdate(root, rootRenderLanes),
              workInProgressRootExitStatus !== RootSuspendedWithDelay &&
                (workInProgressRootExitStatus = RootErrored)),
          !1
        );
      var error = createCapturedValueAtFiber(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: value }
        ),
        sourceFiber
      );
      null === workInProgressRootConcurrentErrors
        ? (workInProgressRootConcurrentErrors = [error])
        : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay &&
        (workInProgressRootExitStatus = RootErrored);
      if (null === returnFiber) return !0;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return (
              (sourceFiber.flags |= 65536),
              (root = rootRenderLanes & -rootRenderLanes),
              (sourceFiber.lanes |= root),
              (root = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root
              )),
              enqueueCapturedUpdate(sourceFiber, root),
              !1
            );
          case 1:
            if (
              ((returnFiber = sourceFiber.type),
              (error = sourceFiber.stateNode),
              0 === (sourceFiber.flags & 128) &&
                ("function" === typeof returnFiber.getDerivedStateFromError ||
                  (null !== error &&
                    "function" === typeof error.componentDidCatch &&
                    (null === legacyErrorBoundariesThatAlreadyFailed ||
                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
            )
              return (
                (sourceFiber.flags |= 65536),
                (rootRenderLanes &= -rootRenderLanes),
                (sourceFiber.lanes |= rootRenderLanes),
                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value
                ),
                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                !1
              );
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return !1;
    }
    function reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      workInProgress.child =
        null === current
          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
          : reconcileChildFibers(
              workInProgress,
              current.child,
              nextChildren,
              renderLanes
            );
    }
    function updateForwardRef(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      nextProps = renderWithHooks(
        current,
        workInProgress,
        Component,
        propsWithoutRef,
        ref,
        renderLanes
      );
      key = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null === current) {
        var type = Component.type;
        if (
          "function" === typeof type &&
          !shouldConstruct(type) &&
          void 0 === type.defaultProps &&
          null === Component.compare
        )
          return (
            (Component = resolveFunctionForHotReloading(type)),
            (workInProgress.tag = 15),
            (workInProgress.type = Component),
            validateFunctionComponentInDev(workInProgress, type),
            updateSimpleMemoComponent(
              current,
              workInProgress,
              Component,
              nextProps,
              renderLanes
            )
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress,
          workInProgress.mode,
          renderLanes
        );
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return (workInProgress.child = current);
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (
          Component(prevProps, nextProps) &&
          current.ref === workInProgress.ref
        )
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes
          );
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return (workInProgress.child = current);
    }
    function updateSimpleMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (
          shallowEqual(prevProps, nextProps) &&
          current.ref === workInProgress.ref &&
          workInProgress.type === current.type
        )
          if (
            ((didReceiveUpdate = !1),
            (workInProgress.pendingProps = nextProps = prevProps),
            checkScheduledUpdateOrContext(current, renderLanes))
          )
            0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
          else
            return (
              (workInProgress.lanes = current.lanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
      }
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        nextProps,
        renderLanes
      );
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        nextIsDetached =
          0 !==
          (workInProgress.stateNode._pendingVisibility & OffscreenDetached),
        prevState = null !== current ? current.memoizedState : null;
      markRef(current, workInProgress);
      if ("hidden" === nextProps.mode || nextIsDetached) {
        if (0 !== (workInProgress.flags & 128)) {
          nextProps =
            null !== prevState
              ? prevState.baseLanes | renderLanes
              : renderLanes;
          if (null !== current) {
            nextChildren = workInProgress.child = current.child;
            for (nextIsDetached = 0; null !== nextChildren; )
              (nextIsDetached =
                nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
                (nextChildren = nextChildren.sibling);
            workInProgress.childLanes = nextIsDetached & ~nextProps;
          } else (workInProgress.childLanes = 0), (workInProgress.child = null);
          return deferHiddenOffscreenComponent(
            current,
            workInProgress,
            nextProps,
            renderLanes
          );
        }
        if (0 !== (renderLanes & 536870912))
          (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
            null !== current &&
              pushTransition(
                workInProgress,
                null !== prevState ? prevState.cachePool : null
              ),
            null !== prevState
              ? pushHiddenContext(workInProgress, prevState)
              : reuseHiddenContextOnStack(workInProgress),
            pushOffscreenSuspenseHandler(workInProgress);
        else
          return (
            (workInProgress.lanes = workInProgress.childLanes = 536870912),
            deferHiddenOffscreenComponent(
              current,
              workInProgress,
              null !== prevState
                ? prevState.baseLanes | renderLanes
                : renderLanes,
              renderLanes
            )
          );
      } else
        null !== prevState
          ? (pushTransition(workInProgress, prevState.cachePool),
            pushHiddenContext(workInProgress, prevState),
            reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.memoizedState = null))
          : (null !== current && pushTransition(workInProgress, null),
            reuseHiddenContextOnStack(workInProgress),
            reuseSuspenseHandlerOnStack(workInProgress));
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function deferHiddenOffscreenComponent(
      current,
      workInProgress,
      nextBaseLanes,
      renderLanes
    ) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result =
        null === JSCompiler_inline_result
          ? null
          : {
              parent: CacheContext._currentValue,
              pool: JSCompiler_inline_result
            };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack(workInProgress);
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current &&
        propagateParentContextChanges(current, workInProgress, renderLanes, !0);
      return null;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref)
        null !== current &&
          null !== current.ref &&
          (workInProgress.flags |= 2097664);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        if (null === current || current.ref !== ref)
          workInProgress.flags |= 2097664;
      }
    }
    function updateFunctionComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (
        Component.prototype &&
        "function" === typeof Component.prototype.render
      ) {
        var componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName] ||
          (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName,
            componentName
          ),
          (didWarnAboutBadClass[componentName] = !0));
      }
      workInProgress.mode & StrictLegacyMode &&
        ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress,
          null
        );
      null === current &&
        (validateFunctionComponentInDev(workInProgress, workInProgress.type),
        Component.contextTypes &&
          ((componentName = getComponentNameFromType(Component) || "Unknown"),
          didWarnAboutContextTypes[componentName] ||
            ((didWarnAboutContextTypes[componentName] = !0),
            console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName
            ))));
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      Component = renderWithHooks(
        current,
        workInProgress,
        Component,
        nextProps,
        void 0,
        renderLanes
      );
      nextProps = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(
      current,
      workInProgress,
      nextProps,
      Component,
      secondArg,
      renderLanes
    ) {
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current, workInProgress);
      Component = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(
      current$jscomp$0,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      switch (shouldErrorImpl(workInProgress)) {
        case !1:
          var _instance = workInProgress.stateNode,
            state = new workInProgress.type(
              workInProgress.memoizedProps,
              _instance.context
            ).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case !0:
          workInProgress.flags |= 128;
          workInProgress.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes & -renderLanes;
          workInProgress.lanes |= lane;
          state = workInProgressRoot;
          if (null === state)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(
            lane,
            state,
            workInProgress,
            createCapturedValueAtFiber(_instance, workInProgress)
          );
          enqueueCapturedUpdate(workInProgress, lane);
      }
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component &&
          null !== _instance &&
          (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) &&
          !didWarnAboutInvalidateContextType.has(Component) &&
          (didWarnAboutInvalidateContextType.add(Component),
          (lane =
            void 0 === _instance
              ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
              : "object" !== typeof _instance
                ? " However, it is set to a " + typeof _instance + "."
                : _instance.$$typeof === REACT_CONSUMER_TYPE
                  ? " Did you accidentally pass the Context.Consumer instead?"
                  : " However, it is set to an object with keys {" +
                    Object.keys(_instance).join(", ") +
                    "}."),
          console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            getComponentNameFromType(Component) || "Component",
            lane
          ));
        "object" === typeof _instance &&
          null !== _instance &&
          (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        state = workInProgress.memoizedState =
          null !== _instance.state && void 0 !== _instance.state
            ? _instance.state
            : null;
        _instance.updater = classComponentUpdater;
        workInProgress.stateNode = _instance;
        _instance._reactInternals = workInProgress;
        _instance._reactInternalInstance = fakeInternalInstance;
        "function" === typeof Component.getDerivedStateFromProps &&
          null === state &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutUninitializedState.has(state) ||
            (didWarnAboutUninitializedState.add(state),
            console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
        if (
          "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate
        ) {
          var foundWillUpdateName = (lane = state = null);
          "function" === typeof _instance.componentWillMount &&
          !0 !== _instance.componentWillMount.__suppressDeprecationWarning
            ? (state = "componentWillMount")
            : "function" === typeof _instance.UNSAFE_componentWillMount &&
              (state = "UNSAFE_componentWillMount");
          "function" === typeof _instance.componentWillReceiveProps &&
          !0 !==
            _instance.componentWillReceiveProps.__suppressDeprecationWarning
            ? (lane = "componentWillReceiveProps")
            : "function" ===
                typeof _instance.UNSAFE_componentWillReceiveProps &&
              (lane = "UNSAFE_componentWillReceiveProps");
          "function" === typeof _instance.componentWillUpdate &&
          !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning
            ? (foundWillUpdateName = "componentWillUpdate")
            : "function" === typeof _instance.UNSAFE_componentWillUpdate &&
              (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (null !== state || null !== lane || null !== foundWillUpdateName) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName =
              "function" === typeof Component.getDerivedStateFromProps
                ? "getDerivedStateFromProps()"
                : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) ||
              (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance),
              console.error(
                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                _instance,
                newApiName,
                null !== state ? "\n  " + state : "",
                null !== lane ? "\n  " + lane : "",
                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
              ));
          }
        }
        _instance = workInProgress.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render ||
          (Component.prototype &&
          "function" === typeof Component.prototype.render
            ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                state
              )
            : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                state
              ));
        !_instance.getInitialState ||
          _instance.getInitialState.isReactClassApproved ||
          _instance.state ||
          console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            state
          );
        _instance.getDefaultProps &&
          !_instance.getDefaultProps.isReactClassApproved &&
          console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            state
          );
        _instance.contextType &&
          console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            state
          );
        Component.childContextTypes &&
          !didWarnAboutChildContextTypes.has(Component) &&
          (didWarnAboutChildContextTypes.add(Component),
          console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            state
          ));
        Component.contextTypes &&
          !didWarnAboutContextTypes$1.has(Component) &&
          (didWarnAboutContextTypes$1.add(Component),
          console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            state
          ));
        "function" === typeof _instance.componentShouldUpdate &&
          console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            state
          );
        Component.prototype &&
          Component.prototype.isPureReactComponent &&
          "undefined" !== typeof _instance.shouldComponentUpdate &&
          console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            getComponentNameFromType(Component) || "A pure component"
          );
        "function" === typeof _instance.componentDidUnmount &&
          console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            state
          );
        "function" === typeof _instance.componentDidReceiveProps &&
          console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            state
          );
        "function" === typeof _instance.componentWillRecieveProps &&
          console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            state
          );
        "function" === typeof _instance.UNSAFE_componentWillRecieveProps &&
          console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            state
          );
        lane = _instance.props !== nextProps;
        void 0 !== _instance.props &&
          lane &&
          console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            state
          );
        _instance.defaultProps &&
          console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            state,
            state
          );
        "function" !== typeof _instance.getSnapshotBeforeUpdate ||
          "function" === typeof _instance.componentDidUpdate ||
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) ||
          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component),
          console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            getComponentNameFromType(Component)
          ));
        "function" === typeof _instance.getDerivedStateFromProps &&
          console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof _instance.getDerivedStateFromError &&
          console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof Component.getSnapshotBeforeUpdate &&
          console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            state
          );
        (lane = _instance.state) &&
          ("object" !== typeof lane || isArrayImpl(lane)) &&
          console.error("%s.state: must be set to an object or null", state);
        "function" === typeof _instance.getChildContext &&
          "object" !== typeof Component.childContextTypes &&
          console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            state
          );
        _instance = workInProgress.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress);
        state = Component.contextType;
        _instance.context =
          "object" === typeof state && null !== state
            ? readContext(state)
            : emptyContextObject;
        _instance.state === nextProps &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutDirectlyAssigningPropsToState.has(state) ||
            (didWarnAboutDirectlyAssigningPropsToState.add(state),
            console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
        workInProgress.mode & StrictLegacyMode &&
          ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress,
            _instance
          );
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
          workInProgress,
          _instance
        );
        _instance.state = workInProgress.memoizedState;
        state = Component.getDerivedStateFromProps;
        "function" === typeof state &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            state,
            nextProps
          ),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate ||
          ("function" !== typeof _instance.UNSAFE_componentWillMount &&
            "function" !== typeof _instance.componentWillMount) ||
          ((state = _instance.state),
          "function" === typeof _instance.componentWillMount &&
            _instance.componentWillMount(),
          "function" === typeof _instance.UNSAFE_componentWillMount &&
            _instance.UNSAFE_componentWillMount(),
          state !== _instance.state &&
            (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress) || "Component"
            ),
            classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )),
          processUpdateQueue(workInProgress, nextProps, _instance, renderLanes),
          suspendIfUpdateReadFromEntangledAsyncAction(),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof _instance.componentDidMount &&
          (workInProgress.flags |= 4194308);
        (workInProgress.mode & StrictEffectsMode) !== NoMode &&
          (workInProgress.flags |= 67108864);
        _instance = !0;
      } else if (null === current$jscomp$0) {
        _instance = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        "object" === typeof foundWillUpdateName &&
          null !== foundWillUpdateName &&
          (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName =
          "function" === typeof newApiName ||
          "function" === typeof _instance.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        foundWillUpdateName ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((unresolvedOldProps || oldContext !== state) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              state
            ));
        hasForceUpdate = !1;
        var oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
          ? ("function" === typeof newApiName &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                newApiName,
                nextProps
              ),
              (oldContext = workInProgress.memoizedState)),
            (lane =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                lane,
                nextProps,
                oldState,
                oldContext,
                state
              ))
              ? (foundWillUpdateName ||
                  ("function" !== typeof _instance.UNSAFE_componentWillMount &&
                    "function" !== typeof _instance.componentWillMount) ||
                  ("function" === typeof _instance.componentWillMount &&
                    _instance.componentWillMount(),
                  "function" === typeof _instance.UNSAFE_componentWillMount &&
                    _instance.UNSAFE_componentWillMount()),
                "function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 67108864))
              : ("function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 67108864),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = oldContext)),
            (_instance.props = nextProps),
            (_instance.state = oldContext),
            (_instance.context = state),
            (_instance = lane))
          : ("function" === typeof _instance.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.mode & StrictEffectsMode) !== NoMode &&
              (workInProgress.flags |= 67108864),
            (_instance = !1));
      } else {
        _instance = workInProgress.stateNode;
        cloneUpdateQueue(current$jscomp$0, workInProgress);
        state = workInProgress.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        "object" === typeof oldContext &&
          null !== oldContext &&
          (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext =
          "function" === typeof unresolvedOldProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate) ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((state !== newApiName || oldState !== lane) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              lane
            ));
        hasForceUpdate = !1;
        oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        state !== newApiName ||
        oldState !== newState ||
        hasForceUpdate ||
        (null !== current$jscomp$0 &&
          null !== current$jscomp$0.dependencies &&
          checkIfContextChanged(current$jscomp$0.dependencies))
          ? ("function" === typeof unresolvedOldProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                unresolvedOldProps,
                nextProps
              ),
              (newState = workInProgress.memoizedState)),
            (foundWillUpdateName =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                foundWillUpdateName,
                nextProps,
                oldState,
                newState,
                lane
              ) ||
              (null !== current$jscomp$0 &&
                null !== current$jscomp$0.dependencies &&
                checkIfContextChanged(current$jscomp$0.dependencies)))
              ? (oldContext ||
                  ("function" !== typeof _instance.UNSAFE_componentWillUpdate &&
                    "function" !== typeof _instance.componentWillUpdate) ||
                  ("function" === typeof _instance.componentWillUpdate &&
                    _instance.componentWillUpdate(nextProps, newState, lane),
                  "function" === typeof _instance.UNSAFE_componentWillUpdate &&
                    _instance.UNSAFE_componentWillUpdate(
                      nextProps,
                      newState,
                      lane
                    )),
                "function" === typeof _instance.componentDidUpdate &&
                  (workInProgress.flags |= 4),
                "function" === typeof _instance.getSnapshotBeforeUpdate &&
                  (workInProgress.flags |= 1024))
              : ("function" !== typeof _instance.componentDidUpdate ||
                  (state === current$jscomp$0.memoizedProps &&
                    oldState === current$jscomp$0.memoizedState) ||
                  (workInProgress.flags |= 4),
                "function" !== typeof _instance.getSnapshotBeforeUpdate ||
                  (state === current$jscomp$0.memoizedProps &&
                    oldState === current$jscomp$0.memoizedState) ||
                  (workInProgress.flags |= 1024),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = newState)),
            (_instance.props = nextProps),
            (_instance.state = newState),
            (_instance.context = lane),
            (_instance = foundWillUpdateName))
          : ("function" !== typeof _instance.componentDidUpdate ||
              (state === current$jscomp$0.memoizedProps &&
                oldState === current$jscomp$0.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof _instance.getSnapshotBeforeUpdate ||
              (state === current$jscomp$0.memoizedProps &&
                oldState === current$jscomp$0.memoizedState) ||
              (workInProgress.flags |= 1024),
            (_instance = !1));
      }
      lane = _instance;
      markRef(current$jscomp$0, workInProgress);
      state = 0 !== (workInProgress.flags & 128);
      if (lane || state) {
        lane = workInProgress.stateNode;
        ReactSharedInternals.getCurrentStack =
          null === workInProgress ? null : getCurrentFiberStackInDev;
        isRendering = !1;
        current = workInProgress;
        if (state && "function" !== typeof Component.getDerivedStateFromError)
          (Component = null), (profilerStartTime = -1);
        else {
          markComponentRenderStarted(workInProgress);
          Component = callRenderInDEV(lane);
          if (workInProgress.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          markComponentRenderStopped();
        }
        workInProgress.flags |= 1;
        null !== current$jscomp$0 && state
          ? ((workInProgress.child = reconcileChildFibers(
              workInProgress,
              current$jscomp$0.child,
              null,
              renderLanes
            )),
            (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              Component,
              renderLanes
            )))
          : reconcileChildren(
              current$jscomp$0,
              workInProgress,
              Component,
              renderLanes
            );
        workInProgress.memoizedState = lane.state;
        current$jscomp$0 = workInProgress.child;
      } else
        current$jscomp$0 = bailoutOnAlreadyFinishedWork(
          current$jscomp$0,
          workInProgress,
          renderLanes
        );
      renderLanes = workInProgress.stateNode;
      _instance &&
        renderLanes.props !== nextProps &&
        (didWarnAboutReassigningProps ||
          console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress) || "a component"
          ),
        (didWarnAboutReassigningProps = !0));
      return current$jscomp$0;
    }
    function mountHostRootWithoutHydrating(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
      Component &&
        Component.childContextTypes &&
        console.error(
          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
          Component.displayName || Component.name || "Component"
        );
      "function" === typeof Component.getDerivedStateFromProps &&
        ((workInProgress = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] ||
          (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress
          ),
          (didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] =
            !0)));
      "object" === typeof Component.contextType &&
        null !== Component.contextType &&
        ((Component = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutContextTypeOnFunctionComponent[Component] ||
          (console.error(
            "%s: Function components do not support contextType.",
            Component
          ),
          (didWarnAboutContextTypeOnFunctionComponent[Component] = !0)));
    }
    function mountSuspenseOffscreenState(renderLanes) {
      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(
      current,
      primaryTreeDidDefer,
      renderLanes
    ) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var JSCompiler_object_inline_digest_2317;
      var JSCompiler_object_inline_stack_2318 = workInProgress.pendingProps;
      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
      var JSCompiler_object_inline_componentStack_2319 = !1;
      var didSuspend = 0 !== (workInProgress.flags & 128);
      (JSCompiler_object_inline_digest_2317 = didSuspend) ||
        (JSCompiler_object_inline_digest_2317 =
          null !== current && null === current.memoizedState
            ? !1
            : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
      JSCompiler_object_inline_digest_2317 &&
        ((JSCompiler_object_inline_componentStack_2319 = !0),
        (workInProgress.flags &= -129));
      JSCompiler_object_inline_digest_2317 = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          JSCompiler_object_inline_componentStack_2319
            ? pushPrimaryTreeSuspenseHandler(workInProgress)
            : reuseSuspenseHandlerOnStack(workInProgress);
          if (isHydrating) {
            var JSCompiler_object_inline_message_2316 = nextHydratableInstance;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2316)) {
              c: {
                var instance = JSCompiler_object_inline_message_2316;
                for (
                  JSCompiler_temp = rootOrSingletonContext;
                  8 !== instance.nodeType;

                ) {
                  if (!JSCompiler_temp) {
                    JSCompiler_temp = null;
                    break c;
                  }
                  instance = getNextHydratable(instance.nextSibling);
                  if (null === instance) {
                    JSCompiler_temp = null;
                    break c;
                  }
                }
                JSCompiler_temp = instance;
              }
              null !== JSCompiler_temp
                ? (warnIfNotHydrating(),
                  (workInProgress.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext:
                      null !== treeContextProvider
                        ? { id: treeContextId, overflow: treeContextOverflow }
                        : null,
                    retryLane: 536870912
                  }),
                  (instance = createFiber(18, null, null, NoMode)),
                  (instance.stateNode = JSCompiler_temp),
                  (instance.return = workInProgress),
                  (workInProgress.child = instance),
                  (hydrationParentFiber = workInProgress),
                  (nextHydratableInstance = null),
                  (JSCompiler_temp = !0))
                : (JSCompiler_temp = !1);
              JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp &&
              (warnNonHydratedInstance(
                workInProgress,
                JSCompiler_object_inline_message_2316
              ),
              throwOnHydrationMismatch(workInProgress));
          }
          JSCompiler_object_inline_message_2316 = workInProgress.memoizedState;
          if (
            null !== JSCompiler_object_inline_message_2316 &&
            ((JSCompiler_object_inline_message_2316 =
              JSCompiler_object_inline_message_2316.dehydrated),
            null !== JSCompiler_object_inline_message_2316)
          )
            return (
              JSCompiler_object_inline_message_2316.data ===
              SUSPENSE_FALLBACK_START_DATA
                ? (workInProgress.lanes = 16)
                : (workInProgress.lanes = 536870912),
              null
            );
          popSuspenseHandler(workInProgress);
        }
        JSCompiler_object_inline_message_2316 =
          JSCompiler_object_inline_stack_2318.children;
        JSCompiler_object_inline_stack_2318 =
          JSCompiler_object_inline_stack_2318.fallback;
        if (JSCompiler_object_inline_componentStack_2319)
          return (
            reuseSuspenseHandlerOnStack(workInProgress),
            (JSCompiler_object_inline_componentStack_2319 =
              workInProgress.mode),
            (JSCompiler_object_inline_message_2316 =
              mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2316
                },
                JSCompiler_object_inline_componentStack_2319
              )),
            (JSCompiler_object_inline_stack_2318 = createFiberFromFragment(
              JSCompiler_object_inline_stack_2318,
              JSCompiler_object_inline_componentStack_2319,
              renderLanes,
              null
            )),
            (JSCompiler_object_inline_message_2316.return = workInProgress),
            (JSCompiler_object_inline_stack_2318.return = workInProgress),
            (JSCompiler_object_inline_message_2316.sibling =
              JSCompiler_object_inline_stack_2318),
            (workInProgress.child = JSCompiler_object_inline_message_2316),
            (JSCompiler_object_inline_componentStack_2319 =
              workInProgress.child),
            (JSCompiler_object_inline_componentStack_2319.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (JSCompiler_object_inline_componentStack_2319.childLanes =
              getRemainingWorkInPrimaryTree(
                current,
                JSCompiler_object_inline_digest_2317,
                renderLanes
              )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            JSCompiler_object_inline_stack_2318
          );
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(
          workInProgress,
          JSCompiler_object_inline_message_2316
        );
      }
      var prevState = current.memoizedState;
      if (
        null !== prevState &&
        ((JSCompiler_object_inline_message_2316 = prevState.dehydrated),
        null !== JSCompiler_object_inline_message_2316)
      ) {
        if (didSuspend)
          workInProgress.flags & 256
            ? (pushPrimaryTreeSuspenseHandler(workInProgress),
              (workInProgress.flags &= -257),
              (workInProgress = retrySuspenseComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes
              )))
            : null !== workInProgress.memoizedState
              ? (reuseSuspenseHandlerOnStack(workInProgress),
                (workInProgress.child = current.child),
                (workInProgress.flags |= 128),
                (workInProgress = null))
              : (reuseSuspenseHandlerOnStack(workInProgress),
                (JSCompiler_object_inline_componentStack_2319 =
                  JSCompiler_object_inline_stack_2318.fallback),
                (JSCompiler_object_inline_message_2316 = workInProgress.mode),
                (JSCompiler_object_inline_stack_2318 =
                  mountWorkInProgressOffscreenFiber(
                    {
                      mode: "visible",
                      children: JSCompiler_object_inline_stack_2318.children
                    },
                    JSCompiler_object_inline_message_2316
                  )),
                (JSCompiler_object_inline_componentStack_2319 =
                  createFiberFromFragment(
                    JSCompiler_object_inline_componentStack_2319,
                    JSCompiler_object_inline_message_2316,
                    renderLanes,
                    null
                  )),
                (JSCompiler_object_inline_componentStack_2319.flags |= 2),
                (JSCompiler_object_inline_stack_2318.return = workInProgress),
                (JSCompiler_object_inline_componentStack_2319.return =
                  workInProgress),
                (JSCompiler_object_inline_stack_2318.sibling =
                  JSCompiler_object_inline_componentStack_2319),
                (workInProgress.child = JSCompiler_object_inline_stack_2318),
                reconcileChildFibers(
                  workInProgress,
                  current.child,
                  null,
                  renderLanes
                ),
                (JSCompiler_object_inline_stack_2318 = workInProgress.child),
                (JSCompiler_object_inline_stack_2318.memoizedState =
                  mountSuspenseOffscreenState(renderLanes)),
                (JSCompiler_object_inline_stack_2318.childLanes =
                  getRemainingWorkInPrimaryTree(
                    current,
                    JSCompiler_object_inline_digest_2317,
                    renderLanes
                  )),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                (workInProgress =
                  JSCompiler_object_inline_componentStack_2319));
        else if (
          (pushPrimaryTreeSuspenseHandler(workInProgress),
          isHydrating &&
            console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ),
          JSCompiler_object_inline_message_2316.data ===
            SUSPENSE_FALLBACK_START_DATA)
        ) {
          JSCompiler_object_inline_digest_2317 =
            JSCompiler_object_inline_message_2316.nextSibling &&
            JSCompiler_object_inline_message_2316.nextSibling.dataset;
          if (JSCompiler_object_inline_digest_2317) {
            JSCompiler_temp = JSCompiler_object_inline_digest_2317.dgst;
            var message = JSCompiler_object_inline_digest_2317.msg;
            instance = JSCompiler_object_inline_digest_2317.stck;
            var componentStack = JSCompiler_object_inline_digest_2317.cstck;
          }
          JSCompiler_object_inline_message_2316 = message;
          JSCompiler_object_inline_digest_2317 = JSCompiler_temp;
          JSCompiler_object_inline_stack_2318 = instance;
          JSCompiler_temp = JSCompiler_object_inline_componentStack_2319 =
            componentStack;
          JSCompiler_object_inline_componentStack_2319 =
            JSCompiler_object_inline_message_2316
              ? Error(JSCompiler_object_inline_message_2316)
              : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
          JSCompiler_object_inline_componentStack_2319.stack =
            JSCompiler_object_inline_stack_2318 || "";
          JSCompiler_object_inline_componentStack_2319.digest =
            JSCompiler_object_inline_digest_2317;
          JSCompiler_object_inline_digest_2317 =
            void 0 === JSCompiler_temp ? null : JSCompiler_temp;
          JSCompiler_object_inline_stack_2318 = {
            value: JSCompiler_object_inline_componentStack_2319,
            source: null,
            stack: JSCompiler_object_inline_digest_2317
          };
          "string" === typeof JSCompiler_object_inline_digest_2317 &&
            CapturedStacks.set(
              JSCompiler_object_inline_componentStack_2319,
              JSCompiler_object_inline_stack_2318
            );
          queueHydrationError(JSCompiler_object_inline_stack_2318);
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          );
        } else if (
          (didReceiveUpdate ||
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
          (JSCompiler_object_inline_digest_2317 =
            0 !== (renderLanes & current.childLanes)),
          didReceiveUpdate || JSCompiler_object_inline_digest_2317)
        ) {
          JSCompiler_object_inline_digest_2317 = workInProgressRoot;
          if (null !== JSCompiler_object_inline_digest_2317) {
            JSCompiler_object_inline_stack_2318 = renderLanes & -renderLanes;
            if (0 !== (JSCompiler_object_inline_stack_2318 & 42))
              JSCompiler_object_inline_stack_2318 = 1;
            else
              switch (JSCompiler_object_inline_stack_2318) {
                case 2:
                  JSCompiler_object_inline_stack_2318 = 1;
                  break;
                case 8:
                  JSCompiler_object_inline_stack_2318 = 4;
                  break;
                case 32:
                  JSCompiler_object_inline_stack_2318 = 16;
                  break;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  JSCompiler_object_inline_stack_2318 = 64;
                  break;
                case 268435456:
                  JSCompiler_object_inline_stack_2318 = 134217728;
                  break;
                default:
                  JSCompiler_object_inline_stack_2318 = 0;
              }
            JSCompiler_object_inline_stack_2318 =
              0 !==
              (JSCompiler_object_inline_stack_2318 &
                (JSCompiler_object_inline_digest_2317.suspendedLanes |
                  renderLanes))
                ? 0
                : JSCompiler_object_inline_stack_2318;
            if (
              0 !== JSCompiler_object_inline_stack_2318 &&
              JSCompiler_object_inline_stack_2318 !== prevState.retryLane
            )
              throw (
                ((prevState.retryLane = JSCompiler_object_inline_stack_2318),
                enqueueConcurrentRenderForLane(
                  current,
                  JSCompiler_object_inline_stack_2318
                ),
                scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2317,
                  current,
                  JSCompiler_object_inline_stack_2318
                ),
                SelectiveHydrationException)
              );
          }
          JSCompiler_object_inline_message_2316.data ===
            SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
          workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          );
        } else
          JSCompiler_object_inline_message_2316.data ===
          SUSPENSE_PENDING_START_DATA
            ? ((workInProgress.flags |= 128),
              (workInProgress.child = current.child),
              (workInProgress = retryDehydratedSuspenseBoundary.bind(
                null,
                current
              )),
              (JSCompiler_object_inline_message_2316._reactRetry =
                workInProgress),
              (workInProgress = null))
            : ((current = prevState.treeContext),
              (nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2316.nextSibling
              )),
              (hydrationParentFiber = workInProgress),
              (isHydrating = !0),
              (hydrationErrors = null),
              (didSuspendOrErrorDEV = !1),
              (hydrationDiffRootDEV = null),
              (rootOrSingletonContext = !1),
              null !== current &&
                (warnIfNotHydrating(),
                (idStack[idStackIndex++] = treeContextId),
                (idStack[idStackIndex++] = treeContextOverflow),
                (idStack[idStackIndex++] = treeContextProvider),
                (treeContextId = current.id),
                (treeContextOverflow = current.overflow),
                (treeContextProvider = workInProgress)),
              (workInProgress = mountSuspensePrimaryChildren(
                workInProgress,
                JSCompiler_object_inline_stack_2318.children
              )),
              (workInProgress.flags |= 4096));
        return workInProgress;
      }
      if (JSCompiler_object_inline_componentStack_2319)
        return (
          reuseSuspenseHandlerOnStack(workInProgress),
          (JSCompiler_object_inline_componentStack_2319 =
            JSCompiler_object_inline_stack_2318.fallback),
          (JSCompiler_object_inline_message_2316 = workInProgress.mode),
          (JSCompiler_temp = current.child),
          (instance = JSCompiler_temp.sibling),
          (JSCompiler_object_inline_stack_2318 = createWorkInProgress(
            JSCompiler_temp,
            {
              mode: "hidden",
              children: JSCompiler_object_inline_stack_2318.children
            }
          )),
          (JSCompiler_object_inline_stack_2318.subtreeFlags =
            JSCompiler_temp.subtreeFlags & 31457280),
          null !== instance
            ? (JSCompiler_object_inline_componentStack_2319 =
                createWorkInProgress(
                  instance,
                  JSCompiler_object_inline_componentStack_2319
                ))
            : ((JSCompiler_object_inline_componentStack_2319 =
                createFiberFromFragment(
                  JSCompiler_object_inline_componentStack_2319,
                  JSCompiler_object_inline_message_2316,
                  renderLanes,
                  null
                )),
              (JSCompiler_object_inline_componentStack_2319.flags |= 2)),
          (JSCompiler_object_inline_componentStack_2319.return =
            workInProgress),
          (JSCompiler_object_inline_stack_2318.return = workInProgress),
          (JSCompiler_object_inline_stack_2318.sibling =
            JSCompiler_object_inline_componentStack_2319),
          (workInProgress.child = JSCompiler_object_inline_stack_2318),
          (JSCompiler_object_inline_stack_2318 =
            JSCompiler_object_inline_componentStack_2319),
          (JSCompiler_object_inline_componentStack_2319 = workInProgress.child),
          (JSCompiler_object_inline_message_2316 = current.child.memoizedState),
          null === JSCompiler_object_inline_message_2316
            ? (JSCompiler_object_inline_message_2316 =
                mountSuspenseOffscreenState(renderLanes))
            : ((JSCompiler_temp =
                JSCompiler_object_inline_message_2316.cachePool),
              null !== JSCompiler_temp
                ? ((instance = CacheContext._currentValue),
                  (JSCompiler_temp =
                    JSCompiler_temp.parent !== instance
                      ? { parent: instance, pool: instance }
                      : JSCompiler_temp))
                : (JSCompiler_temp = getSuspendedCache()),
              (JSCompiler_object_inline_message_2316 = {
                baseLanes:
                  JSCompiler_object_inline_message_2316.baseLanes | renderLanes,
                cachePool: JSCompiler_temp
              })),
          (JSCompiler_object_inline_componentStack_2319.memoizedState =
            JSCompiler_object_inline_message_2316),
          (JSCompiler_object_inline_componentStack_2319.childLanes =
            getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_object_inline_digest_2317,
              renderLanes
            )),
          (workInProgress.memoizedState = SUSPENDED_MARKER),
          JSCompiler_object_inline_stack_2318
        );
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2318.children
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current &&
        ((JSCompiler_object_inline_digest_2317 = workInProgress.deletions),
        null === JSCompiler_object_inline_digest_2317
          ? ((workInProgress.deletions = [current]),
            (workInProgress.flags |= 16))
          : JSCompiler_object_inline_digest_2317.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress.mode
      );
      primaryChildren.return = workInProgress;
      return (workInProgress.child = primaryChildren);
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      return createFiberFromOffscreen(offscreenProps, mode, 0, null);
    }
    function retrySuspenseComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(
        workInProgress,
        workInProgress.pendingProps.children
      );
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(
        fiber.return,
        renderLanes,
        propagationRoot
      );
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
      return isAnArray || childSlot
        ? ((isAnArray = isAnArray ? "array" : "iterable"),
          console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ),
          !1)
        : !0;
    }
    function initSuspenseListRenderState(
      workInProgress,
      isBackwards,
      tail,
      lastContentRow,
      tailMode
    ) {
      var renderState = workInProgress.memoizedState;
      null === renderState
        ? (workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode
          })
        : ((renderState.isBackwards = isBackwards),
          (renderState.rendering = null),
          (renderState.renderingStartTime = 0),
          (renderState.last = lastContentRow),
          (renderState.tail = tail),
          (renderState.tailMode = tailMode));
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
      nextProps = nextProps.children;
      if (
        void 0 !== revealOrder &&
        "forwards" !== revealOrder &&
        "backwards" !== revealOrder &&
        "together" !== revealOrder &&
        !didWarnAboutRevealOrder[revealOrder]
      )
        if (
          ((didWarnAboutRevealOrder[revealOrder] = !0),
          "string" === typeof revealOrder)
        )
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            revealOrder
          );
      void 0 === tailMode ||
        didWarnAboutTailOptions[tailMode] ||
        ("collapsed" !== tailMode && "hidden" !== tailMode
          ? ((didWarnAboutTailOptions[tailMode] = !0),
            console.error(
              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
              tailMode
            ))
          : "forwards" !== revealOrder &&
            "backwards" !== revealOrder &&
            ((didWarnAboutTailOptions[tailMode] = !0),
            console.error(
              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
              tailMode
            )));
      a: if (
        ("forwards" === revealOrder || "backwards" === revealOrder) &&
        void 0 !== nextProps &&
        null !== nextProps &&
        !1 !== nextProps
      )
        if (isArrayImpl(nextProps))
          for (var i = 0; i < nextProps.length; i++) {
            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
          }
        else if (((i = getIteratorFn(nextProps)), "function" === typeof i)) {
          if ((i = i.call(nextProps)))
            for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) break a;
              _i++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            revealOrder
          );
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & ForceSuspenseFallback))
        (nextProps =
          (nextProps & SubtreeSuspenseContextMask) | ForceSuspenseFallback),
          (workInProgress.flags |= 128);
      else {
        if (null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState &&
                scheduleSuspenseWorkOnFiber(
                  current,
                  renderLanes,
                  workInProgress
                );
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        nextProps &= SubtreeSuspenseContextMask;
      }
      push(suspenseStackCursor, nextProps, workInProgress);
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes; )
            (current = renderLanes.alternate),
              null !== current &&
                null === findFirstSuspended(current) &&
                (revealOrder = renderLanes),
              (renderLanes = renderLanes.sibling);
          renderLanes = revealOrder;
          null === renderLanes
            ? ((revealOrder = workInProgress.child),
              (workInProgress.child = null))
            : ((revealOrder = renderLanes.sibling),
              (renderLanes.sibling = null));
          initSuspenseListRenderState(
            workInProgress,
            !1,
            revealOrder,
            renderLanes,
            tailMode
          );
          break;
        case "backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress,
            !0,
            renderLanes,
            null,
            tailMode
          );
          break;
        case "together":
          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes
    ) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes))
        if (null !== current) {
          if (
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            0 === (renderLanes & workInProgress.childLanes))
          )
            return null;
        } else return null;
      if (null !== current && workInProgress.child !== current.child)
        throw Error("Resuming work not yet implemented.");
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling; )
          (current = current.sibling),
            (renderLanes = renderLanes.sibling =
              createWorkInProgress(current, current.pendingProps)),
            (renderLanes.return = workInProgress);
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return !0;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(
      current,
      workInProgress,
      renderLanes
    ) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          break;
        case 10:
          pushProvider(
            workInProgress,
            workInProgress.type,
            workInProgress.memoizedProps.value
          );
          break;
        case 12:
          0 !== (renderLanes & workInProgress.childLanes) &&
            (workInProgress.flags |= 4);
          workInProgress.flags |= 2048;
          var stateNode = workInProgress.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 13:
          stateNode = workInProgress.memoizedState;
          if (null !== stateNode) {
            if (null !== stateNode.dehydrated)
              return (
                pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags |= 128),
                null
              );
            if (0 !== (renderLanes & workInProgress.child.childLanes))
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderLanes
              );
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
          stateNode ||
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            (stateNode = 0 !== (renderLanes & workInProgress.childLanes)));
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(
                current,
                workInProgress,
                renderLanes
              );
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore &&
            ((didSuspendBefore.rendering = null),
            (didSuspendBefore.tail = null),
            (didSuspendBefore.lastEffect = null));
          push(
            suspenseStackCursor,
            suspenseStackCursor.current,
            workInProgress
          );
          if (stateNode) break;
          else return null;
        case 22:
        case 23:
          return (
            (workInProgress.lanes = 0),
            updateOffscreenComponent(current, workInProgress, renderLanes)
          );
        case 24:
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (workInProgress._debugNeedsRemount && null !== current) {
        renderLanes = createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes
        );
        var returnFiber = workInProgress.return;
        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
        current.alternate = null;
        workInProgress.alternate = null;
        renderLanes.index = workInProgress.index;
        renderLanes.sibling = workInProgress.sibling;
        renderLanes.return = workInProgress.return;
        renderLanes.ref = workInProgress.ref;
        renderLanes._debugInfo = workInProgress._debugInfo;
        if (workInProgress === returnFiber.child)
          returnFiber.child = renderLanes;
        else {
          var prevSibling = returnFiber.child;
          if (null === prevSibling)
            throw Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== workInProgress; )
            if (((prevSibling = prevSibling.sibling), null === prevSibling))
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes;
        }
        workInProgress = returnFiber.deletions;
        null === workInProgress
          ? ((returnFiber.deletions = [current]), (returnFiber.flags |= 16))
          : workInProgress.push(current);
        renderLanes.flags |= 2;
        return renderLanes;
      }
      if (null !== current)
        if (
          current.memoizedProps !== workInProgress.pendingProps ||
          workInProgress.type !== current.type
        )
          didReceiveUpdate = !0;
        else {
          if (
            !checkScheduledUpdateOrContext(current, renderLanes) &&
            0 === (workInProgress.flags & 128)
          )
            return (
              (didReceiveUpdate = !1),
              attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress,
                renderLanes
              )
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
        }
      else {
        didReceiveUpdate = !1;
        if ((returnFiber = isHydrating))
          warnIfNotHydrating(),
            (returnFiber = 0 !== (workInProgress.flags & 1048576));
        returnFiber &&
          ((returnFiber = workInProgress.index),
          warnIfNotHydrating(),
          pushTreeId(workInProgress, treeForkCount, returnFiber));
      }
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: if (
            ((returnFiber = workInProgress.pendingProps),
            (current = callLazyInitInDEV(workInProgress.elementType)),
            (workInProgress.type = current),
            "function" === typeof current)
          )
            shouldConstruct(current)
              ? ((returnFiber = resolveClassComponentProps(
                  current,
                  returnFiber
                )),
                (workInProgress.tag = 1),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateClassComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )))
              : ((workInProgress.tag = 0),
                validateFunctionComponentInDev(workInProgress, current),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateFunctionComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )));
          else {
            if (void 0 !== current && null !== current)
              if (
                ((prevSibling = current.$$typeof),
                prevSibling === REACT_FORWARD_REF_TYPE)
              ) {
                workInProgress.tag = 11;
                workInProgress.type = current =
                  resolveForwardRefForHotReloading(current);
                workInProgress = updateForwardRef(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else if (prevSibling === REACT_MEMO_TYPE) {
                workInProgress.tag = 14;
                workInProgress = updateMemoComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              }
            workInProgress = "";
            null !== current &&
              "object" === typeof current &&
              current.$$typeof === REACT_LAZY_TYPE &&
              (workInProgress =
                " Did you wrap a component in React.lazy() more than once?");
            current = getComponentNameFromType(current) || current;
            throw Error(
              "Element type is invalid. Received a promise that resolves to: " +
                current +
                ". Lazy element type must resolve to a class or function." +
                workInProgress
            );
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 1:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = resolveClassComponentProps(
              returnFiber,
              workInProgress.pendingProps
            )),
            updateClassComponent(
              current,
              workInProgress,
              returnFiber,
              prevSibling,
              renderLanes
            )
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            );
            if (null === current)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            var nextProps = workInProgress.pendingProps;
            prevSibling = workInProgress.memoizedState;
            returnFiber = prevSibling.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, nextProps, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            nextProps = nextState.cache;
            pushProvider(workInProgress, CacheContext, nextProps);
            nextProps !== prevSibling.cache &&
              propagateContextChanges(
                workInProgress,
                [CacheContext],
                renderLanes,
                !0
              );
            suspendIfUpdateReadFromEntangledAsyncAction();
            nextProps = nextState.element;
            if (prevSibling.isDehydrated)
              if (
                ((prevSibling = {
                  element: nextProps,
                  isDehydrated: !1,
                  cache: nextState.cache
                }),
                (workInProgress.updateQueue.baseState = prevSibling),
                (workInProgress.memoizedState = prevSibling),
                workInProgress.flags & 256)
              ) {
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  nextProps,
                  renderLanes
                );
                break a;
              } else if (nextProps !== returnFiber) {
                returnFiber = createCapturedValueAtFiber(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  workInProgress
                );
                queueHydrationError(returnFiber);
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  nextProps,
                  renderLanes
                );
                break a;
              } else
                for (
                  nextHydratableInstance = getNextHydratable(
                    workInProgress.stateNode.containerInfo.firstChild
                  ),
                    hydrationParentFiber = workInProgress,
                    isHydrating = !0,
                    hydrationErrors = null,
                    didSuspendOrErrorDEV = !1,
                    hydrationDiffRootDEV = null,
                    rootOrSingletonContext = !0,
                    current = mountChildFibers(
                      workInProgress,
                      null,
                      nextProps,
                      renderLanes
                    ),
                    workInProgress.child = current;
                  current;

                )
                  (current.flags = (current.flags & -3) | 4096),
                    (current = current.sibling);
            else {
              resetHydrationState();
              if (nextProps === returnFiber) {
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderLanes
                );
                break a;
              }
              reconcileChildren(
                current,
                workInProgress,
                nextProps,
                renderLanes
              );
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return (
            markRef(current, workInProgress),
            null === current
              ? (current = getResource(
                  workInProgress.type,
                  null,
                  workInProgress.pendingProps,
                  null
                ))
                ? (workInProgress.memoizedState = current)
                : isHydrating ||
                  ((current = workInProgress.type),
                  (renderLanes = workInProgress.pendingProps),
                  (returnFiber = requiredContext(
                    rootInstanceStackCursor.current
                  )),
                  (returnFiber =
                    getOwnerDocumentFromRootContainer(
                      returnFiber
                    ).createElement(current)),
                  (returnFiber[internalInstanceKey] = workInProgress),
                  (returnFiber[internalPropsKey] = renderLanes),
                  setInitialProperties(returnFiber, current, renderLanes),
                  markNodeAsHoistable(returnFiber),
                  (workInProgress.stateNode = returnFiber))
              : (workInProgress.memoizedState = getResource(
                  workInProgress.type,
                  current.memoizedProps,
                  workInProgress.pendingProps,
                  current.memoizedState
                )),
            null
          );
        case 27:
          return (
            pushHostContext(workInProgress),
            null === current &&
              isHydrating &&
              ((prevSibling = requiredContext(rootInstanceStackCursor.current)),
              (returnFiber = getHostContext()),
              (prevSibling = workInProgress.stateNode =
                resolveSingletonInstance(
                  workInProgress.type,
                  workInProgress.pendingProps,
                  prevSibling,
                  returnFiber,
                  !1
                )),
              didSuspendOrErrorDEV ||
                ((returnFiber = diffHydratedProperties(
                  prevSibling,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  returnFiber
                )),
                null !== returnFiber &&
                  (buildHydrationDiffNode(workInProgress, 0).serverProps =
                    returnFiber)),
              (hydrationParentFiber = workInProgress),
              (rootOrSingletonContext = !0),
              (nextHydratableInstance = getNextHydratable(
                prevSibling.firstChild
              ))),
            (returnFiber = workInProgress.pendingProps.children),
            null !== current || isHydrating
              ? reconcileChildren(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                )
              : (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                )),
            markRef(current, workInProgress),
            workInProgress.child
          );
        case 5:
          return (
            null === current &&
              isHydrating &&
              ((nextProps = getHostContext()),
              (returnFiber = validateDOMNesting(
                workInProgress.type,
                nextProps.ancestorInfo
              )),
              (prevSibling = nextHydratableInstance),
              (nextState = !prevSibling) ||
                ((nextState = canHydrateInstance(
                  prevSibling,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== nextState
                  ? ((workInProgress.stateNode = nextState),
                    didSuspendOrErrorDEV ||
                      ((nextProps = diffHydratedProperties(
                        nextState,
                        workInProgress.type,
                        workInProgress.pendingProps,
                        nextProps
                      )),
                      null !== nextProps &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          nextProps)),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = getNextHydratable(
                      nextState.firstChild
                    )),
                    (rootOrSingletonContext = !1),
                    (nextProps = !0))
                  : (nextProps = !1),
                (nextState = !nextProps)),
              nextState &&
                (returnFiber &&
                  warnNonHydratedInstance(workInProgress, prevSibling),
                throwOnHydrationMismatch(workInProgress))),
            pushHostContext(workInProgress),
            (prevSibling = workInProgress.type),
            (nextProps = workInProgress.pendingProps),
            (nextState = null !== current ? current.memoizedProps : null),
            (returnFiber = nextProps.children),
            shouldSetTextContent(prevSibling, nextProps)
              ? (returnFiber = null)
              : null !== nextState &&
                shouldSetTextContent(prevSibling, nextState) &&
                (workInProgress.flags |= 32),
            null !== workInProgress.memoizedState &&
              ((prevSibling = renderWithHooks(
                current,
                workInProgress,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes
              )),
              (HostTransitionContext._currentValue = prevSibling)),
            markRef(current, workInProgress),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 6:
          return (
            null === current &&
              isHydrating &&
              ((current = workInProgress.pendingProps),
              (renderLanes = getHostContext().ancestorInfo.current),
              (current =
                null != renderLanes
                  ? validateTextNesting(current, renderLanes.tag)
                  : !0),
              (renderLanes = nextHydratableInstance),
              (returnFiber = !renderLanes) ||
                ((returnFiber = canHydrateTextInstance(
                  renderLanes,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== returnFiber
                  ? ((workInProgress.stateNode = returnFiber),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null),
                    (returnFiber = !0))
                  : (returnFiber = !1),
                (returnFiber = !returnFiber)),
              returnFiber &&
                (current &&
                  warnNonHydratedInstance(workInProgress, renderLanes),
                throwOnHydrationMismatch(workInProgress))),
            null
          );
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return (
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            ),
            (returnFiber = workInProgress.pendingProps),
            null === current
              ? (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                ))
              : reconcileChildren(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                ),
            workInProgress.child
          );
        case 11:
          return updateForwardRef(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 7:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps,
              renderLanes
            ),
            workInProgress.child
          );
        case 8:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 12:
          return (
            (workInProgress.flags |= 4),
            (workInProgress.flags |= 2048),
            (returnFiber = workInProgress.stateNode),
            (returnFiber.effectDuration = -0),
            (returnFiber.passiveEffectDuration = -0),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 10:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = workInProgress.pendingProps),
            (nextProps = prevSibling.value),
            "value" in prevSibling ||
              hasWarnedAboutUsingNoValuePropOnContextProvider ||
              ((hasWarnedAboutUsingNoValuePropOnContextProvider = !0),
              console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )),
            pushProvider(workInProgress, returnFiber, nextProps),
            reconcileChildren(
              current,
              workInProgress,
              prevSibling.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 9:
          return (
            (prevSibling = workInProgress.type._context),
            (returnFiber = workInProgress.pendingProps.children),
            "function" !== typeof returnFiber &&
              console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ),
            prepareToReadContext(workInProgress),
            (prevSibling = readContext(prevSibling)),
            markComponentRenderStarted(workInProgress),
            (returnFiber = callComponentInDEV(
              returnFiber,
              prevSibling,
              void 0
            )),
            markComponentRenderStopped(),
            (workInProgress.flags |= 1),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 14:
          return updateMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 19:
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        case 22:
          return updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          return (
            prepareToReadContext(workInProgress),
            (returnFiber = readContext(CacheContext)),
            null === current
              ? ((prevSibling = peekCacheFromPool()),
                null === prevSibling &&
                  ((prevSibling = workInProgressRoot),
                  (nextProps = createCache()),
                  (prevSibling.pooledCache = nextProps),
                  retainCache(nextProps),
                  null !== nextProps &&
                    (prevSibling.pooledCacheLanes |= renderLanes),
                  (prevSibling = nextProps)),
                (workInProgress.memoizedState = {
                  parent: returnFiber,
                  cache: prevSibling
                }),
                initializeUpdateQueue(workInProgress),
                pushProvider(workInProgress, CacheContext, prevSibling))
              : (0 !== (current.lanes & renderLanes) &&
                  (cloneUpdateQueue(current, workInProgress),
                  processUpdateQueue(workInProgress, null, null, renderLanes),
                  suspendIfUpdateReadFromEntangledAsyncAction()),
                (prevSibling = current.memoizedState),
                (nextProps = workInProgress.memoizedState),
                prevSibling.parent !== returnFiber
                  ? ((prevSibling = {
                      parent: returnFiber,
                      cache: returnFiber
                    }),
                    (workInProgress.memoizedState = prevSibling),
                    0 === workInProgress.lanes &&
                      (workInProgress.memoizedState =
                        workInProgress.updateQueue.baseState =
                          prevSibling),
                    pushProvider(workInProgress, CacheContext, returnFiber))
                  : ((returnFiber = nextProps.cache),
                    pushProvider(workInProgress, CacheContext, returnFiber),
                    returnFiber !== prevSibling.cache &&
                      propagateContextChanges(
                        workInProgress,
                        [CacheContext],
                        renderLanes,
                        !0
                      ))),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber = null;
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      void 0 !== context._currentRenderer &&
        null !== context._currentRenderer &&
        context._currentRenderer !== rendererSigil &&
        console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(
      parent,
      renderLanes,
      propagationRoot
    ) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes
          ? ((parent.childLanes |= renderLanes),
            null !== alternate && (alternate.childLanes |= renderLanes))
          : null !== alternate &&
            (alternate.childLanes & renderLanes) !== renderLanes &&
            (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
      parent !== propagationRoot &&
        console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
    }
    function propagateContextChanges(
      workInProgress,
      contexts,
      renderLanes,
      forcePropagateEntireTree
    ) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes,
                  workInProgress
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(
            nextFiber,
            renderLanes,
            workInProgress
          );
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(
      current,
      workInProgress,
      renderLanes,
      forcePropagateEntireTree
    ) {
      current = null;
      for (
        var parent = workInProgress, isInsidePropagationBailout = !1;
        null !== parent;

      ) {
        if (!isInsidePropagationBailout)
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
          else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) ||
              (null !== current
                ? current.push(context)
                : (current = [context]));
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !==
            parent.memoizedState.memoizedState &&
            (null !== current
              ? current.push(HostTransitionContext)
              : (current = [HostTransitionContext]));
        }
        parent = parent.return;
      }
      null !== current &&
        propagateContextChanges(
          workInProgress,
          current,
          renderLanes,
          forcePropagateEntireTree
        );
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (
        currentDependencies = currentDependencies.firstContext;
        null !== currentDependencies;

      ) {
        if (
          !objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          )
        )
          return !0;
        currentDependencies = currentDependencies.next;
      }
      return !1;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV &&
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      return readContextForConsumer(currentlyRenderingFiber, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context: context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current &&
        (workInProgress.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
    }
    function createUpdate(lane) {
      return {
        lane: lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (
        currentlyProcessingQueue === updateQueue &&
        !didWarnUpdateInsideUpdate
      ) {
        var componentName = getComponentNameFromFiber(fiber);
        console.error(
          "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
          componentName
        );
        didWarnUpdateInsideUpdate = !0;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return (
          (componentName = updateQueue.pending),
          null === componentName
            ? (update.next = update)
            : ((update.next = componentName.next),
              (componentName.next = update)),
          (updateQueue.pending = update),
          (update = getRootForUpdatedFiber(fiber)),
          markUpdateLaneFromFiberToRoot(fiber, null, lane),
          update
        );
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (
        null !== current &&
        ((current = current.updateQueue), queue === current)
      ) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast
              ? (newFirst = newLast = clone)
              : (newLast = newLast.next = clone);
            queue = queue.next;
          } while (null !== queue);
          null === newLast
            ? (newFirst = newLast = capturedUpdate)
            : (newLast = newLast.next = capturedUpdate);
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress
        ? (queue.firstBaseUpdate = capturedUpdate)
        : (workInProgress.next = capturedUpdate);
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(
      workInProgress,
      props,
      instance$jscomp$0,
      renderLanes
    ) {
      didReadFromEntangledAsyncAction = !1;
      var queue = workInProgress.updateQueue;
      hasForceUpdate = !1;
      currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate
          ? (firstBaseUpdate = firstPendingUpdate)
          : (lastBaseUpdate.next = firstPendingUpdate);
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress.alternate;
        null !== current &&
          ((current = current.updateQueue),
          (pendingQueue = current.lastBaseUpdate),
          pendingQueue !== lastBaseUpdate &&
            (null === pendingQueue
              ? (current.firstBaseUpdate = firstPendingUpdate)
              : (pendingQueue.next = firstPendingUpdate),
            (current.lastBaseUpdate = lastPendingUpdate)));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (
            isHiddenUpdate
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            0 !== updateLane &&
              updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction = !0);
            null !== current &&
              (current = current.next =
                {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
            a: {
              updateLane = workInProgress;
              var partialState = pendingQueue;
              var nextProps = props,
                instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if ("function" === typeof partialState) {
                    isDisallowedContextReadInDEV = !0;
                    var nextState = partialState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = (updateLane.flags & -65537) | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if ("function" === typeof nextState) {
                    isDisallowedContextReadInDEV = !0;
                    partialState = nextState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                  } else partialState = nextState;
                  if (null === partialState || void 0 === partialState) break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = !0;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane &&
              ((workInProgress.flags |= 64),
              isHiddenUpdate && (workInProgress.flags |= 8192),
              (isHiddenUpdate = queue.callbacks),
              null === isHiddenUpdate
                ? (queue.callbacks = [updateLane])
                : isHiddenUpdate.push(updateLane));
          } else
            (isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }),
              null === current
                ? ((firstPendingUpdate = current = isHiddenUpdate),
                  (lastPendingUpdate = newState))
                : (current = current.next = isHiddenUpdate),
              (lastBaseUpdate |= updateLane);
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
              break;
            else
              (isHiddenUpdate = pendingQueue),
                (pendingQueue = isHiddenUpdate.next),
                (isHiddenUpdate.next = null),
                (queue.lastBaseUpdate = isHiddenUpdate),
                (queue.shared.pending = null);
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress.lanes = lastBaseUpdate;
        workInProgress.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " +
            callback
        );
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (null !== hiddenCallbacks)
        for (
          updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;
          updateQueue < hiddenCallbacks.length;
          updateQueue++
        )
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (
          updateQueue.callbacks = null, updateQueue = 0;
          updateQueue < callbacks.length;
          updateQueue++
        )
          callCallback(callbacks[updateQueue], context);
    }
    function shouldProfile(current) {
      return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if (
              (updateQueue.tag & flags) === flags &&
              ((flags & Passive) !== NoFlags
                ? null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
                  injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                    finishedWork
                  )
                : (flags & Layout) !== NoFlags &&
                  null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
                  injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                    finishedWork
                  ),
              (lastEffect = void 0),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !0),
              (lastEffect = runWithFiberInDEV(
                finishedWork,
                callCreateInDEV,
                updateQueue
              )),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !1),
              (flags & Passive) !== NoFlags
                ? null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
                  injectedProfilingHooks.markComponentPassiveEffectMountStopped()
                : (flags & Layout) !== NoFlags &&
                  null !== injectedProfilingHooks &&
                  "function" ===
                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
                  injectedProfilingHooks.markComponentLayoutEffectMountStopped(),
              void 0 !== lastEffect && "function" !== typeof lastEffect)
            ) {
              var hookName = void 0;
              hookName =
                0 !== (updateQueue.tag & Layout)
                  ? "useLayoutEffect"
                  : 0 !== (updateQueue.tag & Insertion)
                    ? "useInsertionEffect"
                    : "useEffect";
              var addendum = void 0;
              addendum =
                null === lastEffect
                  ? " You returned null. If your effect does not require clean up, return undefined (or nothing)."
                  : "function" === typeof lastEffect.then
                    ? "\n\nIt looks like you wrote " +
                      hookName +
                      "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" +
                      hookName +
                      "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
                    : " You returned: " + lastEffect;
              runWithFiberInDEV(
                finishedWork,
                function (n, a) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    n,
                    a
                  );
                },
                hookName,
                addendum
              );
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(
      flags,
      finishedWork,
      nearestMountedAncestor
    ) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              void 0 !== destroy &&
                ((inst.destroy = void 0),
                (flags & Passive) !== NoFlags
                  ? null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                      finishedWork
                    )
                  : (flags & Layout) !== NoFlags &&
                    null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                      finishedWork
                    ),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !0),
                runWithFiberInDEV(
                  finishedWork,
                  callDestroyInDEV,
                  finishedWork,
                  nearestMountedAncestor,
                  destroy
                ),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !1),
                (flags & Passive) !== NoFlags
                  ? null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
                  : (flags & Layout) !== NoFlags &&
                    null !== injectedProfilingHooks &&
                    "function" ===
                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps ||
          "ref" in finishedWork.memoizedProps ||
          didWarnAboutReassigningProps ||
          (instance.props !== finishedWork.memoizedProps &&
            console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ),
          instance.state !== finishedWork.memoizedState &&
            console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
        try {
          runWithFiberInDEV(
            finishedWork,
            commitCallbacks,
            updateQueue,
            instance
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
      var prevProps = current.memoizedProps,
        prevState = current.memoizedState;
      current = finishedWork.stateNode;
      finishedWork.type.defaultProps ||
        "ref" in finishedWork.memoizedProps ||
        didWarnAboutReassigningProps ||
        (current.props !== finishedWork.memoizedProps &&
          console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ),
        current.state !== finishedWork.memoizedState &&
          console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
      try {
        var resolvedPrevProps = resolveClassComponentProps(
          finishedWork.type,
          prevProps,
          finishedWork.elementType === finishedWork.type
        );
        var snapshot = runWithFiberInDEV(
          finishedWork,
          callGetSnapshotBeforeUpdates,
          current,
          resolvedPrevProps,
          prevState
        );
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        void 0 !== snapshot ||
          prevProps.has(finishedWork.type) ||
          (prevProps.add(finishedWork.type),
          runWithFiberInDEV(finishedWork, function () {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              getComponentNameFromFiber(finishedWork)
            );
          }));
        current.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(
      current,
      nearestMountedAncestor,
      instance
    ) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      shouldProfile(current)
        ? (startEffectTimer(),
          runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          ),
          recordEffectDuration())
        : runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          );
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (null !== ref) {
        var instance = finishedWork.stateNode;
        if ("function" === typeof ref)
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(), (finishedWork.refCleanup = ref(instance));
            } finally {
              recordEffectDuration();
            }
          else finishedWork.refCleanup = ref(instance);
        else
          "string" === typeof ref
            ? console.error("String refs are no longer supported.")
            : ref.hasOwnProperty("current") ||
              console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ),
            (ref.current = instance);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current, commitAttachRef, current);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, refCleanup);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            (current.refCleanup = null),
              (current = current.alternate),
              null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, ref, null);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, ref, null);
          } catch (error$6) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$6);
          }
        else ref.current = null;
    }
    function commitProfiler(
      finishedWork,
      current,
      commitStartTime,
      effectDuration
    ) {
      var _finishedWork$memoize = finishedWork.memoizedProps,
        id = _finishedWork$memoize.id,
        onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize &&
        _finishedWork$memoize(
          id,
          current,
          finishedWork.actualDuration,
          finishedWork.treeBaseDuration,
          finishedWork.actualStartTime,
          commitStartTime
        );
      "function" === typeof onCommit &&
        onCommit(
          finishedWork.memoizedProps.id,
          current,
          effectDuration,
          commitStartTime
        );
    }
    function commitProfilerPostCommitImpl(
      finishedWork,
      current,
      commitStartTime,
      passiveEffectDuration
    ) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize2 &&
        _finishedWork$memoize2(
          finishedWork,
          current,
          passiveEffectDuration,
          commitStartTime
        );
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        runWithFiberInDEV(
          finishedWork,
          commitMount,
          instance,
          type,
          props,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(
          finishedWork,
          commitUpdate,
          finishedWork.stateNode,
          finishedWork.type,
          oldProps,
          newProps,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return (
        5 === fiber.tag ||
        3 === fiber.tag ||
        26 === fiber.tag ||
        27 === fiber.tag ||
        4 === fiber.tag
      );
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (
          fiber = fiber.sibling;
          5 !== fiber.tag &&
          6 !== fiber.tag &&
          27 !== fiber.tag &&
          18 !== fiber.tag;

        ) {
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else (fiber.child.return = fiber), (fiber = fiber.child);
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before
            ? 8 === parent.nodeType
              ? parent.parentNode.insertBefore(node, before)
              : parent.insertBefore(node, before)
            : (8 === parent.nodeType
                ? ((before = parent.parentNode),
                  before.insertBefore(node, parent))
                : ((before = parent), before.appendChild(node)),
              (parent = parent._reactRootContainer),
              (null !== parent && void 0 !== parent) ||
                null !== before.onclick ||
                (before.onclick = noop$1));
      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
        for (
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            (node = node.sibling);
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
        for (
          insertOrAppendPlacementNode(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNode(node, before, parent),
            (node = node.sibling);
    }
    function commitPlacement(finishedWork) {
      if (27 !== finishedWork.tag) {
        a: {
          for (var parent = finishedWork.return; null !== parent; ) {
            if (isHostParent(parent)) {
              var parentFiber = parent;
              break a;
            }
            parent = parent.return;
          }
          throw Error(
            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        switch (parentFiber.tag) {
          case 27:
            parent = parentFiber.stateNode;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
            break;
          case 5:
            parent = parentFiber.stateNode;
            parentFiber.flags & 32 &&
              (resetTextContent(parent), (parentFiber.flags &= -33));
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
            break;
          case 3:
          case 4:
            parent = parentFiber.stateNode.containerInfo;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              parentFiber,
              parent
            );
            break;
          default:
            throw Error(
              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
            );
        }
      }
    }
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root)
          var JSCompiler_temp = {
            start: root.selectionStart,
            end: root.selectionEnd
          };
        else
          a: {
            JSCompiler_temp =
              ((JSCompiler_temp = root.ownerDocument) &&
                JSCompiler_temp.defaultView) ||
              window;
            var selection =
              JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset,
                focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$2) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0,
                start = -1,
                end = -1,
                indexWithinAnchor = 0,
                indexWithinFocus = 0,
                node = root,
                parentNode = null;
              b: for (;;) {
                for (var next; ; ) {
                  node !== JSCompiler_temp ||
                    (0 !== anchorOffset && 3 !== node.nodeType) ||
                    (start = length + anchorOffset);
                  node !== focusNode ||
                    (0 !== selection && 3 !== node.nodeType) ||
                    (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (;;) {
                  if (node === root) break b;
                  parentNode === JSCompiler_temp &&
                    ++indexWithinAnchor === anchorOffset &&
                    (start = length);
                  parentNode === focusNode &&
                    ++indexWithinFocus === selection &&
                    (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp =
                -1 === start || -1 === end ? null : { start: start, end: end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp
      };
      _enabled = !1;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (
          ((firstChild = nextEffect),
          (root = firstChild.child),
          0 !== (firstChild.subtreeFlags & 1028) && null !== root)
        )
          (root.return = firstChild), (nextEffect = root);
        else
          for (; null !== nextEffect; ) {
            root = firstChild = nextEffect;
            JSCompiler_temp = root.alternate;
            anchorOffset = root.flags;
            switch (root.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                0 !== (anchorOffset & 1024) &&
                  null !== JSCompiler_temp &&
                  commitClassSnapshot(root, JSCompiler_temp);
                break;
              case 3:
                if (0 !== (anchorOffset & 1024))
                  if (
                    ((root = root.stateNode.containerInfo),
                    (JSCompiler_temp = root.nodeType),
                    9 === JSCompiler_temp)
                  )
                    clearContainerSparingly(root);
                  else if (1 === JSCompiler_temp)
                    switch (root.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root);
                        break;
                      default:
                        root.textContent = "";
                    }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (anchorOffset & 1024))
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            root = firstChild.sibling;
            if (null !== root) {
              root.return = firstChild.return;
              nextEffect = root;
              break;
            }
            nextEffect = firstChild.return;
          }
      firstChild = shouldFireAfterActiveInstanceBlur;
      shouldFireAfterActiveInstanceBlur = !1;
      return firstChild;
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (((finishedRoot = finishedWork.stateNode), null === current))
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )),
                shouldProfile(finishedWork)
                  ? (startEffectTimer(),
                    runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    ),
                    recordEffectDuration())
                  : runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    );
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
              shouldProfile(finishedWork)
                ? (startEffectTimer(),
                  runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ),
                  recordEffectDuration())
                : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (
            flags & 64 &&
            ((flags = finishedWork.updateQueue), null !== flags)
          ) {
            prevProps = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = finishedWork.child.stateNode;
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                flags,
                prevProps
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current);
          break;
        case 26:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                finishedRoot.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          prevProps =
            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!prevProps) {
            current =
              (null !== current && null !== current.memoizedState) ||
              offscreenSubtreeWasHidden;
            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
              prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevProps;
            (offscreenSubtreeWasHidden = current) &&
            !prevOffscreenSubtreeWasHidden
              ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                )
              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          flags & 512 &&
            ("manual" === finishedWork.memoizedProps.mode
              ? safelyAttachRef(finishedWork, finishedWork.return)
              : safelyDetachRef(finishedWork, finishedWork.return));
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate &&
        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag &&
        ((alternate = fiber.stateNode),
        null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(
      finishedRoot,
      nearestMountedAncestor,
      parent
    ) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(
          finishedRoot,
          nearestMountedAncestor,
          parent
        ),
          (parent = parent.sibling);
    }
    function commitDeletionEffectsOnFiber(
      finishedRoot,
      nearestMountedAncestor,
      deletedFiber
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onCommitFiberUnmount
      )
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState
            ? deletedFiber.memoizedState.count--
            : deletedFiber.stateNode &&
              ((deletedFiber = deletedFiber.stateNode),
              deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber = deletedFiber.stateNode;
          for (finishedRoot = deletedFiber.attributes; finishedRoot.length; )
            deletedFiber.removeAttributeNode(finishedRoot[0]);
          detachDeletedInstance(deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChildFromContainer,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChild,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent &&
            (hostParentIsContainer
              ? ((finishedRoot = hostParent),
                (deletedFiber = deletedFiber.stateNode),
                8 === finishedRoot.nodeType
                  ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
                  : 1 === finishedRoot.nodeType &&
                    clearSuspenseBoundary(finishedRoot, deletedFiber),
                retryIfBlockedOn(finishedRoot))
              : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = !0;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden ||
            commitHookEffectListUnmount(
              Insertion,
              deletedFiber,
              nearestMountedAncestor
            );
          offscreenSubtreeWasHidden ||
            commitHookLayoutUnmountEffects(
              deletedFiber,
              nearestMountedAncestor,
              Layout
            );
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden ||
            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
            (prevHostParent = deletedFiber.stateNode),
            "function" === typeof prevHostParent.componentWillUnmount &&
              safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden =
            (prevHostParent = offscreenSubtreeWasHidden) ||
            null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState),
          null !== finishedRoot &&
            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
      )
        try {
          runWithFiberInDEV(
            finishedWork,
            commitHydratedSuspenseInstance,
            finishedRoot
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache &&
            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return (
            (finishedWork = finishedWork.stateNode),
            (retryCache = finishedWork._retryCache),
            null === retryCache &&
              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
            retryCache
          );
        default:
          throw Error(
            "Unexpected Suspense handler tag (" +
              finishedWork.tag +
              "). This is a bug in React."
          );
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (null !== inProgressLanes && null !== inProgressRoot)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          wakeable.then(retry, retry);
        }
      });
    }
    function commitMutationEffects(root, finishedWork, committedLanes) {
      inProgressLanes = committedLanes;
      inProgressRoot = root;
      commitMutationEffectsOnFiber(finishedWork, root);
      inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var root = root$jscomp$0,
            returnFiber = parentFiber,
            deletedFiber = deletions[i],
            parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = !1;
                break a;
              case 3:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = !0;
                break a;
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = !0;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = !1;
          root = deletedFiber;
          returnFiber = root.alternate;
          null !== returnFiber && (returnFiber.return = null);
          root.return = null;
        }
      if (parentFiber.subtreeFlags & 13878)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
            (parentFiber = parentFiber.sibling);
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            (commitHookEffectListUnmount(
              Insertion | HasEffect,
              finishedWork,
              finishedWork.return
            ),
            commitHookEffectListMount(Insertion | HasEffect, finishedWork),
            commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout | HasEffect
            ));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          flags & 64 &&
            offscreenSubtreeIsHidden &&
            ((finishedWork = finishedWork.updateQueue),
            null !== finishedWork &&
              ((flags = finishedWork.callbacks),
              null !== flags &&
                ((current = finishedWork.shared.hiddenCallbacks),
                (finishedWork.shared.hiddenCallbacks =
                  null === current ? flags : current.concat(flags)))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (flags & 4)
            if (
              ((root = null !== current ? current.memoizedState : null),
              (flags = finishedWork.memoizedState),
              null === current)
            )
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    root = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        hoistableRoot = root.getElementsByTagName("title")[0];
                        if (
                          !hoistableRoot ||
                          hoistableRoot[internalHoistableMarker] ||
                          hoistableRoot[internalInstanceKey] ||
                          hoistableRoot.namespaceURI === SVG_NAMESPACE ||
                          hoistableRoot.hasAttribute("itemprop")
                        )
                          (hoistableRoot = root.createElement(flags)),
                            root.head.insertBefore(
                              hoistableRoot,
                              root.querySelector("head > title")
                            );
                        setInitialProperties(hoistableRoot, flags, current);
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          root
                        ).get(flags + (current.href || ""));
                        if (maybeNodes)
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (
                              ((hoistableRoot = maybeNodes[i]),
                              hoistableRoot.getAttribute("href") ===
                                (null == current.href ? null : current.href) &&
                                hoistableRoot.getAttribute("rel") ===
                                  (null == current.rel ? null : current.rel) &&
                                hoistableRoot.getAttribute("title") ===
                                  (null == current.title
                                    ? null
                                    : current.title) &&
                                hoistableRoot.getAttribute("crossorigin") ===
                                  (null == current.crossOrigin
                                    ? null
                                    : current.crossOrigin))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        hoistableRoot = root.createElement(flags);
                        setInitialProperties(hoistableRoot, flags, current);
                        root.head.appendChild(hoistableRoot);
                        break;
                      case "meta":
                        if (
                          (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            root
                          ).get(flags + (current.content || "")))
                        )
                          for (i = 0; i < maybeNodes.length; i++)
                            if (
                              ((hoistableRoot = maybeNodes[i]),
                              checkAttributeStringCoercion(
                                current.content,
                                "content"
                              ),
                              hoistableRoot.getAttribute("content") ===
                                (null == current.content
                                  ? null
                                  : "" + current.content) &&
                                hoistableRoot.getAttribute("name") ===
                                  (null == current.name
                                    ? null
                                    : current.name) &&
                                hoistableRoot.getAttribute("property") ===
                                  (null == current.property
                                    ? null
                                    : current.property) &&
                                hoistableRoot.getAttribute("http-equiv") ===
                                  (null == current.httpEquiv
                                    ? null
                                    : current.httpEquiv) &&
                                hoistableRoot.getAttribute("charset") ===
                                  (null == current.charSet
                                    ? null
                                    : current.charSet))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        hoistableRoot = root.createElement(flags);
                        setInitialProperties(hoistableRoot, flags, current);
                        root.head.appendChild(hoistableRoot);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' +
                            flags +
                            '". This is a bug in React.'
                        );
                    }
                    hoistableRoot[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(hoistableRoot);
                    flags = hoistableRoot;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              root !== flags
                ? (null === root
                    ? null !== current.stateNode &&
                      ((current = current.stateNode),
                      current.parentNode.removeChild(current))
                    : root.count--,
                  null === flags
                    ? mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      )
                    : acquireResource(
                        hoistableRoot,
                        flags,
                        finishedWork.memoizedProps
                      ))
                : null === flags &&
                  null !== finishedWork.stateNode &&
                  commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current.memoizedProps
                  );
          break;
        case 27:
          if (flags & 4 && null === finishedWork.alternate) {
            hoistableRoot = finishedWork.stateNode;
            maybeNodes = finishedWork.memoizedProps;
            try {
              for (i = hoistableRoot.firstChild; i; ) {
                var nextNode = i.nextSibling,
                  nodeName = i.nodeName;
                i[internalHoistableMarker] ||
                  "HEAD" === nodeName ||
                  "BODY" === nodeName ||
                  "SCRIPT" === nodeName ||
                  "STYLE" === nodeName ||
                  ("LINK" === nodeName &&
                    "stylesheet" === i.rel.toLowerCase()) ||
                  hoistableRoot.removeChild(i);
                i = nextNode;
              }
              runWithFiberInDEV(
                finishedWork,
                acquireSingletonInstance,
                finishedWork.type,
                maybeNodes,
                hoistableRoot,
                finishedWork
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, root);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 &&
            null != finishedWork.stateNode &&
            ((root = finishedWork.memoizedProps),
            commitHostUpdate(
              finishedWork,
              root,
              null !== current ? current.memoizedProps : root
            ));
          flags & 1024 &&
            ((needsFormReset = !0),
            "form" !== finishedWork.type &&
              console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            flags = finishedWork.memoizedProps;
            current = null !== current ? current.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitTextUpdate,
                root,
                current,
                flags
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          tagCaches = null;
          maybeNodes = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = maybeNodes;
          commitReconciliationEffects(finishedWork);
          if (
            flags & 4 &&
            null !== current &&
            current.memoizedState.isDehydrated
          )
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedContainer,
                root.containerInfo
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset &&
            ((needsFormReset = !1), recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration +=
            bubbleNestedEffectDurations(flags);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 &&
            (null !== finishedWork.memoizedState) !==
              (null !== current && null !== current.memoizedState) &&
            (globalMostRecentFallbackTime = now$1());
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          i = null !== finishedWork.memoizedState;
          nextNode = null !== current && null !== current.memoizedState;
          nodeName = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = nodeName || i;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = nodeName;
          commitReconciliationEffects(finishedWork);
          root = finishedWork.stateNode;
          root._current = finishedWork;
          root._visibility &= ~OffscreenDetached;
          root._visibility |= root._pendingVisibility & OffscreenDetached;
          if (
            flags & 8192 &&
            ((root._visibility = i
              ? root._visibility & ~OffscreenVisible
              : root._visibility | OffscreenVisible),
            i &&
              ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
              null === current ||
                nextNode ||
                root ||
                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
            null === finishedWork.memoizedProps ||
              "manual" !== finishedWork.memoizedProps.mode)
          )
            a: for (current = null, root = finishedWork; ; ) {
              if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
                if (null === current) {
                  nextNode = current = root;
                  try {
                    (hoistableRoot = nextNode.stateNode),
                      i
                        ? runWithFiberInDEV(
                            nextNode,
                            hideInstance,
                            hoistableRoot
                          )
                        : runWithFiberInDEV(
                            nextNode,
                            unhideInstance,
                            nextNode.stateNode,
                            nextNode.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(nextNode, nextNode.return, error);
                  }
                }
              } else if (6 === root.tag) {
                if (null === current) {
                  nextNode = root;
                  try {
                    (maybeNodes = nextNode.stateNode),
                      i
                        ? runWithFiberInDEV(
                            nextNode,
                            hideTextInstance,
                            maybeNodes
                          )
                        : runWithFiberInDEV(
                            nextNode,
                            unhideTextInstance,
                            maybeNodes,
                            nextNode.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(nextNode, nextNode.return, error);
                  }
                }
              } else if (
                ((22 !== root.tag && 23 !== root.tag) ||
                  null === root.memoizedState ||
                  root === finishedWork) &&
                null !== root.child
              ) {
                root.child.return = root;
                root = root.child;
                continue;
              }
              if (root === finishedWork) break a;
              for (; null === root.sibling; ) {
                if (null === root.return || root.return === finishedWork)
                  break a;
                current === root && (current = null);
                root = root.return;
              }
              current === root && (current = null);
              root.sibling.return = root.return;
              root = root.sibling;
            }
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((current = flags.retryQueue),
              null !== current &&
                ((flags.retryQueue = null),
                attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork),
            commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function commitLayoutEffects(finishedWork, root, committedLanes) {
      inProgressLanes = committedLanes;
      inProgressRoot = root;
      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
      inProgressRoot = inProgressLanes = null;
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function disappearLayoutEffects(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(
            finishedWork,
            finishedWork.return,
            Layout
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount &&
            safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 26:
        case 27:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          safelyDetachRef(finishedWork, finishedWork.return);
          null === finishedWork.memoizedState &&
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disappearLayoutEffects(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function reappearLayoutEffects(
      finishedRoot,
      current,
      finishedWork,
      includeWorkInProgressEffects
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork.stateNode;
          "function" === typeof current.componentDidMount &&
            runWithFiberInDEV(
              finishedWork,
              callComponentDidMountInDEV,
              finishedWork,
              current
            );
          current = finishedWork.updateQueue;
          if (null !== current) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHiddenCallbacks,
                current,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects &&
            flags & 64 &&
            commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 26:
        case 27:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            null === current &&
            flags & 4 &&
            commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration +=
              bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                includeWorkInProgressEffects.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState &&
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
    }
    function recursivelyTraverseReappearLayoutEffects(
      finishedRoot,
      parentFiber,
      includeWorkInProgressEffects
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        reappearLayoutEffects(
          finishedRoot,
          parentFiber.alternate,
          parentFiber,
          includeWorkInProgressEffects
        ),
          (parentFiber = parentFiber.sibling);
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current &&
        null !== current.memoizedState &&
        null !== current.memoizedState.cachePool &&
        (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState &&
        null !== finishedWork.memoizedState.cachePool &&
        (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache &&
        (null != current && retainCache(current),
        null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate &&
        (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current &&
        (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(
      root,
      parentFiber,
      committedLanes,
      committedTransitions
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root,
            parentFiber,
            committedLanes,
            committedTransitions
          ),
            (parentFiber = parentFiber.sibling);
    }
    function commitPassiveMountOnFiber(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            ((committedLanes = null),
            null !== finishedWork.alternate &&
              (committedLanes = finishedWork.alternate.memoizedState.cache),
            (finishedWork = finishedWork.memoizedState.cache),
            finishedWork !== committedLanes &&
              (retainCache(finishedWork),
              null != committedLanes && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration +=
            popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            prevEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration +=
              bubbleNestedEffectDurations(prevEffectDuration);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfilerPostCommitImpl,
                finishedWork,
                finishedWork.alternate,
                commitStartTime,
                finishedRoot.passiveEffectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 23:
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState
            ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                )
            : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                )
              : ((prevEffectDuration._visibility |=
                  OffscreenPassiveEffectsConnected),
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  0 !== (finishedWork.subtreeFlags & 10256)
                ));
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(
      finishedRoot,
      parentFiber,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects &&
        0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        reconnectPassiveEffects(
          finishedRoot,
          parentFiber,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        ),
          (parentFiber = parentFiber.sibling);
    }
    function reconnectPassiveEffects(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects
    ) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState
            ? _instance2._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                )
            : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber
    ) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0,
            finishedWork = parentFiber,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
              flags & 2048 &&
                commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
              flags & 2048 &&
                commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork
                );
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              );
          }
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag &&
            null !== fiber.memoizedState &&
            suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            fiber.stateNode.containerInfo
          );
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState &&
            ((previousHoistableRoot = fiber.alternate),
            null !== previousHoistableRoot &&
            null !== previousHoistableRoot.memoizedState
              ? ((previousHoistableRoot = suspenseyCommitFlag),
                (suspenseyCommitFlag = 16777216),
                recursivelyAccumulateSuspenseyCommit(fiber),
                (suspenseyCommitFlag = previousHoistableRoot))
              : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (
        null !== previousFiber &&
        ((parentFiber = previousFiber.child), null !== parentFiber)
      ) {
        previousFiber.child = null;
        do
          (previousFiber = parentFiber.sibling),
            (parentFiber.sibling = null),
            (parentFiber = previousFiber);
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 &&
            commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive | HasEffect
            );
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            bubbleNestedEffectDurations(prevEffectDuration);
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState &&
          prevEffectDuration._visibility & OffscreenPassiveEffectsConnected &&
          (null === finishedWork.return || 13 !== finishedWork.return.tag)
            ? ((prevEffectDuration._visibility &=
                ~OffscreenPassiveEffectsConnected),
              recursivelyTraverseDisconnectPassiveEffects(finishedWork))
            : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disconnectPassiveEffect(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function disconnectPassiveEffect(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(
            finishedWork,
            finishedWork.return,
            Passive
          );
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected &&
            ((instance._visibility &= ~OffscreenPassiveEffectsConnected),
            recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
      deletedSubtreeRoot,
      nearestMountedAncestor
    ) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect,
          current = fiber;
        switch (current.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(
              current,
              nearestMountedAncestor,
              Passive
            );
            break;
          case 23:
          case 22:
            null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              ((current = current.memoizedState.cachePool.pool),
              null != current && retainCache(current));
            break;
          case 24:
            releaseCache(current.memoizedState.cache);
        }
        current = fiber.child;
        if (null !== current) (current.return = fiber), (nextEffect = current);
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            current = nextEffect;
            var sibling = current.sibling,
              returnFiber = current.return;
            detachFiberAfterEffects(current);
            if (current === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = !1;
      this._debugHookTypes = null;
      hasBadMapPolyfill ||
        "function" !== typeof Object.preventExtensions ||
        Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress
        ? ((workInProgress = createFiber(
            current.tag,
            pendingProps,
            current.key,
            current.mode
          )),
          (workInProgress.elementType = current.elementType),
          (workInProgress.type = current.type),
          (workInProgress.stateNode = current.stateNode),
          (workInProgress._debugOwner = current._debugOwner),
          (workInProgress._debugHookTypes = current._debugHookTypes),
          (workInProgress.alternate = current),
          (current.alternate = workInProgress))
        : ((workInProgress.pendingProps = pendingProps),
          (workInProgress.type = current.type),
          (workInProgress.flags = 0),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.actualDuration = -0),
          (workInProgress.actualStartTime = -1.1));
      workInProgress.flags = current.flags & 31457280;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies =
        null === pendingProps
          ? null
          : {
              lanes: pendingProps.lanes,
              firstContext: pendingProps.firstContext,
              _debugThenableState: pendingProps._debugThenableState
            };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
      workInProgress._debugInfo = current._debugInfo;
      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
      switch (workInProgress.tag) {
        case 0:
        case 15:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 1:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 11:
          workInProgress.type = resolveForwardRefForHotReloading(current.type);
      }
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 31457282;
      var current = workInProgress.alternate;
      null === current
        ? ((workInProgress.childLanes = 0),
          (workInProgress.lanes = renderLanes),
          (workInProgress.child = null),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.memoizedProps = null),
          (workInProgress.memoizedState = null),
          (workInProgress.updateQueue = null),
          (workInProgress.dependencies = null),
          (workInProgress.stateNode = null),
          (workInProgress.selfBaseDuration = 0),
          (workInProgress.treeBaseDuration = 0))
        : ((workInProgress.childLanes = current.childLanes),
          (workInProgress.lanes = current.lanes),
          (workInProgress.child = current.child),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.memoizedProps = current.memoizedProps),
          (workInProgress.memoizedState = current.memoizedState),
          (workInProgress.updateQueue = current.updateQueue),
          (workInProgress.type = current.type),
          (renderLanes = current.dependencies),
          (workInProgress.dependencies =
            null === renderLanes
              ? null
              : {
                  lanes: renderLanes.lanes,
                  firstContext: renderLanes.firstContext,
                  _debugThenableState: renderLanes._debugThenableState
                }),
          (workInProgress.selfBaseDuration = current.selfBaseDuration),
          (workInProgress.treeBaseDuration = current.treeBaseDuration));
      return workInProgress;
    }
    function createFiberFromTypeAndProps(
      type,
      key,
      pendingProps,
      owner,
      mode,
      lanes
    ) {
      var fiberTag = 0,
        resolvedType = type;
      if ("function" === typeof type)
        shouldConstruct(type) && (fiberTag = 1),
          (resolvedType = resolveFunctionForHotReloading(resolvedType));
      else if ("string" === typeof type)
        (fiberTag = getHostContext()),
          (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
            ? 26
            : "html" === type || "head" === type || "body" === type
              ? 27
              : 5);
      else
        a: switch (type) {
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(
              pendingProps.children,
              mode,
              lanes,
              key
            );
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= StrictLegacyMode;
            mode |= StrictEffectsMode;
            break;
          case REACT_PROFILER_TYPE:
            return (
              (type = pendingProps),
              (owner = mode),
              "string" !== typeof type.id &&
                console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ),
              (key = createFiber(12, type, key, owner | ProfileMode)),
              (key.elementType = REACT_PROFILER_TYPE),
              (key.lanes = lanes),
              (key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
              key
            );
          case REACT_SUSPENSE_TYPE:
            return (
              (key = createFiber(13, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_SUSPENSE_LIST_TYPE:
            return (
              (key = createFiber(19, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_LIST_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_OFFSCREEN_TYPE:
            return createFiberFromOffscreen(pendingProps, mode, lanes, key);
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  resolvedType = null;
                  break a;
              }
            resolvedType = "";
            if (
              void 0 === type ||
              ("object" === typeof type &&
                null !== type &&
                0 === Object.keys(type).length)
            )
              resolvedType +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type
              ? (pendingProps = "null")
              : isArrayImpl(type)
                ? (pendingProps = "array")
                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
                  ? ((pendingProps =
                      "<" +
                      (getComponentNameFromType(type.type) || "Unknown") +
                      " />"),
                    (resolvedType =
                      " Did you accidentally export a JSX literal instead of a component?"))
                  : (pendingProps = typeof type);
            (fiberTag = owner ? getComponentNameFromOwner(owner) : null) &&
              (resolvedType +=
                "\n\nCheck the render method of `" + fiberTag + "`.");
            fiberTag = 29;
            pendingProps = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " +
                (pendingProps + "." + resolvedType)
            );
            resolvedType = null;
        }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        element._owner,
        mode,
        lanes
      );
      mode._debugOwner = element._owner;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
      pendingProps = createFiber(22, pendingProps, key, mode);
      pendingProps.elementType = REACT_OFFSCREEN_TYPE;
      pendingProps.lanes = lanes;
      var primaryChildInstance = {
        _visibility: OffscreenVisible,
        _pendingVisibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
        _current: null,
        detach: function () {
          var instance = primaryChildInstance,
            fiber = instance._current;
          if (null === fiber)
            throw Error(
              "Calling Offscreen.detach before instance handle has been set."
            );
          if (0 === (instance._pendingVisibility & OffscreenDetached)) {
            var root = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root &&
              ((instance._pendingVisibility |= OffscreenDetached),
              scheduleUpdateOnFiber(root, fiber, 2));
          }
        },
        attach: function () {
          var instance = primaryChildInstance,
            fiber = instance._current;
          if (null === fiber)
            throw Error(
              "Calling Offscreen.detach before instance handle has been set."
            );
          if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
            var root = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root &&
              ((instance._pendingVisibility &= ~OffscreenDetached),
              scheduleUpdateOnFiber(root, fiber, 2));
          }
        }
      };
      pendingProps.stateNode = primaryChildInstance;
      return pendingProps;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if (
        "stylesheet" !== resource.type ||
        (resource.state.loading & Inserted) !== NotLoaded
      )
        workInProgress.flags &= -16777217;
      else if (
        ((workInProgress.flags |= 16777216), !preloadResource(resource))
      ) {
        resource = suspenseHandlerStackCursor.current;
        if (
          null !== resource &&
          ((workInProgressRootRenderLanes & 4194176) ===
          workInProgressRootRenderLanes
            ? null !== shellBoundary
            : ((workInProgressRootRenderLanes & 62914560) !==
                workInProgressRootRenderLanes &&
                0 === (workInProgressRootRenderLanes & 536870912)) ||
              resource !== shellBoundary)
        )
          throw (
            ((suspendedThenable = noopSuspenseyCommitThenable),
            SuspenseyCommitException)
          );
        workInProgress.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 &&
        ((retryQueue =
          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
        (workInProgress.lanes |= retryQueue),
        (workInProgressSuspendedRetryLanes |= retryQueue));
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate &&
                (lastTailNode = hasRenderedATailFallback),
                (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
            null === lastTailNode
              ? (renderState.tail = null)
              : (lastTailNode.sibling = null);
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
                (lastTailNode = lastTailNode.sibling);
            null === _lastTailNode
              ? hasRenderedATailFallback || null === renderState.tail
                ? (renderState.tail = null)
                : (renderState.tail.sibling = null)
              : (_lastTailNode.sibling = null);
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout =
          null !== completedWork.alternate &&
          completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (
            var _treeBaseDuration = completedWork.selfBaseDuration,
              _child2 = completedWork.child;
            null !== _child2;

          )
            (newChildLanes |= _child2.lanes | _child2.childLanes),
              (subtreeFlags |= _child2.subtreeFlags & 31457280),
              (subtreeFlags |= _child2.flags & 31457280),
              (_treeBaseDuration += _child2.treeBaseDuration),
              (_child2 = _child2.sibling);
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (
            _treeBaseDuration = completedWork.child;
            null !== _treeBaseDuration;

          )
            (newChildLanes |=
              _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
              (subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280),
              (subtreeFlags |= _treeBaseDuration.flags & 31457280),
              (_treeBaseDuration.return = completedWork),
              (_treeBaseDuration = _treeBaseDuration.sibling);
      else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child; null !== child; )
          (newChildLanes |= child.lanes | child.childLanes),
            (subtreeFlags |= child.subtreeFlags),
            (subtreeFlags |= child.flags),
            (_treeBaseDuration += child.actualDuration),
            (_child2 += child.treeBaseDuration),
            (child = child.sibling);
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (
          _treeBaseDuration = completedWork.child;
          null !== _treeBaseDuration;

        )
          (newChildLanes |=
            _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
            (subtreeFlags |= _treeBaseDuration.subtreeFlags),
            (subtreeFlags |= _treeBaseDuration.flags),
            (_treeBaseDuration.return = completedWork),
            (_treeBaseDuration = _treeBaseDuration.sibling);
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress), null;
        case 1:
          return bubbleProperties(workInProgress), null;
        case 3:
          newProps = workInProgress.stateNode;
          renderLanes = null;
          null !== current && (renderLanes = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== renderLanes &&
            (workInProgress.flags |= 2048);
          popProvider(CacheContext, workInProgress);
          popHostContainer(workInProgress);
          newProps.pendingContext &&
            ((newProps.context = newProps.pendingContext),
            (newProps.pendingContext = null));
          if (null === current || null === current.child)
            popHydrationState(workInProgress)
              ? (emitPendingHydrationWarnings(), markUpdate(workInProgress))
              : null === current ||
                (current.memoizedState.isDehydrated &&
                  0 === (workInProgress.flags & 256)) ||
                ((workInProgress.flags |= 1024),
                null !== hydrationErrors &&
                  (queueRecoverableErrors(hydrationErrors),
                  (hydrationErrors = null)));
          bubbleProperties(workInProgress);
          return null;
        case 26:
          return (
            (renderLanes = workInProgress.memoizedState),
            null === current
              ? (markUpdate(workInProgress),
                null !== renderLanes
                  ? (bubbleProperties(workInProgress),
                    preloadResourceAndSuspendIfNeeded(
                      workInProgress,
                      renderLanes
                    ))
                  : (bubbleProperties(workInProgress),
                    (workInProgress.flags &= -16777217)))
              : renderLanes
                ? renderLanes !== current.memoizedState
                  ? (markUpdate(workInProgress),
                    bubbleProperties(workInProgress),
                    preloadResourceAndSuspendIfNeeded(
                      workInProgress,
                      renderLanes
                    ))
                  : (bubbleProperties(workInProgress),
                    (workInProgress.flags &= -16777217))
                : (current.memoizedProps !== newProps &&
                    markUpdate(workInProgress),
                  bubbleProperties(workInProgress),
                  (workInProgress.flags &= -16777217)),
            null
          );
        case 27:
          popHostContext(workInProgress);
          renderLanes = requiredContext(rootInstanceStackCursor.current);
          var _type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            current = getHostContext();
            popHydrationState(workInProgress)
              ? prepareToHydrateHostInstance(workInProgress, current)
              : ((current = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes,
                  current,
                  !0
                )),
                (workInProgress.stateNode = current),
                markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          renderLanes = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            _type = getHostContext();
            if (popHydrationState(workInProgress))
              prepareToHydrateHostInstance(workInProgress, _type);
            else {
              current = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(renderLanes, _type.ancestorInfo);
              _type = _type.context;
              current = getOwnerDocumentFromRootContainer(current);
              switch (_type) {
                case HostContextNamespaceSvg:
                  current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                  break;
                case HostContextNamespaceMath:
                  current = current.createElementNS(
                    MATH_NAMESPACE,
                    renderLanes
                  );
                  break;
                default:
                  switch (renderLanes) {
                    case "svg":
                      current = current.createElementNS(
                        SVG_NAMESPACE,
                        renderLanes
                      );
                      break;
                    case "math":
                      current = current.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes
                      );
                      break;
                    case "script":
                      current = current.createElement("div");
                      current.innerHTML = "<script>\x3c/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current =
                        "string" === typeof newProps.is
                          ? current.createElement("select", { is: newProps.is })
                          : current.createElement("select");
                      newProps.multiple
                        ? (current.multiple = !0)
                        : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      (current =
                        "string" === typeof newProps.is
                          ? current.createElement(renderLanes, {
                              is: newProps.is
                            })
                          : current.createElement(renderLanes)),
                        -1 === renderLanes.indexOf("-") &&
                          (renderLanes !== renderLanes.toLowerCase() &&
                            console.error(
                              "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                              renderLanes
                            ),
                          "[object HTMLUnknownElement]" !==
                            Object.prototype.toString.call(current) ||
                            hasOwnProperty.call(
                              warnedUnknownTags,
                              renderLanes
                            ) ||
                            ((warnedUnknownTags[renderLanes] = !0),
                            console.error(
                              "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                              renderLanes
                            )));
                  }
              }
              current[internalInstanceKey] = workInProgress;
              current[internalPropsKey] = newProps;
              a: for (_type = workInProgress.child; null !== _type; ) {
                if (5 === _type.tag || 6 === _type.tag)
                  current.appendChild(_type.stateNode);
                else if (
                  4 !== _type.tag &&
                  27 !== _type.tag &&
                  null !== _type.child
                ) {
                  _type.child.return = _type;
                  _type = _type.child;
                  continue;
                }
                if (_type === workInProgress) break a;
                for (; null === _type.sibling; ) {
                  if (null === _type.return || _type.return === workInProgress)
                    break a;
                  _type = _type.return;
                }
                _type.sibling.return = _type.return;
                _type = _type.sibling;
              }
              workInProgress.stateNode = current;
              a: switch (
                (setInitialProperties(current, renderLanes, newProps),
                renderLanes)
              ) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = !0;
                  break a;
                default:
                  current = !1;
              }
              current && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          workInProgress.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (
              "string" !== typeof newProps &&
              null === workInProgress.stateNode
            )
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            current = requiredContext(rootInstanceStackCursor.current);
            renderLanes = getHostContext();
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              newProps = workInProgress.memoizedProps;
              _type = !didSuspendOrErrorDEV;
              renderLanes = null;
              var returnFiber = hydrationParentFiber;
              if (null !== returnFiber)
                switch (returnFiber.tag) {
                  case 3:
                    _type &&
                      ((_type = diffHydratedTextForDevWarnings(
                        current,
                        newProps,
                        renderLanes
                      )),
                      null !== _type &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          _type));
                    break;
                  case 27:
                  case 5:
                    (renderLanes = returnFiber.memoizedProps),
                      _type &&
                        ((_type = diffHydratedTextForDevWarnings(
                          current,
                          newProps,
                          renderLanes
                        )),
                        null !== _type &&
                          (buildHydrationDiffNode(
                            workInProgress,
                            0
                          ).serverProps = _type));
                }
              current[internalInstanceKey] = workInProgress;
              current =
                current.nodeValue === newProps ||
                (null !== renderLanes &&
                  !0 === renderLanes.suppressHydrationWarning) ||
                checkForUnmatchedText(current.nodeValue, newProps)
                  ? !0
                  : !1;
              current || throwOnHydrationMismatch(workInProgress);
            } else
              (renderLanes = renderLanes.ancestorInfo.current),
                null != renderLanes &&
                  validateTextNesting(newProps, renderLanes.tag),
                (current =
                  getOwnerDocumentFromRootContainer(current).createTextNode(
                    newProps
                  )),
                (current[internalInstanceKey] = workInProgress),
                (workInProgress.stateNode = current);
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (
            null === current ||
            (null !== current.memoizedState &&
              null !== current.memoizedState.dehydrated)
          ) {
            _type = popHydrationState(workInProgress);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!_type)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                _type = workInProgress.memoizedState;
                _type = null !== _type ? _type.dehydrated : null;
                if (!_type)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                _type[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  null !== newProps &&
                  ((_type = workInProgress.child),
                  null !== _type &&
                    (workInProgress.treeBaseDuration -=
                      _type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(),
                  resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4),
                  bubbleProperties(workInProgress),
                  (workInProgress.mode & ProfileMode) !== NoMode &&
                    null !== newProps &&
                    ((_type = workInProgress.child),
                    null !== _type &&
                      (workInProgress.treeBaseDuration -=
                        _type.treeBaseDuration));
              _type = !1;
            } else
              null !== hydrationErrors &&
                (queueRecoverableErrors(hydrationErrors),
                (hydrationErrors = null)),
                (_type = !0);
            if (!_type) {
              if (workInProgress.flags & 256)
                return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128))
            return (
              (workInProgress.lanes = renderLanes),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress
            );
          newProps = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          newProps &&
            ((renderLanes = workInProgress.child),
            (_type = null),
            null !== renderLanes.alternate &&
              null !== renderLanes.alternate.memoizedState &&
              null !== renderLanes.alternate.memoizedState.cachePool &&
              (_type = renderLanes.alternate.memoizedState.cachePool.pool),
            (returnFiber = null),
            null !== renderLanes.memoizedState &&
              null !== renderLanes.memoizedState.cachePool &&
              (returnFiber = renderLanes.memoizedState.cachePool.pool),
            returnFiber !== _type && (renderLanes.flags |= 2048));
          newProps !== current &&
            newProps &&
            (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          (workInProgress.mode & ProfileMode) !== NoMode &&
            newProps &&
            ((current = workInProgress.child),
            null !== current &&
              (workInProgress.treeBaseDuration -= current.treeBaseDuration));
          return null;
        case 4:
          return (
            popHostContainer(workInProgress),
            null === current &&
              listenToAllSupportedEvents(
                workInProgress.stateNode.containerInfo
              ),
            bubbleProperties(workInProgress),
            null
          );
        case 10:
          return (
            popProvider(workInProgress.type, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 19:
          pop(suspenseStackCursor, workInProgress);
          _type = workInProgress.memoizedState;
          if (null === _type) return bubbleProperties(workInProgress), null;
          newProps = 0 !== (workInProgress.flags & 128);
          returnFiber = _type.rendering;
          if (null === returnFiber)
            if (newProps) cutOffTailIfNeeded(_type, !1);
            else {
              if (
                workInProgressRootExitStatus !== RootInProgress ||
                (null !== current && 0 !== (current.flags & 128))
              )
                for (current = workInProgress.child; null !== current; ) {
                  returnFiber = findFirstSuspended(current);
                  if (null !== returnFiber) {
                    workInProgress.flags |= 128;
                    cutOffTailIfNeeded(_type, !1);
                    current = returnFiber.updateQueue;
                    workInProgress.updateQueue = current;
                    scheduleRetryEffect(workInProgress, current);
                    workInProgress.subtreeFlags = 0;
                    current = renderLanes;
                    for (newProps = workInProgress.child; null !== newProps; )
                      resetWorkInProgress(newProps, current),
                        (newProps = newProps.sibling);
                    push(
                      suspenseStackCursor,
                      (suspenseStackCursor.current &
                        SubtreeSuspenseContextMask) |
                        ForceSuspenseFallback,
                      workInProgress
                    );
                    return workInProgress.child;
                  }
                  current = current.sibling;
                }
              null !== _type.tail &&
                now$1() > workInProgressRootRenderTargetTime &&
                ((workInProgress.flags |= 128),
                (newProps = !0),
                cutOffTailIfNeeded(_type, !1),
                (workInProgress.lanes = 4194304));
            }
          else {
            if (!newProps)
              if (
                ((current = findFirstSuspended(returnFiber)), null !== current)
              ) {
                if (
                  ((workInProgress.flags |= 128),
                  (newProps = !0),
                  (current = current.updateQueue),
                  (workInProgress.updateQueue = current),
                  scheduleRetryEffect(workInProgress, current),
                  cutOffTailIfNeeded(_type, !0),
                  null === _type.tail &&
                    "hidden" === _type.tailMode &&
                    !returnFiber.alternate &&
                    !isHydrating)
                )
                  return bubbleProperties(workInProgress), null;
              } else
                2 * now$1() - _type.renderingStartTime >
                  workInProgressRootRenderTargetTime &&
                  536870912 !== renderLanes &&
                  ((workInProgress.flags |= 128),
                  (newProps = !0),
                  cutOffTailIfNeeded(_type, !1),
                  (workInProgress.lanes = 4194304));
            _type.isBackwards
              ? ((returnFiber.sibling = workInProgress.child),
                (workInProgress.child = returnFiber))
              : ((current = _type.last),
                null !== current
                  ? (current.sibling = returnFiber)
                  : (workInProgress.child = returnFiber),
                (_type.last = returnFiber));
          }
          if (null !== _type.tail)
            return (
              (current = _type.tail),
              (_type.rendering = current),
              (_type.tail = current.sibling),
              (_type.renderingStartTime = now$1()),
              (current.sibling = null),
              (renderLanes = suspenseStackCursor.current),
              (renderLanes = newProps
                ? (renderLanes & SubtreeSuspenseContextMask) |
                  ForceSuspenseFallback
                : renderLanes & SubtreeSuspenseContextMask),
              push(suspenseStackCursor, renderLanes, workInProgress),
              current
            );
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            (newProps = null !== workInProgress.memoizedState),
            null !== current
              ? (null !== current.memoizedState) !== newProps &&
                (workInProgress.flags |= 8192)
              : newProps && (workInProgress.flags |= 8192),
            newProps
              ? 0 !== (renderLanes & 536870912) &&
                0 === (workInProgress.flags & 128) &&
                (bubbleProperties(workInProgress),
                workInProgress.subtreeFlags & 6 &&
                  (workInProgress.flags |= 8192))
              : bubbleProperties(workInProgress),
            (newProps = workInProgress.updateQueue),
            null !== newProps &&
              scheduleRetryEffect(workInProgress, newProps.retryQueue),
            (newProps = null),
            null !== current &&
              null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              (newProps = current.memoizedState.cachePool.pool),
            (renderLanes = null),
            null !== workInProgress.memoizedState &&
              null !== workInProgress.memoizedState.cachePool &&
              (renderLanes = workInProgress.memoizedState.cachePool.pool),
            renderLanes !== newProps && (workInProgress.flags |= 2048),
            null !== current && pop(resumedCache, workInProgress),
            null
          );
        case 24:
          return (
            (newProps = null),
            null !== current && (newProps = current.memoizedState.cache),
            workInProgress.memoizedState.cache !== newProps &&
              (workInProgress.flags |= 2048),
            popProvider(CacheContext, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 25:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return (
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 3:
          return (
            popProvider(CacheContext, workInProgress),
            popHostContainer(workInProgress),
            (current = workInProgress.flags),
            0 !== (current & 65536) && 0 === (current & 128)
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress), null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress)
            : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress), null;
        case 4:
          return popHostContainer(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            null !== current && pop(resumedCache, workInProgress),
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 24:
          return popProvider(CacheContext, workInProgress), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          null !== current && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function (commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal =
        "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT
          ? IS_REACT_ACT_ENVIRONMENT
          : void 0;
      isReactActEnvironmentGlobal ||
        null === ReactSharedInternals.actQueue ||
        console.error(
          "The current testing environment is not configured to support act(...)"
        );
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if (
        (executionContext & RenderContext) !== NoContext &&
        0 !== workInProgressRootRenderLanes
      )
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return null !== transition
        ? (transition._updatedFibers || (transition._updatedFibers = new Set()),
          transition._updatedFibers.add(fiber),
          (fiber = currentEntangledLane),
          0 !== fiber ? fiber : requestTransitionLane())
        : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane &&
        (workInProgressDeferredLane =
          0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
            ? claimNextTransitionLane()
            : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect &&
        console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
      if (
        (root === workInProgressRoot &&
          workInProgressSuspendedReason === SuspendedOnData) ||
        null !== root.cancelPendingCommit
      )
        prepareFreshStack(root, 0),
          markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            !1
          );
      markRootUpdated$1(root, lane);
      if (
        0 !== (executionContext & RenderContext) &&
        root === workInProgressRoot
      ) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root =
                (workInProgress && getComponentNameFromFiber(workInProgress)) ||
                "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root) ||
                (didWarnAboutUpdateInRenderForAnotherComponent.add(root),
                (fiber = getComponentNameFromFiber(fiber) || "Unknown"),
                console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  fiber,
                  root,
                  root
                ));
              break;
            case 1:
              didWarnAboutUpdateInRender ||
                (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ),
                (didWarnAboutUpdateInRender = !0));
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
          warnIfUpdatesNotWrappedWithActDEV(fiber),
          root === workInProgressRoot &&
            ((executionContext & RenderContext) === NoContext &&
              (workInProgressRootInterleavedUpdatedLanes |= lane),
            workInProgressRootExitStatus === RootSuspendedWithDelay &&
              markRootSuspended(
                root,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                !1
              )),
          ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      var shouldTimeSlice =
          (!forceSync &&
            0 === (lanes & 60) &&
            0 === (lanes & root.expiredLanes)) ||
          checkIfRootIsPrerendering(root, lanes),
        exitStatus = shouldTimeSlice
          ? renderRootConcurrent(root, lanes)
          : renderRootSync(root, lanes, !0),
        renderWasConcurrent = shouldTimeSlice;
      do {
        if (exitStatus === RootInProgress) {
          workInProgressRootIsPrerendering &&
            !shouldTimeSlice &&
            markRootSuspended(root, lanes, 0, !1);
          break;
        } else if (exitStatus === RootDidNotComplete)
          markRootSuspended(
            root,
            lanes,
            0,
            !workInProgressRootDidSkipSuspendedSiblings
          );
        else {
          forceSync = root.current.alternate;
          if (
            renderWasConcurrent &&
            !isRenderConsistentWithExternalStores(forceSync)
          ) {
            exitStatus = renderRootSync(root, lanes, !1);
            renderWasConcurrent = !1;
            continue;
          }
          if (exitStatus === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              (errorRetryLanes = root.pendingLanes & -536870913),
                (errorRetryLanes =
                  0 !== errorRetryLanes
                    ? errorRetryLanes
                    : errorRetryLanes & 536870912
                      ? 536870912
                      : 0);
            if (0 !== errorRetryLanes) {
              lanes = errorRetryLanes;
              a: {
                exitStatus = root;
                var errorRetryLanes$jscomp$0 = errorRetryLanes;
                errorRetryLanes = workInProgressRootConcurrentErrors;
                var wasRootDehydrated =
                  exitStatus.current.memoizedState.isDehydrated;
                wasRootDehydrated &&
                  (prepareFreshStack(
                    exitStatus,
                    errorRetryLanes$jscomp$0
                  ).flags |= 256);
                errorRetryLanes$jscomp$0 = renderRootSync(
                  exitStatus,
                  errorRetryLanes$jscomp$0,
                  !1
                );
                if (errorRetryLanes$jscomp$0 !== RootErrored) {
                  if (
                    workInProgressRootDidAttachPingListener &&
                    !wasRootDehydrated
                  ) {
                    exitStatus.errorRecoveryDisabledLanes |=
                      renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |=
                      renderWasConcurrent;
                    exitStatus = RootSuspendedWithDelay;
                    break a;
                  }
                  exitStatus = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = errorRetryLanes;
                  null !== exitStatus && queueRecoverableErrors(exitStatus);
                }
                exitStatus = errorRetryLanes$jscomp$0;
              }
              renderWasConcurrent = !1;
              if (exitStatus !== RootErrored) continue;
            }
          }
          if (exitStatus === RootFatalErrored) {
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, !0);
            break;
          }
          a: {
            shouldTimeSlice = root;
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194176) === lanes) {
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                }
                break;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            shouldTimeSlice.finishedWork = forceSync;
            shouldTimeSlice.finishedLanes = lanes;
            if (null !== ReactSharedInternals.actQueue)
              commitRoot(
                shouldTimeSlice,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                IMMEDIATE_COMMIT,
                renderStartTime,
                0
              );
            else {
              if (
                (lanes & 62914560) === lanes &&
                ((exitStatus =
                  globalMostRecentFallbackTime +
                  FALLBACK_THROTTLE_MS -
                  now$1()),
                10 < exitStatus)
              ) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    THROTTLED_COMMIT,
                    renderStartTime,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                IMMEDIATE_COMMIT,
                renderStartTime,
                0
              );
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function queueRecoverableErrors(errors) {
      null === workInProgressRootRecoverableErrors
        ? (workInProgressRootRecoverableErrors = errors)
        : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            errors
          );
    }
    function commitRootWhenReady(
      root,
      finishedWork,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      lanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      didSkipSuspendedSiblings,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime
    ) {
      var subtreeFlags = finishedWork.subtreeFlags;
      if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
        if (
          ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
          accumulateSuspenseyCommitOnFiber(finishedWork),
          (finishedWork = waitForCommitToBeReady()),
          null !== finishedWork)
        ) {
          root.cancelPendingCommit = finishedWork(
            commitRoot.bind(
              null,
              root,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              SUSPENDED_COMMIT,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(
            root,
            lanes,
            spawnedLane,
            !didSkipSuspendedSiblings
          );
          return;
        }
      commitRoot(
        root,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if (
          (0 === tag || 11 === tag || 15 === tag) &&
          node.flags & 16384 &&
          ((tag = node.updateQueue),
          null !== tag && ((tag = tag.stores), null !== tag))
        )
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i],
              getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return !1;
            } catch (error) {
              return !1;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          (tag.return = node), (node = tag);
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return !0;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return !0;
    }
    function markRootSuspended(
      root,
      suspendedLanes,
      spawnedLane,
      didAttemptEntireTree
    ) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane &&
        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext
        ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
        : !0;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          (interruptedWork = workInProgress),
            resetContextDependencies(),
            resetHooksOnUnwind(interruptedWork),
            (thenableState$1 = null),
            (thenableIndexCounter$1 = 0),
            (interruptedWork = workInProgress);
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
            (interruptedWork = interruptedWork.return);
        workInProgress = null;
      }
    }
    function prepareFreshStack(root, lanes) {
      root.finishedWork = null;
      root.finishedLanes = 0;
      var timeoutHandle = root.timeoutHandle;
      timeoutHandle !== noTimeout &&
        ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
      timeoutHandle = root.cancelPendingCommit;
      null !== timeoutHandle &&
        ((root.cancelPendingCommit = null), timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = !1;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = !1;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes =
        workInProgressDeferredLane =
        workInProgressRootPingedLanes =
        workInProgressRootInterleavedUpdatedLanes =
        workInProgressRootSkippedLanes =
          0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
        null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root.entangledLanes;
      if (0 !== allEntangledLanes)
        for (
          root = root.entanglements, allEntangledLanes &= lanes;
          0 < allEntangledLanes;

        ) {
          var index = 31 - clz32(allEntangledLanes),
            lane = 1 << index;
          lanes |= root[index];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      ReactStrictModeWarnings.discardPendingWarnings();
      return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = !1;
      current = null;
      thrownValue === SuspenseException
        ? ((thrownValue = getSuspendedThenable()),
          (workInProgressSuspendedReason = SuspendedOnImmediate))
        : thrownValue === SuspenseyCommitException
          ? ((thrownValue = getSuspendedThenable()),
            (workInProgressSuspendedReason = SuspendedOnInstance))
          : (workInProgressSuspendedReason =
              thrownValue === SelectiveHydrationException
                ? SuspendedOnHydration
                : null !== thrownValue &&
                    "object" === typeof thrownValue &&
                    "function" === typeof thrownValue.then
                  ? SuspendedOnDeprecatedThrowPromise
                  : SuspendedOnError);
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      if (null === erroredWork)
        (workInProgressRootExitStatus = RootFatalErrored),
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
      else
        switch (
          (erroredWork.mode & ProfileMode &&
            stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
          markComponentRenderStopped(),
          workInProgressSuspendedReason)
        ) {
          case SuspendedOnError:
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markComponentErrored &&
              injectedProfilingHooks.markComponentErrored(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
            break;
          case SuspendedOnData:
          case SuspendedOnImmediate:
          case SuspendedOnDeprecatedThrowPromise:
          case SuspendedAndReadyToContinue:
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markComponentSuspended &&
              injectedProfilingHooks.markComponentSuspended(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
        }
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings ||
        ((workInProgressRootRenderLanes & 4194176) !==
          workInProgressRootRenderLanes &&
          null !== suspenseHandlerStackCursor.current) ||
        (workInProgressRootIsPrerendering = !0);
      (0 === (workInProgressRootSkippedLanes & 134217727) &&
        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
        null === workInProgressRoot ||
        markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        );
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      markRenderStarted(lanes);
      lanes = !1;
      memoizedUpdaters = workInProgressRootExitStatus;
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          ) {
            var unitOfWork = workInProgress,
              thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                memoizedUpdaters = RootDidNotComplete;
                break a;
              case SuspendedOnImmediate:
              case SuspendedOnData:
              case SuspendedOnDeprecatedThrowPromise:
                null === suspenseHandlerStackCursor.current && (lanes = !0);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                if (
                  shouldYieldForPrerendering &&
                  workInProgressRootIsPrerendering
                ) {
                  memoizedUpdaters = RootInProgress;
                  break a;
                }
                break;
              default:
                (reason = workInProgressSuspendedReason),
                  (workInProgressSuspendedReason = NotSuspended),
                  (workInProgressThrownValue = null),
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          memoizedUpdaters = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$8) {
          handleThrow(root, thrownValue$8);
        }
      while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      markRenderStopped();
      null === workInProgress &&
        ((workInProgressRoot = null),
        (workInProgressRootRenderLanes = 0),
        finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root,
          lanes
        );
      markRenderStarted(lanes);
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          )
            b: switch (
              ((lanes = workInProgress),
              (memoizedUpdaters = workInProgressThrownValue),
              workInProgressSuspendedReason)
            ) {
              case SuspendedOnError:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnError
                );
                break;
              case SuspendedOnData:
                if (isThenableResolved(memoizedUpdaters)) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function () {
                  workInProgressSuspendedReason === SuspendedOnData &&
                    workInProgressRoot === root &&
                    (workInProgressSuspendedReason =
                      SuspendedAndReadyToContinue);
                  ensureRootIsScheduled(root);
                };
                memoizedUpdaters.then(lanes, lanes);
                break a;
              case SuspendedOnImmediate:
                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                break a;
              case SuspendedOnInstance:
                workInProgressSuspendedReason =
                  SuspendedOnInstanceAndReadyToContinue;
                break a;
              case SuspendedAndReadyToContinue:
                isThenableResolved(memoizedUpdaters)
                  ? ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    replaySuspendedUnitOfWork(lanes))
                  : ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    throwAndUnwindWorkLoop(
                      root,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                break;
              case SuspendedOnInstanceAndReadyToContinue:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : 1) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber
                          ? ((workInProgress = returnFiber),
                            completeUnitOfWork(returnFiber))
                          : (workInProgress = null);
                      }
                      break b;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnInstanceAndReadyToContinue
                );
                break;
              case SuspendedOnDeprecatedThrowPromise:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnDeprecatedThrowPromise
                );
                break;
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = RootDidNotComplete;
                break a;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          null !== ReactSharedInternals.actQueue
            ? workLoopSync()
            : workLoopConcurrent();
          break;
        } catch (thrownValue$9) {
          handleThrow(root, thrownValue$9);
        }
      while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress)
        return (
          null !== injectedProfilingHooks &&
            "function" === typeof injectedProfilingHooks.markRenderYielded &&
            injectedProfilingHooks.markRenderYielded(),
          RootInProgress
        );
      markRenderStopped();
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrent() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode
        ? (startProfilerTimer(unitOfWork),
          (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          )),
          stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))
        : (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          ));
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === current
        ? completeUnitOfWork(unitOfWork)
        : (workInProgress = current);
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
    }
    function replayBeginWork(unitOfWork) {
      var current = unitOfWork.alternate,
        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type.render,
            unitOfWork.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current, unitOfWork),
            (unitOfWork = workInProgress =
              resetWorkInProgress(unitOfWork, entangledRenderLanes)),
            (current = beginWork(current, unitOfWork, entangledRenderLanes));
      }
      isProfilingMode &&
        stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current;
    }
    function throwAndUnwindWorkLoop(
      root,
      unitOfWork,
      thrownValue,
      suspendedReason
    ) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (
          throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )
        ) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;
        else if (
          workInProgressRootIsPrerendering ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        )
          root = !1;
        else if (
          ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
          suspendedReason === SuspendedOnData ||
            suspendedReason === SuspendedOnImmediate ||
            suspendedReason === SuspendedOnDeprecatedThrowPromise)
        )
          (suspendedReason = suspenseHandlerStackCursor.current),
            null !== suspendedReason &&
              13 === suspendedReason.tag &&
              (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        var current = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current = runWithFiberInDEV(
          completedWork,
          completeWork,
          current,
          completedWork,
          entangledRenderLanes
        );
        (completedWork.mode & ProfileMode) !== NoMode &&
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (null !== current) {
          workInProgress = current;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      workInProgressRootExitStatus === RootInProgress &&
        (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child; null !== child; )
            (next += child.actualDuration), (child = child.sibling);
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        null !== next &&
          ((next.flags |= 32768),
          (next.subtreeFlags = 0),
          (next.deletions = null));
        if (
          !skipSiblings &&
          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
        ) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = RootDidNotComplete;
      workInProgress = null;
    }
    function commitRoot(
      root,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime
    ) {
      var prevTransition = ReactSharedInternals.T,
        previousUpdateLanePriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = DiscreteEventPriority),
          (ReactSharedInternals.T = null),
          commitRootImpl(
            root,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            previousUpdateLanePriority,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
      } finally {
        (ReactSharedInternals.T = prevTransition),
          (ReactDOMSharedInternals.p = previousUpdateLanePriority);
      }
    }
    function commitRootImpl(
      root,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      renderPriorityLevel,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    ) {
      do flushPassiveEffects();
      while (null !== rootWithPendingPassiveEffects);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      var finishedWork = root.finishedWork;
      didIncludeRenderPhaseUpdate = root.finishedLanes;
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markCommitStarted &&
        injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
      if (null === finishedWork) return markCommitStopped(), null;
      0 === didIncludeRenderPhaseUpdate &&
        console.error(
          "root.finishedLanes should not be empty during a commit. This is a bug in React."
        );
      root.finishedWork = null;
      root.finishedLanes = 0;
      if (finishedWork === root.current)
        throw Error(
          "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
        );
      root.callbackNode = null;
      root.callbackPriority = 0;
      root.cancelPendingCommit = null;
      var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
      remainingLanes |= concurrentlyUpdatedLanes;
      markRootFinished(
        root,
        didIncludeRenderPhaseUpdate,
        remainingLanes,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
      root === workInProgressRoot &&
        ((workInProgress = workInProgressRoot = null),
        (workInProgressRootRenderLanes = 0));
      (0 === (finishedWork.subtreeFlags & 10256) &&
        0 === (finishedWork.flags & 10256)) ||
        rootDoesHavePassiveEffects ||
        ((rootDoesHavePassiveEffects = !0),
        (pendingPassiveEffectsRemainingLanes = remainingLanes),
        (pendingPassiveTransitions = transitions),
        scheduleCallback$1(NormalPriority$1, function () {
          flushPassiveEffects(!0);
          return null;
        }));
      commitStartTime = now();
      transitions = 0 !== (finishedWork.flags & 15990);
      0 !== (finishedWork.subtreeFlags & 15990) || transitions
        ? ((transitions = ReactSharedInternals.T),
          (ReactSharedInternals.T = null),
          (spawnedLane = ReactDOMSharedInternals.p),
          (ReactDOMSharedInternals.p = DiscreteEventPriority),
          (updatedLanes = executionContext),
          (executionContext |= CommitContext),
          commitBeforeMutationEffects(root, finishedWork),
          commitMutationEffects(
            root,
            finishedWork,
            didIncludeRenderPhaseUpdate
          ),
          restoreSelection(selectionInformation, root.containerInfo),
          (_enabled = !!eventsEnabled),
          (selectionInformation = eventsEnabled = null),
          (root.current = finishedWork),
          null !== injectedProfilingHooks &&
            "function" ===
              typeof injectedProfilingHooks.markLayoutEffectsStarted &&
            injectedProfilingHooks.markLayoutEffectsStarted(
              didIncludeRenderPhaseUpdate
            ),
          commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate),
          null !== injectedProfilingHooks &&
            "function" ===
              typeof injectedProfilingHooks.markLayoutEffectsStopped &&
            injectedProfilingHooks.markLayoutEffectsStopped(),
          requestPaint(),
          (executionContext = updatedLanes),
          (ReactDOMSharedInternals.p = spawnedLane),
          (ReactSharedInternals.T = transitions))
        : (root.current = finishedWork);
      (transitions = rootDoesHavePassiveEffects)
        ? ((rootDoesHavePassiveEffects = !1),
          (rootWithPendingPassiveEffects = root),
          (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))
        : (releaseRootPooledCache(root, remainingLanes),
          (nestedPassiveUpdateCount = 0),
          (rootWithPassiveNestedUpdates = null));
      remainingLanes = root.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      transitions || commitDoubleInvokeEffectsInDEV(root);
      onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
      isDevToolsPresent && root.memoizedUpdaters.clear();
      onCommitRoot();
      ensureRootIsScheduled(root);
      if (null !== recoverableErrors)
        for (
          renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
          finishedWork < recoverableErrors.length;
          finishedWork++
        )
          (remainingLanes = recoverableErrors[finishedWork]),
            (transitions = makeErrorInfo(remainingLanes.stack)),
            runWithFiberInDEV(
              remainingLanes.source,
              renderPriorityLevel,
              remainingLanes.value,
              transitions
            );
      0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
      remainingLanes = root.pendingLanes;
      0 !== (didIncludeRenderPhaseUpdate & 4194218) &&
      0 !== (remainingLanes & 42)
        ? ((nestedUpdateScheduled = !0),
          root === rootWithNestedUpdates
            ? nestedUpdateCount++
            : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
        : (nestedUpdateCount = 0);
      flushSyncWorkAcrossRoots_impl(0, !1);
      markCommitStopped();
      return null;
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack: componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function () {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) &&
        ((remainingLanes = root.pooledCache),
        null != remainingLanes &&
          ((root.pooledCache = null), releaseCache(remainingLanes)));
    }
    function flushPassiveEffects() {
      if (null !== rootWithPendingPassiveEffects) {
        var root = rootWithPendingPassiveEffects,
          remainingLanes = pendingPassiveEffectsRemainingLanes;
        pendingPassiveEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
          priority =
            0 === DefaultEventPriority || DefaultEventPriority > renderPriority
              ? DefaultEventPriority
              : renderPriority;
        renderPriority = ReactSharedInternals.T;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = priority;
          ReactSharedInternals.T = null;
          if (null === rootWithPendingPassiveEffects)
            var JSCompiler_inline_result = !1;
          else {
            priority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = rootWithPendingPassiveEffects,
              lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = 0;
            if (
              (executionContext & (RenderContext | CommitContext)) !==
              NoContext
            )
              throw Error(
                "Cannot flush passive effects while already rendering."
              );
            isFlushingPassiveEffects = !0;
            didScheduleUpdateDuringPassiveEffects = !1;
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markPassiveEffectsStarted &&
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(
              root$jscomp$0,
              root$jscomp$0.current,
              lanes,
              priority
            );
            null !== injectedProfilingHooks &&
              "function" ===
                typeof injectedProfilingHooks.markPassiveEffectsStopped &&
              injectedProfilingHooks.markPassiveEffectsStopped();
            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, !1);
            didScheduleUpdateDuringPassiveEffects
              ? root$jscomp$0 === rootWithPassiveNestedUpdates
                ? nestedPassiveUpdateCount++
                : ((nestedPassiveUpdateCount = 0),
                  (rootWithPassiveNestedUpdates = root$jscomp$0))
              : (nestedPassiveUpdateCount = 0);
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects =
              !1;
            if (
              injectedHook &&
              "function" === typeof injectedHook.onPostCommitFiberRoot
            )
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
              } catch (err) {
                hasLoggedError ||
                  ((hasLoggedError = !0),
                  console.error(
                    "React instrumentation encountered an error: %s",
                    err
                  ));
              }
            var stateNode = root$jscomp$0.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            JSCompiler_inline_result = !0;
          }
          return JSCompiler_inline_result;
        } finally {
          (ReactDOMSharedInternals.p = previousPriority),
            (ReactSharedInternals.T = renderPriority),
            releaseRootPooledCache(root, remainingLanes);
        }
      }
      return !1;
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber &&
        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(
      sourceFiber,
      nearestMountedAncestor,
      error
    ) {
      isRunningInsertionEffect = !1;
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            return;
          }
          if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if (
              "function" ===
                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
              ("function" === typeof instance.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
            ) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance &&
                (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ),
                markRootUpdated$1(instance, 2),
                ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(
          "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
          error
        );
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        (threadIDs = pingCache.get(wakeable)),
          void 0 === threadIDs &&
            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) ||
        ((workInProgressRootDidAttachPingListener = !0),
        threadIDs.add(lanes),
        (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
        isDevToolsPresent && restorePendingUpdaters(root, lanes),
        wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        console.error(
          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
        );
      workInProgressRoot === root &&
        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
        (workInProgressRootExitStatus === RootSuspendedWithDelay ||
        (workInProgressRootExitStatus === RootSuspended &&
          (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes &&
          now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
          ? (executionContext & RenderContext) === NoContext &&
            prepareFreshStack(root, 0)
          : (workInProgressRootPingedLanes |= pingedLanes),
        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
          (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber &&
        (markRootUpdated$1(boundaryFiber, retryLane),
        ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(
      root$jscomp$0,
      parentFiber,
      isInStrictMode
    ) {
      if (0 !== (parentFiber.subtreeFlags & 33562624))
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var root = root$jscomp$0,
            fiber = parentFiber,
            isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          22 !== fiber.tag
            ? fiber.flags & 33554432
              ? isStrictModeFiber &&
                runWithFiberInDEV(
                  fiber,
                  doubleInvokeEffectsOnFiber,
                  root,
                  fiber,
                  (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
                )
              : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                  root,
                  fiber,
                  isStrictModeFiber
                )
            : null === fiber.memoizedState &&
              (isStrictModeFiber && fiber.flags & 8192
                ? runWithFiberInDEV(
                    fiber,
                    doubleInvokeEffectsOnFiber,
                    root,
                    fiber
                  )
                : fiber.subtreeFlags & 33554432 &&
                  runWithFiberInDEV(
                    fiber,
                    recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                    root,
                    fiber,
                    isStrictModeFiber
                  ));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      var shouldDoubleInvokePassiveEffects =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
      setIsStrictModeForDevtools(!0);
      try {
        disappearLayoutEffects(fiber),
          shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber),
          reappearLayoutEffects(root, fiber.alternate, fiber, !1),
          shouldDoubleInvokePassiveEffects &&
            reconnectPassiveEffects(root, fiber, 0, null, !1);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = !0;
      root.current.mode & (StrictLegacyMode | StrictEffectsMode) ||
        (doubleInvokeEffects = !1);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(
        root,
        root.current,
        doubleInvokeEffects
      );
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (
          3 === tag ||
          1 === tag ||
          0 === tag ||
          11 === tag ||
          14 === tag ||
          15 === tag
        ) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function () {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent &&
        root.memoizedUpdaters.forEach(function (schedulingFiber) {
          addFiberToLanesMap(root, schedulingFiber, lanes);
        });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return null !== actQueue
        ? (actQueue.push(callback), fakeActCallbackNode$1)
        : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        runWithFiberInDEV(fiber, function () {
          console.error(
            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
            getComponentNameFromFiber(fiber)
          );
        });
    }
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot &&
        null === root.next &&
        (null === lastScheduledRoot
          ? (firstScheduledRoot = lastScheduledRoot = root)
          : (lastScheduledRoot = lastScheduledRoot.next = root));
      mightHavePendingSyncWork = !0;
      null !== ReactSharedInternals.actQueue
        ? didScheduleMicrotask_act ||
          ((didScheduleMicrotask_act = !0),
          scheduleImmediateTask(processRootScheduleInMicrotask))
        : didScheduleMicrotask ||
          ((didScheduleMicrotask = !0),
          scheduleImmediateTask(processRootScheduleInMicrotask));
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do {
          var didPerformSomeWork = !1;
          for (var root = firstScheduledRoot; null !== root; ) {
            if (!onlyLegacy)
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root.pendingLanes;
                if (0 === pendingLanes) var nextLanes = 0;
                else {
                  var suspendedLanes = root.suspendedLanes,
                    pingedLanes = root.pingedLanes;
                  nextLanes =
                    (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes =
                    nextLanes & 201326677
                      ? (nextLanes & 201326677) | 1
                      : nextLanes
                        ? nextLanes | 2
                        : 0;
                }
                0 !== nextLanes &&
                  ((didPerformSomeWork = !0),
                  performSyncWorkOnRoot(root, nextLanes));
              } else
                (nextLanes = workInProgressRootRenderLanes),
                  (nextLanes = getNextLanes(
                    root,
                    root === workInProgressRoot ? nextLanes : 0
                  )),
                  0 === (nextLanes & 3) ||
                    checkIfRootIsPrerendering(root, nextLanes) ||
                    ((didPerformSomeWork = !0),
                    performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = !1;
      }
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork =
        didScheduleMicrotask_act =
        didScheduleMicrotask =
          !1;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane &&
        (shouldAttemptEagerTransition() &&
          (syncTransitionLanes = currentEventTransitionLane),
        (currentEventTransitionLane = 0));
      for (
        var currentTime = now$1(), prev = null, root = firstScheduledRoot;
        null !== root;

      ) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes)
          (root.next = null),
            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
            null === next && (lastScheduledRoot = prev);
        else if (
          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        )
          mightHavePendingSyncWork = !0;
        root = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (
        var suspendedLanes = root.suspendedLanes,
          pingedLanes = root.pingedLanes,
          expirationTimes = root.expirationTimes,
          lanes = root.pendingLanes & -62914561;
        0 < lanes;

      ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index,
          expirationTime = expirationTimes[index];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root,
        root === currentTime ? suspendedLanes : 0
      );
      pingedLanes = root.callbackNode;
      if (
        0 === suspendedLanes ||
        (root === currentTime &&
          workInProgressSuspendedReason === SuspendedOnData) ||
        null !== root.cancelPendingCommit
      )
        return (
          null !== pingedLanes && cancelCallback(pingedLanes),
          (root.callbackNode = null),
          (root.callbackPriority = 0)
        );
      if (
        0 === (suspendedLanes & 3) ||
        checkIfRootIsPrerendering(root, suspendedLanes)
      ) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (
          currentTime !== root.callbackPriority ||
          (null !== ReactSharedInternals.actQueue &&
            pingedLanes !== fakeActCallbackNode)
        )
          cancelCallback(pingedLanes);
        else return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        null !== ReactSharedInternals.actQueue
          ? (ReactSharedInternals.actQueue.push(pingedLanes),
            (suspendedLanes = fakeActCallbackNode))
          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = !1;
      var originalCallbackNode = root.callbackNode;
      if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 =
        workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root,
        root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(
        root,
        workInProgressRootRenderLanes$jscomp$0,
        didTimeout
      );
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return null != root.callbackNode &&
        root.callbackNode === originalCallbackNode
        ? performWorkOnRootViaSchedulerTask.bind(null, root)
        : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPassiveEffects()) return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = !1;
      performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode &&
        null !== callbackNode &&
        cancelCallback$1(callbackNode);
    }
    function scheduleImmediateTask(cb) {
      null !== ReactSharedInternals.actQueue &&
        ReactSharedInternals.actQueue.push(function () {
          cb();
          return null;
        });
      scheduleMicrotask(function () {
        (executionContext & (RenderContext | CommitContext)) !== NoContext
          ? scheduleCallback$3(ImmediatePriority, cb)
          : cb();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane &&
        (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (
        null == actionProp ||
        "symbol" === typeof actionProp ||
        "boolean" === typeof actionProp
      )
        return null;
      if ("function" === typeof actionProp) return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(
      dispatchQueue,
      domEventName,
      maybeTargetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      if (
        "submit" === domEventName &&
        maybeTargetInst &&
        maybeTargetInst.stateNode === nativeEventTarget
      ) {
        var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ),
          submitter = nativeEvent.submitter;
        submitter &&
          ((domEventName = (domEventName = submitter[internalPropsKey] || null)
            ? coerceFormActionProp(domEventName.formAction)
            : submitter.getAttribute("formAction")),
          null !== domEventName &&
            ((action = domEventName), (submitter = null)));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event: event,
          listeners: [
            {
              instance: null,
              listener: function () {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter
                        ? createFormDataWithSubmitter(
                            nativeEventTarget,
                            submitter
                          )
                        : new FormData(nativeEventTarget),
                      pendingState = {
                        pending: !0,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action
                      };
                    Object.freeze(pendingState);
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action &&
                    (event.preventDefault(),
                    (formData = submitter
                      ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        )
                      : new FormData(nativeEventTarget)),
                    (pendingState = {
                      pending: !0,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action
                    }),
                    Object.freeze(pendingState),
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      action,
                      formData
                    ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = void 0,
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags)
            for (
              var i$jscomp$0 = _dispatchQueue$i.length - 1;
              0 <= i$jscomp$0;
              i$jscomp$0--
            ) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                instance = _dispatchListeners$i.instance,
                currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = event;
              previousInstance.currentTarget = currentTarget;
              try {
                _dispatchListeners$i(previousInstance);
              } catch (error) {
                reportGlobalError(error);
              }
              previousInstance.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (
              i$jscomp$0 = 0;
              i$jscomp$0 < _dispatchQueue$i.length;
              i$jscomp$0++
            ) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = event;
              previousInstance.currentTarget = currentTarget;
              try {
                _dispatchListeners$i(previousInstance);
              } catch (error) {
                reportGlobalError(error);
              }
              previousInstance.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) ||
        console.error(
          'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
          domEventName
        );
      var listenerSet = targetElement[internalEventHandlersKey];
      void 0 === listenerSet &&
        (listenerSet = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) ||
        (addTrappedEventListener(targetElement, domEventName, 2, !1),
        listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) &&
        !isCapturePhaseListener &&
        console.error(
          'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
          domEventName
        );
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName &&
            (nonDelegatedEvents.has(domEventName) ||
              listenToNativeEvent(domEventName, !1, rootContainerElement),
            listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument =
          9 === rootContainerElement.nodeType
            ? rootContainerElement
            : rootContainerElement.ownerDocument;
        null === ownerDocument ||
          ownerDocument[listeningMarker] ||
          ((ownerDocument[listeningMarker] = !0),
          listenToNativeEvent("selectionchange", !1, ownerDocument));
      }
    }
    function addTrappedEventListener(
      targetContainer,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    ) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported ||
        ("touchstart" !== domEventName &&
          "touchmove" !== domEventName &&
          "wheel" !== domEventName) ||
        (listenerWrapper = !0);
      isCapturePhaseListener
        ? void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: !0,
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
        : void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              !1
            );
    }
    function dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetInst$jscomp$0,
      targetContainer
    ) {
      var ancestorInst = targetInst$jscomp$0;
      if (
        0 === (eventSystemFlags & 1) &&
        0 === (eventSystemFlags & 2) &&
        null !== targetInst$jscomp$0
      )
        a: for (;;) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (
              container === targetContainer ||
              (8 === container.nodeType &&
                container.parentNode === targetContainer)
            )
              break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if (3 === grandTag || 4 === grandTag)
                  if (
                    ((grandTag = nodeTag.stateNode.containerInfo),
                    grandTag === targetContainer ||
                      (8 === grandTag.nodeType &&
                        grandTag.parentNode === targetContainer))
                  )
                    return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (
                5 === grandTag ||
                6 === grandTag ||
                26 === grandTag ||
                27 === grandTag
              ) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly =
                !inCapturePhase &&
                ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase
                ? null !== reactName
                  ? reactName + "Capture"
                  : null
                : reactName;
            inCapturePhase = [];
            for (
              var instance = targetInst, lastHostComponent;
              null !== instance;

            ) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
                null === lastHostComponent ||
                null === reactEventName ||
                ((_instance2 = getListener(instance, reactEventName)),
                null != _instance2 &&
                  inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length &&
              ((reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: reactName,
                listeners: inCapturePhase
              }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName =
              "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor =
              "mouseout" === domEventName || "pointerout" === domEventName;
            if (
              reactName &&
              nativeEvent !== currentReplayingEvent &&
              (reactEventType =
                nativeEvent.relatedTarget || nativeEvent.fromElement) &&
              (getClosestInstanceFromNode(reactEventType) ||
                reactEventType[internalContainerInstanceKey])
            )
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName =
                nativeEventTarget.window === nativeEventTarget
                  ? nativeEventTarget
                  : (reactName = nativeEventTarget.ownerDocument)
                    ? reactName.defaultView || reactName.parentWindow
                    : window;
              if (SyntheticEventCtor) {
                if (
                  ((reactEventType =
                    nativeEvent.relatedTarget || nativeEvent.toElement),
                  (SyntheticEventCtor = targetInst),
                  (reactEventType = reactEventType
                    ? getClosestInstanceFromNode(reactEventType)
                    : null),
                  null !== reactEventType &&
                    ((accumulateTargetOnly =
                      getNearestMountedFiber(reactEventType)),
                    (inCapturePhase = reactEventType.tag),
                    reactEventType !== accumulateTargetOnly ||
                      (5 !== inCapturePhase &&
                        27 !== inCapturePhase &&
                        6 !== inCapturePhase)))
                )
                  reactEventType = null;
              } else (SyntheticEventCtor = null), (reactEventType = targetInst);
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (
                  "pointerout" === domEventName ||
                  "pointerover" === domEventName
                )
                  (inCapturePhase = SyntheticPointerEvent),
                    (_instance2 = "onPointerLeave"),
                    (reactEventName = "onPointerEnter"),
                    (instance = "pointer");
                accumulateTargetOnly =
                  null == SyntheticEventCtor
                    ? reactName
                    : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent =
                  null == reactEventType
                    ? reactName
                    : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance2,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
                  ((inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  )),
                  (inCapturePhase.target = lastHostComponent),
                  (inCapturePhase.relatedTarget = accumulateTargetOnly),
                  (_instance2 = inCapturePhase));
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = SyntheticEventCtor;
                    reactEventName = reactEventType;
                    instance = 0;
                    for (
                      lastHostComponent = inCapturePhase;
                      lastHostComponent;
                      lastHostComponent = getParent(lastHostComponent)
                    )
                      instance++;
                    lastHostComponent = 0;
                    for (
                      _instance2 = reactEventName;
                      _instance2;
                      _instance2 = getParent(_instance2)
                    )
                      lastHostComponent++;
                    for (; 0 < instance - lastHostComponent; )
                      (inCapturePhase = getParent(inCapturePhase)), instance--;
                    for (; 0 < lastHostComponent - instance; )
                      (reactEventName = getParent(reactEventName)),
                        lastHostComponent--;
                    for (; instance--; ) {
                      if (
                        inCapturePhase === reactEventName ||
                        (null !== reactEventName &&
                          inCapturePhase === reactEventName.alternate)
                      )
                        break b;
                      inCapturePhase = getParent(inCapturePhase);
                      reactEventName = getParent(reactEventName);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    !1
                  );
                null !== reactEventType &&
                  null !== accumulateTargetOnly &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    !0
                  );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor =
              reactName.nodeName && reactName.nodeName.toLowerCase();
            if (
              "select" === SyntheticEventCtor ||
              ("input" === SyntheticEventCtor && "file" === reactName.type)
            )
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              (SyntheticEventCtor = reactName.nodeName),
                !SyntheticEventCtor ||
                "input" !== SyntheticEventCtor.toLowerCase() ||
                ("checkbox" !== reactName.type && "radio" !== reactName.type)
                  ? targetInst &&
                    isCustomElement(targetInst.elementType) &&
                    (getTargetInstFunc = getTargetInstForChangeEvent)
                  : (getTargetInstFunc = getTargetInstForClickEvent);
            if (
              getTargetInstFunc &&
              (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
            ) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc &&
              handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName &&
              targetInst &&
              "number" === reactName.type &&
              null != targetInst.memoizedProps.value &&
              setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst
            ? getNodeFromInstance(targetInst)
            : window;
          switch (domEventName) {
            case "focusin":
              if (
                isTextInputElement(handleEventFunc) ||
                "true" === handleEventFunc.contentEditable
              )
                (activeElement = handleEventFunc),
                  (activeElementInst = targetInst),
                  (lastSelection = null);
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing
              ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                (eventType = "onCompositionEnd")
              : "keydown" === domEventName &&
                nativeEvent.keyCode === START_KEYCODE &&
                (eventType = "onCompositionStart");
          eventType &&
            (useFallbackCompositionData &&
              "ko" !== nativeEvent.locale &&
              (isComposing || "onCompositionStart" !== eventType
                ? "onCompositionEnd" === eventType &&
                  isComposing &&
                  (fallbackData = getData())
                : ((root = nativeEventTarget),
                  (startText = "value" in root ? root.value : root.textContent),
                  (isComposing = !0))),
            (handleEventFunc = accumulateTwoPhaseListeners(
              targetInst,
              eventType
            )),
            0 < handleEventFunc.length &&
              ((eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }),
              fallbackData
                ? (eventType.data = fallbackData)
                : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                  null !== fallbackData && (eventType.data = fallbackData))));
          if (
            (fallbackData = canUseTextInputEvent
              ? getNativeBeforeInputChars(domEventName, nativeEvent)
              : getFallbackBeforeInputChars(domEventName, nativeEvent))
          )
            (eventType = accumulateTwoPhaseListeners(
              targetInst,
              "onBeforeInput"
            )),
              0 < eventType.length &&
                ((handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                )),
                dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }),
                (handleEventFunc.data = fallbackData));
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (
        var captureName = reactName + "Capture", listeners = [];
        null !== targetFiber;

      ) {
        var _instance3 = targetFiber,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
          null === stateNode ||
          ((_instance3 = getListener(targetFiber, captureName)),
          null != _instance3 &&
            listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ),
          (_instance3 = getListener(targetFiber, reactName)),
          null != _instance3 &&
            listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
        targetFiber = targetFiber.return;
      }
      return listeners;
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      event,
      target,
      common,
      inCapturePhase
    ) {
      for (
        var registrationName = event._reactName, listeners = [];
        null !== target && target !== common;

      ) {
        var _instance4 = target,
          alternate = _instance4.alternate,
          stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (null !== alternate && alternate === common) break;
        (5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4) ||
          null === stateNode ||
          ((alternate = stateNode),
          inCapturePhase
            ? ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.unshift(
                  createDispatchListener(target, stateNode, alternate)
                ))
            : inCapturePhase ||
              ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.push(
                  createDispatchListener(target, stateNode, alternate)
                )));
        target = target.return;
      }
      0 !== listeners.length &&
        dispatchQueue.push({ event: event, listeners: listeners });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      ("input" !== type && "textarea" !== type && "select" !== type) ||
        null == props ||
        null !== props.value ||
        didWarnValueNull ||
        ((didWarnValueNull = !0),
        "select" === type && props.multiple
          ? console.error(
              "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
              type
            )
          : console.error(
              "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
              type
            ));
      var eventRegistry = {
        registrationNameDependencies: registrationNameDependencies,
        possibleRegistrationNames: possibleRegistrationNames
      };
      isCustomElement(type) ||
        "string" === typeof props.is ||
        warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable &&
        !props.suppressContentEditableWarning &&
        null != props.children &&
        console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
    }
    function warnForPropDifference(
      propName,
      serverValue,
      clientValue,
      serverDifferences
    ) {
      serverValue !== clientValue &&
        ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
        normalizeMarkupForTextOrAttribute(serverValue) !== clientValue &&
          (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(
      domElement,
      attributeNames,
      serverDifferences
    ) {
      attributeNames.forEach(function (attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] =
          "style" === attributeName
            ? getStylesObjectFromElement(domElement)
            : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      !1 === listener
        ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          )
        : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
    }
    function normalizeHTML(parent, html) {
      parent =
        parent.namespaceURI === MATH_NAMESPACE ||
        parent.namespaceURI === SVG_NAMESPACE
          ? parent.ownerDocument.createElementNS(
              parent.namespaceURI,
              parent.tagName
            )
          : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) &&
        (console.error(
          "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
          typeName(markup)
        ),
        testStringCoercion(markup));
      return ("string" === typeof markup ? markup : "" + markup)
        .replace(NORMALIZE_NEWLINES_REGEX, "\n")
        .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText
        ? !0
        : !1;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if ("string" === typeof value)
            validateTextNesting(value, tag),
              "body" === tag ||
                ("textarea" === tag && "" === value) ||
                setTextContent(domElement, value);
          else if ("number" === typeof value || "bigint" === typeof value)
            validateTextNesting("" + value, tag),
              "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            "src" === key
              ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                )
              : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
            domElement.removeAttribute(key);
            break;
          }
          if (
            null == value ||
            "function" === typeof value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          null != value &&
            ("form" === tag
              ? "formAction" === key
                ? console.error(
                    "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
                  )
                : "function" === typeof value &&
                  ((null == props.encType && null == props.method) ||
                    didWarnFormActionMethod ||
                    ((didWarnFormActionMethod = !0),
                    console.error(
                      "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                    )),
                  null == props.target ||
                    didWarnFormActionTarget ||
                    ((didWarnFormActionTarget = !0),
                    console.error(
                      "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                    )))
              : "input" === tag || "button" === tag
                ? "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
                    )
                  : "input" !== tag ||
                      "submit" === props.type ||
                      "image" === props.type ||
                      didWarnFormActionType
                    ? "button" !== tag ||
                      null == props.type ||
                      "submit" === props.type ||
                      didWarnFormActionType
                      ? "function" === typeof value &&
                        (null == props.name ||
                          didWarnFormActionName ||
                          ((didWarnFormActionName = !0),
                          console.error(
                            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
                          )),
                        (null == props.formEncType &&
                          null == props.formMethod) ||
                          didWarnFormActionMethod ||
                          ((didWarnFormActionMethod = !0),
                          console.error(
                            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
                          )),
                        null == props.formTarget ||
                          didWarnFormActionTarget ||
                          ((didWarnFormActionTarget = !0),
                          console.error(
                            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
                          )))
                      : ((didWarnFormActionType = !0),
                        console.error(
                          'A button can only specify a formAction along with type="submit" or no type.'
                        ))
                    : ((didWarnFormActionType = !0),
                      console.error(
                        'An input can only specify a formAction along with type="submit" or type="image".'
                      ))
                : "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>."
                    )
                  : console.error(
                      "You can only pass the formAction prop to <input> or <button>."
                    ));
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue &&
              ("formAction" === key
                ? ("input" !== tag &&
                    setProp(domElement, tag, "name", props.name, props, null),
                  setProp(
                    domElement,
                    tag,
                    "formEncType",
                    props.formEncType,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formMethod",
                    props.formMethod,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formTarget",
                    props.formTarget,
                    props,
                    null
                  ))
                : (setProp(
                    domElement,
                    tag,
                    "encType",
                    props.encType,
                    props,
                    null
                  ),
                  setProp(domElement, tag, "method", props.method, props, null),
                  setProp(
                    domElement,
                    tag,
                    "target",
                    props.target,
                    props,
                    null
                  )));
          if (
            null == value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (
            null == value ||
            "function" === typeof value ||
            "boolean" === typeof value ||
            "symbol" === typeof value
          ) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, "" + value))
            : domElement.removeAttribute(key);
          break;
        case "inert":
          "" !== value ||
            didWarnForNewBooleanPropsWithEmptyValue[key] ||
            ((didWarnForNewBooleanPropsWithEmptyValue[key] = !0),
            console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              key
            ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value
            ? domElement.setAttribute(key, "")
            : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          !0 === value
            ? domElement.setAttribute(key, "")
            : !1 !== value &&
                null != value &&
                "function" !== typeof value &&
                "symbol" !== typeof value
              ? (checkAttributeStringCoercion(value, key),
                domElement.setAttribute(key, value))
              : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value &&
          !isNaN(value) &&
          1 <= value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value))
            : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value ||
          "function" === typeof value ||
          "symbol" === typeof value ||
          isNaN(value)
            ? domElement.removeAttribute(key)
            : (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:space",
            value
          );
          break;
        case "is":
          null != prevValue &&
            console.error(
              'Cannot update the "is" prop after it has been initialized.'
            );
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject ||
            null == value ||
            "object" !== typeof value ||
            ((didWarnPopoverTargetObject = !0),
            console.error(
              "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
              value
            ));
        default:
          !(2 < key.length) ||
          ("o" !== key[0] && "O" !== key[0]) ||
          ("n" !== key[1] && "N" !== key[1])
            ? ((key = getAttributeAlias(key)),
              setValueForAttribute(domElement, key, value))
            : registrationNameDependencies.hasOwnProperty(key) &&
              null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(
      domElement,
      tag,
      key,
      value,
      props,
      prevValue
    ) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value
            ? setTextContent(domElement, value)
            : ("number" === typeof value || "bigint" === typeof value) &&
              setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key))
            null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
          else
            a: {
              if (
                "o" === key[0] &&
                "n" === key[1] &&
                ((props = key.endsWith("Capture")),
                (tag = key.slice(2, props ? key.length - 7 : void 0)),
                (prevValue = domElement[internalPropsKey] || null),
                (prevValue = null != prevValue ? prevValue[key] : null),
                "function" === typeof prevValue &&
                  domElement.removeEventListener(tag, prevValue, props),
                "function" === typeof value)
              ) {
                "function" !== typeof prevValue &&
                  null !== prevValue &&
                  (key in domElement
                    ? (domElement[key] = null)
                    : domElement.hasAttribute(key) &&
                      domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement
                ? (domElement[key] = value)
                : !0 === value
                  ? domElement.setAttribute(key, "")
                  : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = !1,
            hasSrcSet = !1,
            propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = !0;
                    break;
                  case "srcSet":
                    hasSrcSet = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet &&
            setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = (propKey = propValue = hasSrcSet = null),
            checked = null,
            defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var _propValue = props[hasSrc];
              if (null != _propValue)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = _propValue;
                    break;
                  case "type":
                    propValue = _propValue;
                    break;
                  case "checked":
                    checked = _propValue;
                    break;
                  case "defaultChecked":
                    defaultChecked = _propValue;
                    break;
                  case "value":
                    propKey = _propValue;
                    break;
                  case "defaultValue":
                    defaultValue = _propValue;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != _propValue)
                      throw Error(
                        tag +
                          " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, _propValue, props, null);
                }
            }
          validateInputProps(domElement, props);
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            !1
          );
          track(domElement);
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (
              props.hasOwnProperty(hasSrcSet) &&
              ((defaultValue = props[hasSrcSet]), null != defaultValue)
            )
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(
                    domElement,
                    tag,
                    hasSrcSet,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag
            ? updateOptions(domElement, !!hasSrc, tag, !1)
            : null != props && updateOptions(domElement, !!hasSrc, props, !0);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (
              props.hasOwnProperty(propValue) &&
              ((defaultValue = props[propValue]), null != defaultValue)
            )
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propValue,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props)
            if (
              props.hasOwnProperty(checked) &&
              ((hasSrc = props[checked]), null != hasSrc)
            )
              switch (checked) {
                case "selected":
                  domElement.selected =
                    hasSrc &&
                    "function" !== typeof hasSrc &&
                    "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement),
            listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (
              props.hasOwnProperty(defaultChecked) &&
              ((hasSrc = props[defaultChecked]), null != hasSrc)
            )
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag +
                      " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props)
              props.hasOwnProperty(_propValue) &&
                ((hasSrc = props[_propValue]),
                void 0 !== hasSrc &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) &&
          ((hasSrc = props[defaultValue]),
          null != hasSrc &&
            setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) ||
                    setProp(
                      domElement,
                      tag,
                      propKey,
                      null,
                      nextProps,
                      lastProp
                    );
              }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (
              nextProps.hasOwnProperty(_propKey8) &&
              (null != propKey || null != lastProp)
            )
              switch (_propKey8) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  propKey !== lastProp &&
                    setProp(
                      domElement,
                      tag,
                      _propKey8,
                      propKey,
                      nextProps,
                      lastProp
                    );
              }
          }
          tag =
            "checkbox" === lastProps.type || "radio" === lastProps.type
              ? null != lastProps.checked
              : null != lastProps.value;
          nextProps =
            "checkbox" === nextProps.type || "radio" === nextProps.type
              ? null != nextProps.checked
              : null != nextProps.value;
          tag ||
            !nextProps ||
            didWarnUncontrolledToControlled ||
            (console.error(
              "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnUncontrolledToControlled = !0));
          !tag ||
            nextProps ||
            didWarnControlledToUncontrolled ||
            (console.error(
              "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnControlledToUncontrolled = !0));
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps)
            if (
              ((lastDefaultValue = lastProps[type]),
              lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            )
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) ||
                    setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
              }
          for (name in nextProps)
            if (
              ((type = nextProps[name]),
              (lastDefaultValue = lastProps[name]),
              nextProps.hasOwnProperty(name) &&
                (null != type || null != lastDefaultValue))
            )
              switch (name) {
                case "value":
                  _propKey8 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue &&
                    setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
              }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          null != _propKey8
            ? updateOptions(domElement, !!tag, _propKey8, !1)
            : !!lastProps !== !!tag &&
              (null != nextProps
                ? updateOptions(domElement, !!tag, nextProps, !0)
                : updateOptions(domElement, !!tag, tag ? [] : "", !1));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps)
            if (
              ((name = lastProps[defaultValue]),
              lastProps.hasOwnProperty(defaultValue) &&
                null != name &&
                !nextProps.hasOwnProperty(defaultValue))
            )
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (
              ((name = nextProps[value]),
              (type = lastProps[value]),
              nextProps.hasOwnProperty(value) && (null != name || null != type))
            )
              switch (value) {
                case "value":
                  _propKey8 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  name !== type &&
                    setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps)
            if (
              ((_propKey8 = lastProps[_propKey13]),
              lastProps.hasOwnProperty(_propKey13) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey13))
            )
              switch (_propKey13) {
                case "selected":
                  domElement.selected = !1;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    _propKey13,
                    null,
                    nextProps,
                    _propKey8
                  );
              }
          for (lastDefaultValue in nextProps)
            if (
              ((_propKey8 = nextProps[lastDefaultValue]),
              (propKey = lastProps[lastDefaultValue]),
              nextProps.hasOwnProperty(lastDefaultValue) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected =
                    _propKey8 &&
                    "function" !== typeof _propKey8 &&
                    "symbol" !== typeof _propKey8;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps)
            (_propKey8 = lastProps[_propKey15]),
              lastProps.hasOwnProperty(_propKey15) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey15) &&
                setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
          for (checked in nextProps)
            if (
              ((_propKey8 = nextProps[checked]),
              (propKey = lastProps[checked]),
              nextProps.hasOwnProperty(checked) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != _propKey8)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps)
              (_propKey8 = lastProps[_propKey17]),
                lastProps.hasOwnProperty(_propKey17) &&
                  void 0 !== _propKey8 &&
                  !nextProps.hasOwnProperty(_propKey17) &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
            for (defaultChecked in nextProps)
              (_propKey8 = nextProps[defaultChecked]),
                (propKey = lastProps[defaultChecked]),
                !nextProps.hasOwnProperty(defaultChecked) ||
                  _propKey8 === propKey ||
                  (void 0 === _propKey8 && void 0 === propKey) ||
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
            return;
          }
      }
      for (var _propKey19 in lastProps)
        (_propKey8 = lastProps[_propKey19]),
          lastProps.hasOwnProperty(_propKey19) &&
            null != _propKey8 &&
            !nextProps.hasOwnProperty(_propKey19) &&
            setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps)
        (_propKey8 = nextProps[lastProp]),
          (propKey = lastProps[lastProp]),
          !nextProps.hasOwnProperty(lastProp) ||
            _propKey8 === propKey ||
            (null == _propKey8 && null == propKey) ||
            setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0; i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] =
          domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else if (canDiffStyleForHydrationWarning) {
        var clientValue;
        var delimiter = (clientValue = ""),
          styleName;
        for (styleName in value$jscomp$0)
          if (value$jscomp$0.hasOwnProperty(styleName)) {
            var value = value$jscomp$0[styleName];
            null != value &&
              "boolean" !== typeof value &&
              "" !== value &&
              (0 === styleName.indexOf("--")
                ? (checkCSSPropertyStringCoercion(value, styleName),
                  (clientValue +=
                    delimiter + styleName + ":" + ("" + value).trim()))
                : "number" !== typeof value ||
                    0 === value ||
                    unitlessNumbers.has(styleName)
                  ? (checkCSSPropertyStringCoercion(value, styleName),
                    (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      ("" + value).trim()))
                  : (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      value +
                      "px"),
              (delimiter = ";"));
          }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue &&
          ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
          normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue &&
            (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value) return;
      } else
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (value) return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, attributeName),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(value)) return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              !isNaN(value) &&
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              (attributeName = sanitizeURL("" + value)),
              domElement === attributeName)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (
        var serverDifferences = {},
          extraAttributes = new Set(),
          attributes = domElement.attributes,
          i = 0;
        i < attributes.length;
        i++
      )
        switch (attributes[i].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            extraAttributes.add(attributes[i].name);
        }
      if (isCustomElement(tag))
        for (var propKey in props) {
          if (props.hasOwnProperty(propKey)) {
            var value = props[propKey];
            if (null != value)
              if (registrationNameDependencies.hasOwnProperty(propKey))
                "function" !== typeof value &&
                  warnForInvalidEventListener(propKey, value);
              else if (!0 !== props.suppressHydrationWarning)
                switch (propKey) {
                  case "children":
                    ("string" !== typeof value && "number" !== typeof value) ||
                      warnForPropDifference(
                        "children",
                        domElement.textContent,
                        value,
                        serverDifferences
                      );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    value = value ? value.__html : void 0;
                    null != value &&
                      ((value = normalizeHTML(domElement, value)),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      ));
                    continue;
                  case "style":
                    extraAttributes.delete(propKey);
                    diffHydratedStyles(domElement, value, serverDifferences);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    extraAttributes.delete(propKey.toLowerCase());
                    console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      propKey
                    );
                    continue;
                  case "className":
                    extraAttributes.delete("class");
                    attributes = getValueForAttributeOnCustomComponent(
                      domElement,
                      "class",
                      value
                    );
                    warnForPropDifference(
                      "className",
                      attributes,
                      value,
                      serverDifferences
                    );
                    continue;
                  default:
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(propKey.toLowerCase())
                      : extraAttributes.delete(propKey),
                      (attributes = getValueForAttributeOnCustomComponent(
                        domElement,
                        propKey,
                        value
                      )),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      );
                }
          }
        }
      else
        for (value in props)
          if (
            props.hasOwnProperty(value) &&
            ((propKey = props[value]), null != propKey)
          )
            if (registrationNameDependencies.hasOwnProperty(value))
              "function" !== typeof propKey &&
                warnForInvalidEventListener(value, propKey);
            else if (!0 !== props.suppressHydrationWarning)
              switch (value) {
                case "children":
                  ("string" !== typeof propKey &&
                    "number" !== typeof propKey) ||
                    warnForPropDifference(
                      "children",
                      domElement.textContent,
                      propKey,
                      serverDifferences
                    );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  attributes = domElement.innerHTML;
                  propKey = propKey ? propKey.__html : void 0;
                  null != propKey &&
                    ((propKey = normalizeHTML(domElement, propKey)),
                    attributes !== propKey &&
                      (serverDifferences[value] = { __html: attributes }));
                  continue;
                case "className":
                  hydrateAttribute(
                    domElement,
                    value,
                    "class",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "tabIndex":
                  hydrateAttribute(
                    domElement,
                    value,
                    "tabindex",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "style":
                  extraAttributes.delete(value);
                  diffHydratedStyles(domElement, propKey, serverDifferences);
                  continue;
                case "multiple":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.multiple,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "muted":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.muted,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "autoFocus":
                  extraAttributes.delete("autofocus");
                  warnForPropDifference(
                    value,
                    domElement.autofocus,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "data":
                  if ("object" !== tag) {
                    extraAttributes.delete(value);
                    attributes = domElement.getAttribute("data");
                    warnForPropDifference(
                      value,
                      attributes,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (
                    !(
                      "" !== propKey ||
                      ("a" === tag && "href" === value) ||
                      ("object" === tag && "data" === value)
                    )
                  ) {
                    "src" === value
                      ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        )
                      : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                    hydrateSanitizedAttribute(
                      domElement,
                      value,
                      value,
                      null,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "action":
                case "formAction":
                  attributes = domElement.getAttribute(value);
                  if ("function" === typeof propKey) {
                    extraAttributes.delete(value.toLowerCase());
                    "formAction" === value
                      ? (extraAttributes.delete("name"),
                        extraAttributes.delete("formenctype"),
                        extraAttributes.delete("formmethod"),
                        extraAttributes.delete("formtarget"))
                      : (extraAttributes.delete("enctype"),
                        extraAttributes.delete("method"),
                        extraAttributes.delete("target"));
                    continue;
                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                    extraAttributes.delete(value.toLowerCase());
                    warnForPropDifference(
                      value,
                      "function",
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkHref":
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    "xlink:href",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "contentEditable":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "contenteditable",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "spellCheck":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "spellcheck",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "capture":
                case "download":
                  a: {
                    i = domElement;
                    var attributeName = (attributes = value),
                      serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break a;
                        default:
                          if (!1 === propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (!0 === propKey && "" === i) break a;
                          break;
                        default:
                          if (
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  a: {
                    i = domElement;
                    attributeName = attributes = value;
                    serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break a;
                        default:
                          if (isNaN(propKey) || 1 > propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (
                            !(isNaN(propKey) || 1 > propKey) &&
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "rowSpan":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    "rowspan",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "start":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xHeight":
                  hydrateAttribute(
                    domElement,
                    value,
                    "x-height",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkActuate":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:actuate",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkArcrole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:arcrole",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkRole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:role",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkShow":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:show",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkTitle":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:title",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkType":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:type",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlBase":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:base",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlLang":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:lang",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlSpace":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:space",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "inert":
                  "" !== propKey ||
                    didWarnForNewBooleanPropsWithEmptyValue[value] ||
                    ((didWarnForNewBooleanPropsWithEmptyValue[value] = !0),
                    console.error(
                      "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                      value
                    ));
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                default:
                  if (
                    !(2 < value.length) ||
                    ("o" !== value[0] && "O" !== value[0]) ||
                    ("n" !== value[1] && "N" !== value[1])
                  ) {
                    i = getAttributeAlias(value);
                    attributes = !1;
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(i.toLowerCase())
                      : ((attributeName = value.toLowerCase()),
                        (attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        )
                          ? possibleStandardNames[attributeName] || null
                          : null),
                        null !== attributeName &&
                          attributeName !== value &&
                          ((attributes = !0),
                          extraAttributes.delete(attributeName)),
                        extraAttributes.delete(i));
                    a: if (
                      ((attributeName = domElement),
                      (serverDifferences$jscomp$0 = i),
                      (i = propKey),
                      isAttributeNameSafe(serverDifferences$jscomp$0))
                    )
                      if (
                        attributeName.hasAttribute(serverDifferences$jscomp$0)
                      )
                        (attributeName = attributeName.getAttribute(
                          serverDifferences$jscomp$0
                        )),
                          checkAttributeStringCoercion(
                            i,
                            serverDifferences$jscomp$0
                          ),
                          (i = attributeName === "" + i ? i : attributeName);
                      else {
                        switch (typeof i) {
                          case "function":
                          case "symbol":
                            break a;
                          case "boolean":
                            if (
                              ((attributeName = serverDifferences$jscomp$0
                                .toLowerCase()
                                .slice(0, 5)),
                              "data-" !== attributeName &&
                                "aria-" !== attributeName)
                            )
                              break a;
                        }
                        i = void 0 === i ? void 0 : null;
                      }
                    else i = void 0;
                    attributes ||
                      warnForPropDifference(
                        value,
                        i,
                        propKey,
                        serverDifferences
                      );
                  }
              }
      0 < extraAttributes.size &&
        !0 !== props.suppressHydrationWarning &&
        warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return 0 === Object.keys(serverDifferences).length
        ? null
        : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return (
            list.slice(0, -1).join(", ") +
            ", " +
            combinator +
            " " +
            list[list.length - 1]
          );
      }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone)
        switch (type) {
          case "svg":
            return HostContextNamespaceSvg;
          case "math":
            return HostContextNamespaceMath;
          default:
            return HostContextNamespaceNone;
        }
      return parentNamespace === HostContextNamespaceSvg &&
        "foreignObject" === type
        ? HostContextNamespaceNone
        : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return (
        "textarea" === type ||
        "noscript" === type ||
        "string" === typeof props.children ||
        "number" === typeof props.children ||
        "bigint" === typeof props.children ||
        ("object" === typeof props.dangerouslySetInnerHTML &&
          null !== props.dangerouslySetInnerHTML &&
          null != props.dangerouslySetInnerHTML.__html)
      );
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return !1;
        currentPopstateTransitionEvent = event;
        return !0;
      }
      currentPopstateTransitionEvent = null;
      return !1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src
            ? (domElement.src = newProps.src)
            : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      8 === container.nodeType
        ? container.parentNode.removeChild(child)
        : container.removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node = suspenseInstance,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (((node = nextNode.data), node === SUSPENSE_END_DATA)) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else
            (node !== SUSPENSE_START_DATA &&
              node !== SUSPENSE_PENDING_START_DATA &&
              node !== SUSPENSE_FALLBACK_START_DATA) ||
              depth++;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
      instance = instance.style;
      "function" === typeof instance.setProperty
        ? instance.setProperty("display", "none", "important")
        : (instance.display = "none");
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props =
        void 0 !== props && null !== props && props.hasOwnProperty("display")
          ? props.display
          : null;
      instance.style.display =
        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (
            !inRootOrSingleton &&
            ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
          )
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if (
              "hidden" === anyProps.type &&
              instance.getAttribute("name") === name
            )
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if (
                "stylesheet" === name &&
                instance.hasAttribute("data-precedence")
              )
                break;
              else if (
                name !== anyProps.rel ||
                instance.getAttribute("href") !==
                  (null == anyProps.href ? null : anyProps.href) ||
                instance.getAttribute("crossorigin") !==
                  (null == anyProps.crossOrigin
                    ? null
                    : anyProps.crossOrigin) ||
                instance.getAttribute("title") !==
                  (null == anyProps.title ? null : anyProps.title)
              )
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if (
                (name !== (null == anyProps.src ? null : anyProps.src) ||
                  instance.getAttribute("type") !==
                    (null == anyProps.type ? null : anyProps.type) ||
                  instance.getAttribute("crossorigin") !==
                    (null == anyProps.crossOrigin
                      ? null
                      : anyProps.crossOrigin)) &&
                name &&
                instance.hasAttribute("async") &&
                !instance.hasAttribute("itemprop")
              )
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (
            nodeType === SUSPENSE_START_DATA ||
            nodeType === SUSPENSE_FALLBACK_START_DATA ||
            nodeType === SUSPENSE_PENDING_START_DATA ||
            nodeType === FORM_STATE_IS_MATCHING ||
            nodeType === FORM_STATE_IS_NOT_MATCHING
          )
            break;
          if (nodeType === SUSPENSE_END_DATA) return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (1 === instance.nodeType) {
        for (
          var JSCompiler_temp_const = instance.nodeName.toLowerCase(),
            serverDifferences = {},
            attributes = instance.attributes,
            i = 0;
          i < attributes.length;
          i++
        ) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] =
            "style" === attr.name.toLowerCase()
              ? getStylesObjectFromElement(instance)
              : attr.value;
        }
        return { type: JSCompiler_temp_const, props: serverDifferences };
      }
      return 8 === instance.nodeType
        ? { type: "Suspense", props: {} }
        : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return null === parentProps ||
        !0 !== parentProps[SUPPRESS_HYDRATION_WARNING]
        ? (textInstance.nodeValue === text
            ? (textInstance = null)
            : ((text = normalizeMarkupForTextOrAttribute(text)),
              (textInstance =
                normalizeMarkupForTextOrAttribute(textInstance.nodeValue) ===
                text
                  ? null
                  : textInstance.nodeValue)),
          textInstance)
        : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      suspenseInstance = suspenseInstance.nextSibling;
      for (var depth = 0; suspenseInstance; ) {
        if (8 === suspenseInstance.nodeType) {
          var data = suspenseInstance.data;
          if (data === SUSPENSE_END_DATA) {
            if (0 === depth)
              return getNextHydratable(suspenseInstance.nextSibling);
            depth--;
          } else
            (data !== SUSPENSE_START_DATA &&
              data !== SUSPENSE_FALLBACK_START_DATA &&
              data !== SUSPENSE_PENDING_START_DATA) ||
              depth++;
        }
        suspenseInstance = suspenseInstance.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (
            data === SUSPENSE_START_DATA ||
            data === SUSPENSE_FALLBACK_START_DATA ||
            data === SUSPENSE_PENDING_START_DATA
          ) {
            if (0 === depth) return targetInstance;
            depth--;
          } else data === SUSPENSE_END_DATA && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(
      type,
      props,
      rootContainerInstance,
      hostContext,
      validateDOMNestingDev
    ) {
      validateDOMNestingDev &&
        validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "head":
          type = props.head;
          if (!type)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "body":
          type = props.body;
          if (!type)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function acquireSingletonInstance(
      type,
      props,
      instance,
      internalInstanceHandle
    ) {
      if (getInstanceFromNode(instance)) {
        var tagName = instance.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          tagName,
          tagName,
          tagName
        );
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (tagName = instance.attributes; tagName.length; )
        instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode
        ? container.getRootNode()
        : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref =
          escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref =
          'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin &&
          (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) ||
          (preconnectsSet.add(limitedEscapedHref),
          (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
          null === ownerDocument.querySelector(limitedEscapedHref) &&
            ((href = ownerDocument.createElement("link")),
            setInitialProperties(href, "link", rel),
            markNodeAsHoistable(href),
            ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current)
        ? getHoistableRoot(resourceRoot)
        : null;
      if (!resourceRoot)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence &&
            "string" === typeof pendingProps.href
            ? ((pendingProps = getStyleKey(pendingProps.href)),
              (currentProps =
                getResourcesFromRoot(resourceRoot).hoistableStyles),
              (currentResource = currentProps.get(pendingProps)),
              currentResource ||
                ((currentResource = {
                  type: "style",
                  instance: null,
                  count: 0,
                  state: null
                }),
                currentProps.set(pendingProps, currentResource)),
              currentResource)
            : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (
            "stylesheet" === pendingProps.rel &&
            "string" === typeof pendingProps.href &&
            "string" === typeof pendingProps.precedence
          ) {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
              _resource = _styles.get(type);
            if (
              !_resource &&
              ((resourceRoot = resourceRoot.ownerDocument || resourceRoot),
              (_resource = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: NotLoaded, preload: null }
              }),
              _styles.set(type, _resource),
              (_styles = resourceRoot.querySelector(
                getStylesheetSelectorFromKey(type)
              )) &&
                !_styles._p &&
                ((_resource.instance = _styles),
                (_resource.state.loading = Loaded | Inserted)),
              !preloadPropsMap.has(type))
            ) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles ||
                preloadStylesheet(
                  resourceRoot,
                  type,
                  preloadProps,
                  _resource.state
                );
            }
            if (currentProps && null === currentResource)
              throw (
                ((pendingProps =
                  "\n\n  - " +
                  describeLinkForResourceErrorDEV(currentProps) +
                  "\n  + " +
                  describeLinkForResourceErrorDEV(pendingProps)),
                Error(
                  "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                    pendingProps
                ))
              );
            return _resource;
          }
          if (currentProps && null !== currentResource)
            throw (
              ((pendingProps =
                "\n\n  - " +
                describeLinkForResourceErrorDEV(currentProps) +
                "\n  + " +
                describeLinkForResourceErrorDEV(pendingProps)),
              Error(
                "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                  pendingProps
              ))
            );
          return null;
        case "script":
          return (
            (currentProps = pendingProps.async),
            (pendingProps = pendingProps.src),
            "string" === typeof pendingProps &&
            currentProps &&
            "function" !== typeof currentProps &&
            "symbol" !== typeof currentProps
              ? ((pendingProps = getScriptKey(pendingProps)),
                (currentProps =
                  getResourcesFromRoot(resourceRoot).hoistableScripts),
                (currentResource = currentProps.get(pendingProps)),
                currentResource ||
                  ((currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null
                  }),
                  currentProps.set(pendingProps, currentResource)),
                currentResource)
              : { type: "void", instance: null, count: 0, state: null }
          );
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' +
              type +
              '". this is a bug in React.'
          );
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0,
        description = "<link";
      "string" === typeof props.rel
        ? (describedProps++, (description += ' rel="' + props.rel + '"'))
        : hasOwnProperty.call(props, "rel") &&
          (describedProps++,
          (description +=
            ' rel="' +
            (null === props.rel ? "null" : "invalid type " + typeof props.rel) +
            '"'));
      "string" === typeof props.href
        ? (describedProps++, (description += ' href="' + props.href + '"'))
        : hasOwnProperty.call(props, "href") &&
          (describedProps++,
          (description +=
            ' href="' +
            (null === props.href
              ? "null"
              : "invalid type " + typeof props.href) +
            '"'));
      "string" === typeof props.precedence
        ? (describedProps++,
          (description += ' precedence="' + props.precedence + '"'))
        : hasOwnProperty.call(props, "precedence") &&
          (describedProps++,
          (description +=
            " precedence={" +
            (null === props.precedence
              ? "null"
              : "invalid type " + typeof props.precedence) +
            "}"));
      Object.getOwnPropertyNames(props).length > describedProps &&
        (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return (
        'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"'
      );
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector(
        'link[rel="preload"][as="style"][' + key + "]"
      )
        ? (state.loading = Loaded)
        : ((key = ownerDocument.createElement("link")),
          (state.preload = key),
          key.addEventListener("load", function () {
            return (state.loading |= Loaded);
          }),
          key.addEventListener("error", function () {
            return (state.loading |= Errored);
          }),
          setInitialProperties(key, "link", preloadProps),
          markNodeAsHoistable(key),
          ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return (
        '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]'
      );
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                '"]'
            );
            if (instance)
              return (
                (resource.instance = instance),
                markNodeAsHoistable(instance),
                instance
              );
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return (resource.instance = instance);
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var _instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (_instance)
              return (
                (resource.state.loading |= Inserted),
                (resource.instance = _instance),
                markNodeAsHoistable(_instance),
                _instance
              );
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) &&
              adoptPreloadPropsForStylesheet(instance, styleProps);
            _instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("link");
            markNodeAsHoistable(_instance);
            var linkInstance = _instance;
            linkInstance._p = new Promise(function (resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(_instance, "link", instance);
            resource.state.loading |= Inserted;
            insertStylesheet(_instance, props.precedence, hoistableRoot);
            return (resource.instance = _instance);
          case "script":
            _instance = getScriptKey(props.src);
            if (
              (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(_instance)
              ))
            )
              return (
                (resource.instance = styleProps),
                markNodeAsHoistable(styleProps),
                styleProps
              );
            instance = props;
            if ((styleProps = preloadPropsMap.get(_instance)))
              (instance = assign({}, props)),
                adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return (resource.instance = styleProps);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' +
                resource.type +
                '". this is a bug in React.'
            );
        }
      else
        "stylesheet" === resource.type &&
          (resource.state.loading & Inserted) === NotLoaded &&
          ((instance = resource.instance),
          (resource.state.loading |= Inserted),
          insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (
        var nodes = root.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ),
          last = nodes.length ? nodes[nodes.length - 1] : null,
          prior = last,
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior
        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
        : ((precedence = 9 === root.nodeType ? root.head : root),
          precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin &&
        (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy &&
        (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title &&
        (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin &&
        (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy &&
        (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity &&
        (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = (tagCaches = new Map());
        caches.set(ownerDocument, cache);
      } else
        (caches = tagCaches),
          (cache = caches.get(ownerDocument)),
          cache || ((cache = new Map()), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (
          !(
            node[internalHoistableMarker] ||
            node[internalInstanceKey] ||
            ("link" === type && "stylesheet" === node.getAttribute("rel"))
          ) &&
          node.namespaceURI !== SVG_NAMESPACE
        ) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext =
        !hostContext.ancestorInfo.containerTagInScope;
      if (
        hostContext.context === HostContextNamespaceSvg ||
        null != props.itemProp
      )
        return (
          !outsideHostContainerContext ||
            null == props.itemProp ||
            ("meta" !== type &&
              "title" !== type &&
              "style" !== type &&
              "link" !== type &&
              "script" !== type) ||
            console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ),
          !1
        );
      switch (type) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (
            "string" !== typeof props.precedence ||
            "string" !== typeof props.href ||
            "" === props.href
          ) {
            outsideHostContainerContext &&
              console.error(
                'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.'
              );
            break;
          }
          return !0;
        case "link":
          if (
            "string" !== typeof props.rel ||
            "string" !== typeof props.href ||
            "" === props.href ||
            props.onLoad ||
            props.onError
          ) {
            if (
              "stylesheet" === props.rel &&
              "string" === typeof props.precedence
            ) {
              type = props.href;
              var onError = props.onError,
                disabled = props.disabled;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              null != disabled && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += 1 === hostContext.length ? " prop" : " props";
              disabled =
                1 === hostContext.length ? "an " + onError : "the " + onError;
              hostContext.length &&
                console.error(
                  'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                  type,
                  disabled,
                  onError
                );
            }
            outsideHostContainerContext &&
              ("string" !== typeof props.rel ||
              "string" !== typeof props.href ||
              "" === props.href
                ? console.error(
                    "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                  )
                : (props.onError || props.onLoad) &&
                  console.error(
                    "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                  ));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return (
                (type = props.precedence),
                (props = props.disabled),
                "string" !== typeof type &&
                  outsideHostContainerContext &&
                  console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ),
                "string" === typeof type && null == props
              );
            default:
              return !0;
          }
        case "script":
          type =
            props.async &&
            "function" !== typeof props.async &&
            "symbol" !== typeof props.async;
          if (
            !type ||
            props.onLoad ||
            props.onError ||
            !props.src ||
            "string" !== typeof props.src
          ) {
            outsideHostContainerContext &&
              (type
                ? props.onLoad || props.onError
                  ? console.error(
                      "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                    )
                  : console.error(
                      "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                    )
                : console.error(
                    'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                  ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          outsideHostContainerContext &&
            console.error(
              "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
              type
            );
      }
      return !1;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type &&
        (resource.state.loading & Settled) === NotLoaded
        ? !1
        : !0;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var state = suspendedState;
      if (
        "stylesheet" === resource.type &&
        ("string" !== typeof props.media ||
          !1 !== matchMedia(props.media).matches) &&
        (resource.state.loading & Inserted) === NotLoaded
      ) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot &&
              "object" === typeof hoistableRoot &&
              "function" === typeof hoistableRoot.then &&
              (state.count++,
              (state = onUnsuspend.bind(state)),
              hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) &&
            adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) &&
          (resource.state.loading & Settled) === NotLoaded &&
          (state.count++,
          (resource = onUnsuspend.bind(state)),
          hoistableRoot.addEventListener("load", resource),
          hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var state = suspendedState;
      state.stylesheets &&
        0 === state.count &&
        insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count
        ? function (commit) {
            var stylesheetTimer = setTimeout(function () {
              state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function () {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          }
        : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count)
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend &&
        (state.count++,
        (precedencesByRoot = new Map()),
        resources.forEach(insertStylesheetIntoRoot, state),
        (precedencesByRoot = null),
        onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(LAST_PRECEDENCE);
        else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (
            var nodes = root.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ),
              i = 0;
            i < nodes.length;
            i++
          ) {
            var node = nodes[i];
            if (
              "LINK" === node.nodeName ||
              "not all" !== node.getAttribute("media")
            )
              precedences.set(node.dataset.precedence, node), (last = node);
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i
          ? i.parentNode.insertBefore(nodes, i.nextSibling)
          : ((root = 9 === root.nodeType ? root.head : root),
            root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function bindToConsole(methodName, args, badgeName) {
      var offset = 0;
      switch (methodName) {
        case "dir":
        case "dirxml":
        case "groupEnd":
        case "table":
          return bind.apply(console[methodName], [console].concat(args));
        case "assert":
          offset = 1;
      }
      args = args.slice(0);
      "string" === typeof args[offset]
        ? args.splice(
            offset,
            1,
            badgeFormat + args[offset],
            badgeStyle,
            pad + badgeName + pad,
            resetStyle
          )
        : args.splice(
            offset,
            0,
            badgeFormat,
            badgeStyle,
            pad + badgeName + pad,
            resetStyle
          );
      args.unshift(console);
      return bind.apply(console[methodName], args);
    }
    function FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      formState
    ) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null;
      this.timeoutHandle = noTimeout;
      this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.finishedLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set();
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(
      containerInfo,
      tag,
      hydrate,
      initialChildren,
      hydrationCallbacks,
      isStrictMode,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      transitionCallbacks,
      formState
    ) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState
      );
      tag = ConcurrentMode;
      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
      isDevToolsPresent && (tag |= ProfileMode);
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerSync(
      element,
      container,
      parentComponent,
      callback
    ) {
      0 === container.tag && flushPassiveEffects();
      updateContainerImpl(
        container.current,
        2,
        element,
        container,
        parentComponent,
        callback
      );
      return 2;
    }
    function updateContainerImpl(
      rootFiber,
      lane,
      element,
      container,
      parentComponent,
      callback
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onScheduleFiberRoot
      )
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
        }
      null !== injectedProfilingHooks &&
        "function" === typeof injectedProfilingHooks.markRenderScheduled &&
        injectedProfilingHooks.markRenderScheduled(lane);
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context
        ? (container.context = parentComponent)
        : (container.pendingContext = parentComponent);
      isRendering &&
        null !== current &&
        !didWarnAboutNestedUpdates &&
        ((didWarnAboutNestedUpdates = !0),
        console.error(
          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
          getComponentNameFromFiber(current) || "Unknown"
        ));
      container = createUpdate(lane);
      container.payload = { element: element };
      callback = void 0 === callback ? null : callback;
      null !== callback &&
        ("function" !== typeof callback &&
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ),
        (container.callback = callback));
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element &&
        (scheduleUpdateOnFiber(element, rootFiber, lane),
        entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function getLaneLabelMap() {
      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
        var label = getLabelForLane(lane);
        map.set(lane, label);
        lane *= 2;
      }
      return map;
    }
    function dispatchDiscreteEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = DiscreteEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchContinuousEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = ContinuousEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchEvent(
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ),
            clearIfContinuousEvent(domEventName, nativeEvent);
        else if (
          queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        )
          nativeEvent.stopPropagation();
        else if (
          (clearIfContinuousEvent(domEventName, nativeEvent),
          eventSystemFlags & 4 &&
            -1 < discreteReplayableEvents.indexOf(domEventName))
        ) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root = fiber;
                      root.pendingLanes |= 2;
                      for (root.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << (31 - clz32(lanes));
                        root.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      (executionContext & (RenderContext | CommitContext)) ===
                        NoContext &&
                        ((workInProgressRootRenderTargetTime =
                          now$1() + RENDER_TIMEOUT_MS),
                        flushSyncWorkAcrossRoots_impl(0, !1));
                    }
                  }
                  break;
                case 13:
                  (root = enqueueConcurrentRenderForLane(fiber, 2)),
                    null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                    flushSyncWork$1(),
                    markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber &&
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(
      existingQueuedEvent,
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (
        null === existingQueuedEvent ||
        existingQueuedEvent.nativeEvent !== nativeEvent
      )
        return (
          (existingQueuedEvent = {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags,
            nativeEvent: nativeEvent,
            targetContainers: [targetContainer]
          }),
          null !== blockedOn &&
            ((blockedOn = getInstanceFromNode(blockedOn)),
            null !== blockedOn && attemptContinuousHydration(blockedOn)),
          existingQueuedEvent
        );
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer &&
        -1 === blockedOn.indexOf(targetContainer) &&
        blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      switch (domEventName) {
        case "focusin":
          return (
            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "dragenter":
          return (
            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "mouseover":
          return (
            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return !0;
        case "gotpointercapture":
          return (
            (pointerId = nativeEvent.pointerId),
            queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ),
            !0
          );
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted)
          if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
            if (
              ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                if (13 === nearestMounted.tag) {
                  var lane = requestUpdateLane(nearestMounted),
                    root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                  null !== root &&
                    scheduleUpdateOnFiber(root, nearestMounted, lane);
                  markRetryLaneIfNotHydrated(nearestMounted, lane);
                }
              });
              return;
            }
          } else if (
            3 === targetInst &&
            nearestMounted.stateNode.current.memoizedState.isDehydrated
          ) {
            queuedTarget.blockedOn =
              3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            return;
          }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return !1;
      for (
        var targetContainers = queuedEvent.targetContainers;
        0 < targetContainers.length;

      ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            ),
            event = nativeEventClone;
          null !== currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          null === currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = null;
        } else
          return (
            (targetContainers = getInstanceFromNode(nextBlockedOn)),
            null !== targetContainers &&
              attemptContinuousHydration(targetContainers),
            (queuedEvent.blockedOn = nextBlockedOn),
            !1
          );
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1;
      null !== queuedFocus &&
        attemptReplayContinuousQueuedEvent(queuedFocus) &&
        (queuedFocus = null);
      null !== queuedDrag &&
        attemptReplayContinuousQueuedEvent(queuedDrag) &&
        (queuedDrag = null);
      null !== queuedMouse &&
        attemptReplayContinuousQueuedEvent(queuedMouse) &&
        (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked &&
        ((queuedEvent.blockedOn = null),
        hasScheduledReplayAttempt ||
          ((hasScheduledReplayAttempt = !0),
          Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue &&
        ((lastScheduledReplayQueue = formReplayingQueue),
        Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function () {
            lastScheduledReplayQueue === formReplayingQueue &&
              (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i],
                submitterOrAction = formReplayingQueue[i + 1],
                formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (
                  null === findInstanceBlockingTarget(submitterOrAction || form)
                )
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst &&
                (formReplayingQueue.splice(i, 3),
                (i -= 3),
                (form = {
                  pending: !0,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }),
                Object.freeze(form),
                startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
            }
          }
        ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus &&
        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse &&
        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (
        ;
        0 < queuedExplicitHydrationTargets.length &&
        ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

      )
        attemptExplicitHydrationTarget(i),
          null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget],
            submitterOrAction = i[queuedTarget + 1],
            formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (
              submitterOrAction &&
              submitterOrAction.hasAttribute("formAction")
            )
              if (
                ((form = submitterOrAction),
                (formProps = submitterOrAction[internalPropsKey] || null))
              )
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action
              ? (i[queuedTarget + 1] = action)
              : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] &&
        (container._reactRootContainer
          ? console.error(
              "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
            )
          : console.error(
              "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
            ));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js"),
      React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"),
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      assign = Object.assign,
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var current = null,
      isRendering = !1,
      isArrayImpl = Array.isArray,
      ReactDOMSharedInternals =
        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
      }),
      valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1,
      contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null),
      hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now$1 = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null,
      injectedProfilingHooks = null,
      hasLoggedError = !1,
      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2,
      nextTransitionLane = 128,
      nextRetryLane = 4194304,
      DiscreteEventPriority = 2,
      ContinuousEventPriority = 8,
      DefaultEventPriority = 32,
      IdleEventPriority = 268435456,
      randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey,
      allNativeEvents = new Set(),
      registrationNameDependencies = {},
      possibleRegistrationNames = {},
      canUseDOM = !(
        "undefined" === typeof window ||
        "undefined" === typeof window.document ||
        "undefined" === typeof window.document.createElement
      ),
      hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      },
      VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {},
      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
      didWarnValueDefaultValue$1 = !1,
      didWarnCheckedDefaultChecked = !1,
      didWarnSelectedSetOnOption = !1,
      didWarnInvalidChild = !1,
      didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = ["value", "defaultValue"],
      didWarnValDefaultVal = !1,
      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
      specialTags =
        "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ),
      inScopeTags =
        "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ),
      buttonScopeTags = inScopeTags.concat(["button"]),
      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
      emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null
      },
      didWarn = {},
      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
      shorthandToLonghand = {
        animation:
          "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
        background:
          "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border:
          "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
        borderBlockEnd: [
          "borderBlockEndColor",
          "borderBlockEndStyle",
          "borderBlockEndWidth"
        ],
        borderBlockStart: [
          "borderBlockStartColor",
          "borderBlockStartStyle",
          "borderBlockStartWidth"
        ],
        borderBottom: [
          "borderBottomColor",
          "borderBottomStyle",
          "borderBottomWidth"
        ],
        borderColor: [
          "borderBottomColor",
          "borderLeftColor",
          "borderRightColor",
          "borderTopColor"
        ],
        borderImage: [
          "borderImageOutset",
          "borderImageRepeat",
          "borderImageSlice",
          "borderImageSource",
          "borderImageWidth"
        ],
        borderInlineEnd: [
          "borderInlineEndColor",
          "borderInlineEndStyle",
          "borderInlineEndWidth"
        ],
        borderInlineStart: [
          "borderInlineStartColor",
          "borderInlineStartStyle",
          "borderInlineStartWidth"
        ],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: [
          "borderBottomLeftRadius",
          "borderBottomRightRadius",
          "borderTopLeftRadius",
          "borderTopRightRadius"
        ],
        borderRight: [
          "borderRightColor",
          "borderRightStyle",
          "borderRightWidth"
        ],
        borderStyle: [
          "borderBottomStyle",
          "borderLeftStyle",
          "borderRightStyle",
          "borderTopStyle"
        ],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: [
          "borderBottomWidth",
          "borderLeftWidth",
          "borderRightWidth",
          "borderTopWidth"
        ],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
          " "
        ),
        fontVariant:
          "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
          " "
        ),
        gridArea: [
          "gridColumnEnd",
          "gridColumnStart",
          "gridRowEnd",
          "gridRowStart"
        ],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: [
          "gridTemplateAreas",
          "gridTemplateColumns",
          "gridTemplateRows"
        ],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
          " "
        ),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: [
          "textDecorationColor",
          "textDecorationLine",
          "textDecorationStyle"
        ],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: [
          "transitionDelay",
          "transitionDuration",
          "transitionProperty",
          "transitionTimingFunction"
        ],
        wordWrap: ["overflowWrap"]
      },
      uppercasePattern = /([A-Z])/g,
      msPattern$1 = /^ms-/,
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
      msPattern = /^-ms-/,
      hyphenPattern = /-(.)/g,
      badStyleValueWithSemicolonPattern = /;\s*$/,
      warnedStyleNames = {},
      warnedStyleValues = {},
      warnedForNaNValue = !1,
      warnedForInfinityValue = !1,
      unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ),
      aliases = new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]),
      possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      },
      ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      },
      warnedProperties$1 = {},
      rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      didWarnValueNull = !1,
      warnedProperties = {},
      EVENT_NAME_REGEX = /^on./,
      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
      rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
      currentReplayingEvent = null,
      restoreTarget = null,
      restoreQueue = null,
      isInsideEventHandler = !1,
      passiveBrowserEventsSupported = !1;
    if (canUseDOM)
      try {
        var options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
          get: function () {
            passiveBrowserEventsSupported = !0;
          }
        });
        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
      } catch (e) {
        passiveBrowserEventsSupported = !1;
      }
    var root = null,
      startText = null,
      fallbackText = null,
      EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget
            ? event.fromElement === event.srcElement
              ? event.toElement
              : event.fromElement
            : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent &&
            (lastMouseEvent && "mousemove" === event.type
              ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                (lastMovementY = event.screenY - lastMouseEvent.screenY))
              : (lastMovementY = lastMovementX = 0),
            (lastMouseEvent = event));
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event
            ? event.clipboardData
            : window.clipboardData;
        }
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
      SyntheticCompositionEvent = createSyntheticEvent(
        CompositionEventInterface
      ),
      SyntheticInputEvent = SyntheticCompositionEvent,
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      },
      KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type
            ? ((nativeEvent = getEventCharCode(nativeEvent)),
              13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
            : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
              ? translateToKey[nativeEvent.keyCode] || "Unidentified"
              : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type
            ? event.keyCode
            : 0;
        },
        which: function (event) {
          return "keypress" === event.type
            ? getEventCharCode(event)
            : "keydown" === event.type || "keyup" === event.type
              ? event.keyCode
              : 0;
        }
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event
            ? event.deltaX
            : "wheelDeltaX" in event
              ? -event.wheelDeltaX
              : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event
            ? event.deltaY
            : "wheelDeltaY" in event
              ? -event.wheelDeltaY
              : "wheelDelta" in event
                ? -event.wheelDelta
                : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      START_KEYCODE = 229,
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM &&
      "documentMode" in document &&
      (documentMode = document.documentMode);
    var canUseTextInputEvent =
        canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData =
        canUseDOM &&
        (!canUseCompositionEvent ||
          (documentMode && 8 < documentMode && 11 >= documentMode)),
      SPACEBAR_CODE = 32,
      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
      hasSpaceKeypress = !1,
      isComposing = !1,
      supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      },
      activeElement$1 = null,
      activeElementInst$1 = null,
      isInputEventSupported = !1;
    canUseDOM &&
      (isInputEventSupported =
        isEventSupported("input") &&
        (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is,
      skipSelectionChangeEvent =
        canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1,
      vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM &&
      ((style = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete vendorPrefixes.animationend.animation,
        delete vendorPrefixes.animationiteration.animation,
        delete vendorPrefixes.animationstart.animation),
      "TransitionEvent" in window ||
        delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents =
        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
          " "
        ),
      OffscreenVisible = 1,
      OffscreenDetached = 2,
      OffscreenPassiveEffectsConnected = 4,
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0,
      emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null,
      failedBoundaries = null,
      NoMode = 0,
      ConcurrentMode = 1,
      ProfileMode = 2,
      StrictLegacyMode = 8,
      StrictEffectsMode = 16,
      NoStrictPassiveEffectsMode = 64,
      now = Scheduler.unstable_now,
      renderStartTime = -0,
      commitStartTime = -0,
      profilerStartTime = -1.1,
      profilerEffectDuration = -0,
      currentUpdateIsNested = !1,
      nestedUpdateScheduled = !1,
      ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function () {},
        flushPendingUnsafeLifecycleWarnings: function () {},
        recordLegacyContextWarning: function () {},
        flushLegacyContextWarning: function () {},
        discardPendingWarnings: function () {}
      },
      pendingComponentWillMountWarnings = [],
      pendingUNSAFE_ComponentWillMountWarnings = [],
      pendingComponentWillReceivePropsWarnings = [],
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
      pendingComponentWillUpdateWarnings = [],
      pendingUNSAFE_ComponentWillUpdateWarnings = [],
      didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
      fiber,
      instance
    ) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) ||
        ("function" === typeof instance.componentWillMount &&
          !0 !== instance.componentWillMount.__suppressDeprecationWarning &&
          pendingComponentWillMountWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillMount &&
          pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
        "function" === typeof instance.componentWillReceiveProps &&
          !0 !==
            instance.componentWillReceiveProps.__suppressDeprecationWarning &&
          pendingComponentWillReceivePropsWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
        "function" === typeof instance.componentWillUpdate &&
          !0 !== instance.componentWillUpdate.__suppressDeprecationWarning &&
          pendingComponentWillUpdateWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillUpdate &&
          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
      var componentWillMountUniqueNames = new Set();
      0 < pendingComponentWillMountWarnings.length &&
        (pendingComponentWillMountWarnings.forEach(function (fiber) {
          componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillMountWarnings = []));
      var UNSAFE_componentWillMountUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillMountWarnings.length &&
        (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
          UNSAFE_componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillMountWarnings = []));
      var componentWillReceivePropsUniqueNames = new Set();
      0 < pendingComponentWillReceivePropsWarnings.length &&
        (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
          componentWillReceivePropsUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillReceivePropsWarnings = []));
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length &&
        (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
          function (fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }
        ),
        (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
      var componentWillUpdateUniqueNames = new Set();
      0 < pendingComponentWillUpdateWarnings.length &&
        (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
          componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillUpdateWarnings = []));
      var UNSAFE_componentWillUpdateUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length &&
        (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillUpdateWarnings = []));
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(
          UNSAFE_componentWillMountUniqueNames
        );
        console.error(
          "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
          sortedNames
        );
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillReceivePropsUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < UNSAFE_componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillUpdateUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillMountUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillMountUniqueNames)),
        console.warn(
          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          componentWillReceivePropsUniqueNames
        )),
        console.warn(
          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillUpdateUniqueNames)),
        console.warn(
          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
    };
    var pendingLegacyContextWarning = new Map(),
      didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function (
      fiber,
      instance
    ) {
      var strictRoot = null;
      for (var node = fiber; null !== node; )
        node.mode & StrictLegacyMode && (strictRoot = node),
          (node = node.return);
      null === strictRoot
        ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          )
        : !didWarnAboutLegacyContext.has(fiber.type) &&
          ((node = pendingLegacyContextWarning.get(strictRoot)),
          null != fiber.type.contextTypes ||
            null != fiber.type.childContextTypes ||
            (null !== instance &&
              "function" === typeof instance.getChildContext)) &&
          (void 0 === node &&
            ((node = []), pendingLegacyContextWarning.set(strictRoot, node)),
          node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
      pendingLegacyContextWarning.forEach(function (fiberArray) {
        if (0 !== fiberArray.length) {
          var firstFiber = fiberArray[0],
            uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function () {
            console.error(
              "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
              sortedNames
            );
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function () {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map();
    };
    var CapturedStacks = new WeakMap(),
      forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "",
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      didSuspendOrErrorDEV = !1,
      hydrationDiffRootDEV = null,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
      ),
      SuspenseyCommitException = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      noopSuspenseyCommitThenable = {
        then: function () {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      },
      suspendedThenable = null,
      needsToResetSuspendedThenableDEV = !1,
      callComponent = {
        "react-stack-bottom-frame": function (Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callComponentInDEV =
        callComponent["react-stack-bottom-frame"].bind(callComponent),
      callRender = {
        "react-stack-bottom-frame": function (instance) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
      callComponentDidMount = {
        "react-stack-bottom-frame": function (finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidMountInDEV = callComponentDidMount[
        "react-stack-bottom-frame"
      ].bind(callComponentDidMount),
      callComponentDidUpdate = {
        "react-stack-bottom-frame": function (
          finishedWork,
          instance,
          prevProps,
          prevState,
          snapshot
        ) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidUpdateInDEV = callComponentDidUpdate[
        "react-stack-bottom-frame"
      ].bind(callComponentDidUpdate),
      callComponentDidCatch = {
        "react-stack-bottom-frame": function (instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      },
      callComponentDidCatchInDEV = callComponentDidCatch[
        "react-stack-bottom-frame"
      ].bind(callComponentDidCatch),
      callComponentWillUnmount = {
        "react-stack-bottom-frame": function (
          current,
          nearestMountedAncestor,
          instance
        ) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callComponentWillUnmountInDEV = callComponentWillUnmount[
        "react-stack-bottom-frame"
      ].bind(callComponentWillUnmount),
      callCreate = {
        "react-stack-bottom-frame": function (effect) {
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return (effect.destroy = create);
        }
      },
      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
      callDestroy = {
        "react-stack-bottom-frame": function (
          current,
          nearestMountedAncestor,
          destroy
        ) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callDestroyInDEV =
        callDestroy["react-stack-bottom-frame"].bind(callDestroy),
      callLazyInit = {
        "react-stack-bottom-frame": function (lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      },
      callLazyInitInDEV =
        callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
      thenableState$1 = null,
      thenableIndexCounter$1 = 0,
      currentDebugInfo = null,
      didWarnAboutMaps;
    var didWarnAboutGenerators = (didWarnAboutMaps = !1);
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function (returnFiber, workInProgress, child) {
      if (
        null !== child &&
        "object" === typeof child &&
        child._store &&
        ((!child._store.validated && null == child.key) ||
          2 === child._store.validated)
      ) {
        if ("object" !== typeof child._store)
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        child._store.validated = 1;
        var componentName = getComponentNameFromFiber(returnFiber),
          componentKey = componentName || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = !0;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber &&
            "number" === typeof returnFiber.tag &&
            (componentKey = getComponentNameFromFiber(returnFiber)) &&
            (currentComponentErrorInfo =
              "\n\nCheck the render method of `" + componentKey + "`.");
          currentComponentErrorInfo ||
            (componentName &&
              (currentComponentErrorInfo =
                "\n\nCheck the top-level render call using <" +
                componentName +
                ">."));
          var childOwnerAppendix = "";
          null != child &&
            returnFiber !== child &&
            ((componentName = null),
            "number" === typeof child.tag
              ? (componentName = getComponentNameFromFiber(child))
              : "string" === typeof child.name && (componentName = child.name),
            componentName &&
              (childOwnerAppendix =
                " It was passed a child from " + componentName + "."));
          runWithFiberInDEV(workInProgress, function () {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              currentComponentErrorInfo,
              childOwnerAppendix
            );
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null,
      SubtreeSuspenseContextMask = 1,
      ForceSuspenseFallback = 2,
      suspenseStackCursor = createCursor(0),
      NoFlags = 0,
      HasEffect = 1,
      Insertion = 2,
      Layout = 4,
      Passive = 8,
      AbortControllerLocal =
        "undefined" !== typeof AbortController
          ? AbortController
          : function () {
              var listeners = [],
                signal = (this.signal = {
                  aborted: !1,
                  addEventListener: function (type, listener) {
                    listeners.push(listener);
                  }
                });
              this.abort = function () {
                signal.aborted = !0;
                listeners.forEach(function (listener) {
                  return listener();
                });
              };
            },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      },
      currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null,
      prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      "object" === typeof returnValue &&
        null !== returnValue &&
        "function" === typeof returnValue.then &&
        entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish &&
        prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null),
      didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0,
      currentlyRenderingFiber$1 = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter = 0,
      thenableState = null,
      globalClientIdCounter = 0,
      RE_RENDER_LIMIT = 25,
      currentHookNameInDev = null,
      hookTypesDev = null,
      hookTypesUpdateIndexDev = -1,
      ignorePreviousDependencies = !1;
    var createFunctionComponentUpdateQueue = function () {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    };
    var ContextOnlyDispatcher = {
      readContext: readContext,
      use: use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError
    };
    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
    ContextOnlyDispatcher.useFormState = throwInvalidHookError;
    ContextOnlyDispatcher.useActionState = throwInvalidHookError;
    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null,
      HooksDispatcherOnMountWithHookTypesInDEV = null,
      HooksDispatcherOnUpdateInDEV = null,
      HooksDispatcherOnRerenderInDEV = null,
      InvalidNestedHooksDispatcherOnMountInDEV = null,
      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    HooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
      currentHookNameInDev = "useFormState";
      mountHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useActionState = function (
      action,
      initialState
    ) {
      currentHookNameInDev = "useActionState";
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
      currentHookNameInDev = "useOptimistic";
      mountHookTypesDev();
      return mountOptimistic(passthrough);
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function (
      action,
      initialState
    ) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function (
      action,
      initialState
    ) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return mountActionState(action, initialState);
    };
    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function (
      passthrough
    ) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return mountOptimistic(passthrough);
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    HooksDispatcherOnUpdateInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return updateActionState(action);
    };
    HooksDispatcherOnUpdateInDEV.useOptimistic = function (
      passthrough,
      reducer
    ) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    HooksDispatcherOnRerenderInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useActionState = function (action) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    HooksDispatcherOnRerenderInDEV.useOptimistic = function (
      passthrough,
      reducer
    ) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function (
      action,
      initialState
    ) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function (
      action,
      initialState
    ) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState);
    };
    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function (
      passthrough
    ) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOptimistic(passthrough);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function (action) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function (
      action
    ) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action);
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function (
      passthrough,
      reducer
    ) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus =
      useHostTransitionStatus;
    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function (
      action
    ) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function (
      action
    ) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action);
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function (
      passthrough,
      reducer
    ) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        isMounted: function (component) {
          var owner = current;
          if (null !== owner && isRendering && 1 === owner.tag) {
            var instance = owner.stateNode;
            instance._warnedAboutRefsInRender ||
              console.error(
                "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
                getComponentNameFromFiber(owner) || "A component"
              );
            instance._warnedAboutRefsInRender = !0;
          }
          return (component = component._reactInternals)
            ? getNearestMountedFiber(component) === component
            : !1;
        },
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          callback = enqueueUpdate(inst, update, lane);
          null !== callback &&
            (scheduleUpdateOnFiber(callback, inst, lane),
            entangleTransitions(callback, inst, lane));
          null !== injectedProfilingHooks &&
            "function" ===
              typeof injectedProfilingHooks.markForceUpdateScheduled &&
            injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
      },
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      componentName = null,
      errorBoundaryName = null,
      SelectiveHydrationException = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ),
      didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      },
      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
      valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber = null,
      lastContextDependency = null,
      isDisallowedContextReadInDEV = !1,
      UpdateState = 0,
      ReplaceState = 1,
      ForceUpdate = 2,
      CaptureUpdate = 3,
      hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1,
      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null,
      inProgressLanes = null,
      inProgressRoot = null,
      shouldFireAfterActiveInstanceBlur = !1,
      hostParent = null,
      hostParentIsContainer = !1,
      currentHoistableRoot = null,
      suspenseyCommitFlag = 8192;
    var hasBadMapPolyfill = !1;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$7) {
      hasBadMapPolyfill = !0;
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function (resourceType) {
        var cache = readContext(CacheContext),
          cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType &&
          ((cacheForType = resourceType()),
          cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      getOwner: function () {
        return current;
      }
    };
    if ("function" === typeof Symbol && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [],
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      NoContext = 0,
      RenderContext = 2,
      CommitContext = 4,
      RootInProgress = 0,
      RootFatalErrored = 1,
      RootErrored = 2,
      RootSuspended = 3,
      RootSuspendedWithDelay = 4,
      RootCompleted = 5,
      RootDidNotComplete = 6,
      executionContext = NoContext,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      NotSuspended = 0,
      SuspendedOnError = 1,
      SuspendedOnData = 2,
      SuspendedOnImmediate = 3,
      SuspendedOnInstance = 4,
      SuspendedOnInstanceAndReadyToContinue = 5,
      SuspendedOnDeprecatedThrowPromise = 6,
      SuspendedAndReadyToContinue = 7,
      SuspendedOnHydration = 8,
      workInProgressSuspendedReason = NotSuspended,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = RootInProgress,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      FALLBACK_THROTTLE_MS = 300,
      workInProgressRootRenderTargetTime = Infinity,
      RENDER_TIMEOUT_MS = 500,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      rootDoesHavePassiveEffects = !1,
      rootWithPendingPassiveEffects = null,
      pendingPassiveEffectsLanes = 0,
      pendingPassiveEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      isFlushingPassiveEffects = !1,
      didScheduleUpdateDuringPassiveEffects = !1,
      NESTED_PASSIVE_UPDATE_LIMIT = 50,
      nestedPassiveUpdateCount = 0,
      rootWithPassiveNestedUpdates = null,
      isRunningInsertionEffect = !1,
      IMMEDIATE_COMMIT = 0,
      SUSPENDED_COMMIT = 1,
      THROTTLED_COMMIT = 2,
      didWarnStateUpdateForNotYetMountedComponent = null,
      didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {},
      firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      didScheduleMicrotask_act = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0,
      fakeActCallbackNode = {};
    (function () {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i],
          domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes =
        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ),
      nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle"
          .split(" ")
          .concat(mediaEventTypes)
      ),
      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
      didWarnControlledToUncontrolled = !1,
      didWarnUncontrolledToControlled = !1,
      didWarnFormActionType = !1,
      didWarnFormActionName = !1,
      didWarnFormActionTarget = !1,
      didWarnFormActionMethod = !1,
      didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var canDiffStyleForHydrationWarning = !0;
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
      xlinkNamespace = "http://www.w3.org/1999/xlink",
      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
      EXPECTED_FORM_ACTION_URL =
        "javascript:throw new Error('React form unexpectedly submitted.')",
      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
      SUSPENSE_START_DATA = "$",
      SUSPENSE_END_DATA = "/$",
      SUSPENSE_PENDING_START_DATA = "$?",
      SUSPENSE_FALLBACK_START_DATA = "$!",
      FORM_STATE_IS_MATCHING = "F!",
      FORM_STATE_IS_NOT_MATCHING = "F",
      STYLE = "style",
      HostContextNamespaceNone = 0,
      HostContextNamespaceSvg = 1,
      HostContextNamespaceMath = 2,
      eventsEnabled = null,
      selectionInformation = null,
      warnedUnknownTags = { dialog: !0, webview: !0 },
      currentPopstateTransitionEvent = null,
      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout =
        "function" === typeof clearTimeout ? clearTimeout : void 0,
      noTimeout = -1,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask =
        "function" === typeof queueMicrotask
          ? queueMicrotask
          : "undefined" !== typeof localPromise
            ? function (callback) {
                return localPromise
                  .resolve(null)
                  .then(callback)
                  .catch(handleErrorInNextTick);
              }
            : scheduleTimeout,
      NotLoaded = 0,
      Loaded = 1,
      Errored = 2,
      Settled = 3,
      Inserted = 4,
      preloadPropsMap = new Map(),
      preconnectsSet = new Set(),
      previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function () {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function (form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type
          ? requestFormReset$1(formInst)
          : previousDispatcher.r(form);
      },
      D: function (href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function (href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function (href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector =
            'link[rel="preload"][as="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(as) +
            '"]';
          "image" === as
            ? options && options.imageSrcSet
              ? ((preloadSelector +=
                  '[imagesrcset="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    options.imageSrcSet
                  ) +
                  '"]'),
                "string" === typeof options.imageSizes &&
                  (preloadSelector +=
                    '[imagesizes="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(
                      options.imageSizes
                    ) +
                    '"]'))
              : (preloadSelector +=
                  '[href="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                  '"]')
            : (preloadSelector +=
                '[href="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                '"]');
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) ||
            ((href = assign(
              {
                rel: "preload",
                href:
                  "image" === as && options && options.imageSrcSet
                    ? void 0
                    : href,
                as: as
              },
              options
            )),
            preloadPropsMap.set(key, href),
            null !== ownerDocument.querySelector(preloadSelector) ||
              ("style" === as &&
                ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                )) ||
              ("script" === as &&
                ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
              ((as = ownerDocument.createElement("link")),
              setInitialProperties(as, "link", href),
              markNodeAsHoistable(as),
              ownerDocument.head.appendChild(as)));
        }
      },
      m: function (href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as =
              options && "string" === typeof options.as ? options.as : "script",
            preloadSelector =
              'link[rel="modulepreload"][as="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
              '"][href="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
              '"]',
            key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (
            !preloadPropsMap.has(key) &&
            ((href = assign({ rel: "modulepreload", href: href }, options)),
            preloadPropsMap.set(key, href),
            null === ownerDocument.querySelector(preloadSelector))
          ) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function (src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0 }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      },
      S: function (href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: NotLoaded, preload: null };
            if (
              (resource = ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ))
            )
              state.loading = Loaded | Inserted;
            else {
              href = assign(
                {
                  rel: "stylesheet",
                  href: href,
                  "data-precedence": precedence
                },
                options
              );
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForStylesheet(href, options);
              var link = (resource = ownerDocument.createElement("link"));
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function () {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function () {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state: state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function (src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0, type: "module" }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      }
    };
    var globalDocument = "undefined" === typeof document ? null : document,
      tagCaches = null,
      suspendedState = null,
      LAST_PRECEDENCE = null,
      precedencesByRoot = null,
      NotPendingTransition = NotPending,
      HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      },
      badgeFormat = "%c%s%c ",
      badgeStyle =
        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
      resetStyle = "",
      pad = " ",
      bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null,
      overrideHookStateDeletePath = null,
      overrideHookStateRenamePath = null,
      overrideProps = null,
      overridePropsDeletePath = null,
      overridePropsRenamePath = null,
      scheduleUpdate = null,
      setErrorHandler = null,
      setSuspenseHandler = null;
    overrideHookState = function (fiber, id, path, value) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithSetImpl(id.memoizedState, path, 0, value)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function (fiber, id, path) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithDeleteImpl(id.memoizedState, path, 0)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      null !== id &&
        ((oldPath = copyWithRename(id.memoizedState, oldPath, newPath)),
        (id.memoizedState = oldPath),
        (id.baseState = oldPath),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (oldPath = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function (fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function (fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function (fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(
        fiber.memoizedProps,
        oldPath,
        newPath
      );
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function (fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    setErrorHandler = function (newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function (newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0,
      return_targetInst = null,
      hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents =
        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ),
      lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
      function (children, JSCompiler_OptimizeArgumentsArray_p2) {
        var root = this._internalRoot;
        if (null === root) throw Error("Cannot update an unmounted root.");
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p2
          ? console.error(
              "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
            )
          : isValidContainer(JSCompiler_OptimizeArgumentsArray_p2)
            ? console.error(
                "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
              )
            : "undefined" !== typeof JSCompiler_OptimizeArgumentsArray_p2 &&
              console.error(
                "You passed a second argument to root.render(...) but it only accepts one argument."
              );
        JSCompiler_OptimizeArgumentsArray_p2 = root.current;
        var lane = requestUpdateLane(JSCompiler_OptimizeArgumentsArray_p2);
        updateContainerImpl(
          JSCompiler_OptimizeArgumentsArray_p2,
          lane,
          children,
          root,
          null,
          null
        );
      };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
      function (JSCompiler_OptimizeArgumentsArray_p3) {
        "function" === typeof JSCompiler_OptimizeArgumentsArray_p3 &&
          console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
        JSCompiler_OptimizeArgumentsArray_p3 = this._internalRoot;
        if (null !== JSCompiler_OptimizeArgumentsArray_p3) {
          this._internalRoot = null;
          var container = JSCompiler_OptimizeArgumentsArray_p3.containerInfo;
          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
            console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
          updateContainerSync(
            null,
            JSCompiler_OptimizeArgumentsArray_p3,
            null,
            null
          );
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
      target
    ) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target: target, priority: updatePriority };
        for (
          var i = 0;
          i < queuedExplicitHydrationTargets.length &&
          0 !== updatePriority &&
          updatePriority < queuedExplicitHydrationTargets[i].priority;
          i++
        );
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    (function () {
      var isomorphicReactPackageVersion = React.version;
      if ("19.0.0" !== isomorphicReactPackageVersion)
        throw Error(
          'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
            (isomorphicReactPackageVersion +
              "\n  - react-dom:  19.0.0\nLearn more: https://react.dev/warnings/version-mismatch")
        );
    })();
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
      );
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(
          "Argument appears to not be a ReactComponent. Keys: " +
            componentOrElement
        );
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement =
        null !== componentOrElement
          ? findCurrentHostFiberImpl(componentOrElement)
          : null;
      componentOrElement =
        null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (
      !(function () {
        var internals = {
          bundleType: 1,
          version: "19.0.0",
          rendererPackageName: "react-dom",
          currentDispatcherRef: ReactSharedInternals,
          findFiberByHostInstance: getClosestInstanceFromNode,
          reconcilerVersion: "19.0.0"
        };
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        internals.getLaneLabelMap = getLaneLabelMap;
        internals.injectProfilingHooks = injectProfilingHooks;
        return injectInternals(internals);
      })() &&
      canUseDOM &&
      window.top === window.self &&
      ((-1 < navigator.userAgent.indexOf("Chrome") &&
        -1 === navigator.userAgent.indexOf("Edge")) ||
        -1 < navigator.userAgent.indexOf("Firefox"))
    ) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) &&
        console.info(
          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" +
            ("file:" === protocol
              ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq"
              : ""),
          "font-weight:bold"
        );
    }
    exports.createRoot = function (container, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null;
      null !== options &&
        void 0 !== options &&
        (options.hydrate
          ? console.warn(
              "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
            )
          : "object" === typeof options &&
            null !== options &&
            options.$$typeof === REACT_ELEMENT_TYPE &&
            console.error(
              "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
            ),
        !0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.unstable_transitionCallbacks &&
          (transitionCallbacks = options.unstable_transitionCallbacks));
      options = createFiberRoot(
        container,
        1,
        !1,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        null
      );
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(
        8 === container.nodeType ? container.parentNode : container
      );
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function (container, initialChildren, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      void 0 === initialChildren &&
        console.error(
          "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
        );
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null,
        formState = null;
      null !== options &&
        void 0 !== options &&
        (!0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.unstable_transitionCallbacks &&
          (transitionCallbacks = options.unstable_transitionCallbacks),
        void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        !0,
        initialChildren,
        null != options ? options : null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        formState
      );
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      initialChildren.current.lanes = isStrictMode;
      markRootUpdated$1(initialChildren, isStrictMode);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result &&
        (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            key[Symbol.toStringTag]) ||
            key.constructor.name ||
            "Object"
        ),
        testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : "string" === typeof thing
              ? JSON.stringify(thing)
              : "number" === typeof thing
                ? "`" + thing + "`"
                : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      Internals;
    exports.createPortal = function (children, container) {
      var key =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (
        !container ||
        (1 !== container.nodeType &&
          9 !== container.nodeType &&
          11 !== container.nodeType)
      )
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))
          return fn();
      } finally {
        (ReactSharedInternals.T = previousTransition),
          (Internals.p = previousUpdatePriority),
          Internals.d.f() &&
            console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href
        ? null != options && "object" !== typeof options
          ? console.error(
              "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : null != options &&
            "string" !== typeof options.crossOrigin &&
            console.error(
              "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
            )
        : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      "string" === typeof href &&
        (options
          ? ((options = options.crossOrigin),
            (options =
              "string" === typeof options
                ? "use-credentials" === options
                  ? options
                  : ""
                : void 0))
          : (options = null),
        Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
      else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin")
          ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href
        ? null == options || "object" !== typeof options
          ? console.error(
              "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : "style" !== options.as &&
            "script" !== options.as &&
            console.error(
              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
              getValueDescriptorExpectingEnumForWarning(options.as)
            )
        : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      if (
        "string" === typeof href &&
        options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity =
            "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority =
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0;
        "style" === as
          ? Internals.d.S(
              href,
              "string" === typeof options.precedence
                ? options.precedence
                : void 0,
              {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority
              }
            )
          : "script" === as &&
            Internals.d.X(href, {
              crossOrigin: crossOrigin,
              integrity: integrity,
              fetchPriority: fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "script" !== options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingEnumForWarning(options.as) +
            ".");
      if (encountered)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          encountered
        );
      else
        switch (
          ((encountered =
            options && "string" === typeof options.as ? options.as : "script"),
          encountered)
        ) {
          case "script":
            break;
          default:
            (encountered =
              getValueDescriptorExpectingEnumForWarning(encountered)),
              console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
        }
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as)
            (encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
              Internals.d.M(href, {
                crossOrigin: encountered,
                integrity:
                  "string" === typeof options.integrity
                    ? options.integrity
                    : void 0,
                nonce:
                  "string" === typeof options.nonce ? options.nonce : void 0
              });
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      null == options || "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : ("string" === typeof options.as && options.as) ||
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
      if (
        "string" === typeof href &&
        "object" === typeof options &&
        null !== options &&
        "string" === typeof options.as
      ) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(
          encountered,
          options.crossOrigin
        );
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority:
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0,
          referrerPolicy:
            "string" === typeof options.referrerPolicy
              ? options.referrerPolicy
              : void 0,
          imageSrcSet:
            "string" === typeof options.imageSrcSet
              ? options.imageSrcSet
              : void 0,
          imageSizes:
            "string" === typeof options.imageSizes
              ? options.imageSizes
              : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "string" !== typeof options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
      "string" === typeof href &&
        (options
          ? ((encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
            Internals.d.m(href, {
              as:
                "string" === typeof options.as && "script" !== options.as
                  ? options.as
                  : void 0,
              crossOrigin: encountered,
              integrity:
                "string" === typeof options.integrity
                  ? options.integrity
                  : void 0
            }))
          : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-client.development.js */ "./node_modules/react-dom/cjs/react-dom-client.development.js");
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react-router/node_modules/cookie/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-router/node_modules/cookie/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */
const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */
const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */
const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (() => {
    const C = function () { };
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */
function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2)
        return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
            break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    } while (index < len);
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index;
    } while (++index < max);
    return max;
}
function endIndex(str, index, min) {
    while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */
function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
        return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) ||
            !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string"
            ? options.priority.toLowerCase()
            : undefined;
        switch (priority) {
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string"
            ? options.sameSite.toLowerCase()
            : options.sameSite;
        switch (sameSite) {
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */
function decode(str) {
    if (str.indexOf("%") === -1)
        return str;
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */
function isDate(val) {
    return __toString.call(val) === "[object Date]";
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE$2
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
      if (null == type) return "";
      if ("function" === typeof type) {
        var prototype = type.prototype;
        return describeNativeComponentFrame(
          type,
          !(!prototype || !prototype.isReactComponent)
        );
      }
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return (type = describeNativeComponentFrame(type.render, !1)), type;
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type);
          case REACT_LAZY_TYPE:
            prototype = type._payload;
            type = type._init;
            try {
              return describeUnknownElementTypeFrameInDEV(type(prototype));
            } catch (x) {}
        }
      return "";
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(
      type,
      config,
      maybeKey,
      isStaticChildren,
      source,
      self
    ) {
      if (
        "string" === typeof type ||
        "function" === typeof type ||
        type === REACT_FRAGMENT_TYPE ||
        type === REACT_PROFILER_TYPE ||
        type === REACT_STRICT_MODE_TYPE ||
        type === REACT_SUSPENSE_TYPE ||
        type === REACT_SUSPENSE_LIST_TYPE ||
        type === REACT_OFFSCREEN_TYPE ||
        ("object" === typeof type &&
          null !== type &&
          (type.$$typeof === REACT_LAZY_TYPE ||
            type.$$typeof === REACT_MEMO_TYPE ||
            type.$$typeof === REACT_CONTEXT_TYPE ||
            type.$$typeof === REACT_CONSUMER_TYPE ||
            type.$$typeof === REACT_FORWARD_REF_TYPE ||
            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||
            void 0 !== type.getModuleId))
      ) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (
                isStaticChildren = 0;
                isStaticChildren < children.length;
                isStaticChildren++
              )
                validateChildKeys(children[isStaticChildren], type);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children, type);
      } else {
        children = "";
        if (
          void 0 === type ||
          ("object" === typeof type &&
            null !== type &&
            0 === Object.keys(type).length)
        )
          children +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        null === type
          ? (isStaticChildren = "null")
          : isArrayImpl(type)
            ? (isStaticChildren = "array")
            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
              ? ((isStaticChildren =
                  "<" +
                  (getComponentNameFromType(type.type) || "Unknown") +
                  " />"),
                (children =
                  " Did you accidentally export a JSX literal instead of a component?"))
              : (isStaticChildren = typeof type);
        console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          isStaticChildren,
          children
        );
      }
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren =
          0 < keys.length
            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
            : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] ||
          ((keys =
            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
          console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ),
          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
      }
      children = null;
      void 0 !== maybeKey &&
        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
      hasValidKey(config) &&
        (checkKeyStringCoercion(config.key), (children = "" + config.key));
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children &&
        defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
      if (
        "object" === typeof node &&
        node &&
        node.$$typeof !== REACT_CLIENT_REFERENCE
      )
        if (isArrayImpl(node))
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            isValidElement(child) && validateExplicitKey(child, parentType);
          }
        else if (isValidElement(node))
          node._store && (node._store.validated = 1);
        else if (
          (null === node || "object" !== typeof node
            ? (i = null)
            : ((i =
                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                node["@@iterator"]),
              (i = "function" === typeof i ? i : null)),
          "function" === typeof i &&
            i !== node.entries &&
            ((i = i.call(node)), i !== node))
        )
          for (; !(node = i.next()).done; )
            isValidElement(node.value) &&
              validateExplicitKey(node.value, parentType);
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function validateExplicitKey(element, parentType) {
      if (
        element._store &&
        !element._store.validated &&
        null == element.key &&
        ((element._store.validated = 1),
        (parentType = getCurrentComponentErrorInfo(parentType)),
        !ownerHasKeyUseWarning[parentType])
      ) {
        ownerHasKeyUseWarning[parentType] = !0;
        var childOwner = "";
        element &&
          null != element._owner &&
          element._owner !== getOwner() &&
          ((childOwner = null),
          "number" === typeof element._owner.tag
            ? (childOwner = getComponentNameFromType(element._owner.type))
            : "string" === typeof element._owner.name &&
              (childOwner = element._owner.name),
          (childOwner = " It was passed a child from " + childOwner + "."));
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
        ReactSharedInternals.getCurrentStack = function () {
          var stack = describeUnknownElementTypeFrameInDEV(element.type);
          prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
          return stack;
        };
        console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          parentType,
          childOwner
        );
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function getCurrentComponentErrorInfo(parentType) {
      var info = "",
        owner = getOwner();
      owner &&
        (owner = getComponentNameFromType(owner.type)) &&
        (info = "\n\nCheck the render method of `" + owner + "`.");
      info ||
        ((parentType = getComponentNameFromType(parentType)) &&
          (info =
            "\n\nCheck the top-level render call using <" + parentType + ">."));
      return info;
    }
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      assign = Object.assign,
      REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
      isArrayImpl = Array.isArray,
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {},
      ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function (type, config, maybeKey, source, self) {
      return jsxDEVImpl(type, config, maybeKey, !1, source, self);
    };
    exports.jsxs = function (type, config, maybeKey, source, self) {
      return jsxDEVImpl(type, config, maybeKey, !0, source, self);
    };
  })();


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn(
            "%s(...) is deprecated in plain JavaScript React classes. %s",
            info[0],
            info[1]
          );
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance =
        ((publicInstance = publicInstance.constructor) &&
          (publicInstance.displayName || publicInstance.name)) ||
        "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] ||
        (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ),
        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE$2
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function isValidElementType(type) {
      return "string" === typeof type ||
        "function" === typeof type ||
        type === REACT_FRAGMENT_TYPE ||
        type === REACT_PROFILER_TYPE ||
        type === REACT_STRICT_MODE_TYPE ||
        type === REACT_SUSPENSE_TYPE ||
        type === REACT_SUSPENSE_LIST_TYPE ||
        type === REACT_OFFSCREEN_TYPE ||
        ("object" === typeof type &&
          null !== type &&
          (type.$$typeof === REACT_LAZY_TYPE ||
            type.$$typeof === REACT_MEMO_TYPE ||
            type.$$typeof === REACT_CONTEXT_TYPE ||
            type.$$typeof === REACT_CONSUMER_TYPE ||
            type.$$typeof === REACT_FORWARD_REF_TYPE ||
            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||
            void 0 !== type.getModuleId))
        ? !0
        : !1;
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
      if (null == type) return "";
      if ("function" === typeof type) {
        var prototype = type.prototype;
        return describeNativeComponentFrame(
          type,
          !(!prototype || !prototype.isReactComponent)
        );
      }
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return (type = describeNativeComponentFrame(type.render, !1)), type;
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type);
          case REACT_LAZY_TYPE:
            prototype = type._payload;
            type = type._init;
            try {
              return describeUnknownElementTypeFrameInDEV(type(prototype));
            } catch (x) {}
        }
      return "";
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        oldElement._owner,
        oldElement.props
      );
      newKey._store.validated = oldElement._store.validated;
      return newKey;
    }
    function validateChildKeys(node, parentType) {
      if (
        "object" === typeof node &&
        node &&
        node.$$typeof !== REACT_CLIENT_REFERENCE
      )
        if (isArrayImpl(node))
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            isValidElement(child) && validateExplicitKey(child, parentType);
          }
        else if (isValidElement(node))
          node._store && (node._store.validated = 1);
        else if (
          ((i = getIteratorFn(node)),
          "function" === typeof i &&
            i !== node.entries &&
            ((i = i.call(node)), i !== node))
        )
          for (; !(node = i.next()).done; )
            isValidElement(node.value) &&
              validateExplicitKey(node.value, parentType);
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function validateExplicitKey(element, parentType) {
      if (
        element._store &&
        !element._store.validated &&
        null == element.key &&
        ((element._store.validated = 1),
        (parentType = getCurrentComponentErrorInfo(parentType)),
        !ownerHasKeyUseWarning[parentType])
      ) {
        ownerHasKeyUseWarning[parentType] = !0;
        var childOwner = "";
        element &&
          null != element._owner &&
          element._owner !== getOwner() &&
          ((childOwner = null),
          "number" === typeof element._owner.tag
            ? (childOwner = getComponentNameFromType(element._owner.type))
            : "string" === typeof element._owner.name &&
              (childOwner = element._owner.name),
          (childOwner = " It was passed a child from " + childOwner + "."));
        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
        ReactSharedInternals.getCurrentStack = function () {
          var stack = describeUnknownElementTypeFrameInDEV(element.type);
          prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
          return stack;
        };
        console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          parentType,
          childOwner
        );
        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
      }
    }
    function getCurrentComponentErrorInfo(parentType) {
      var info = "",
        owner = getOwner();
      owner &&
        (owner = getComponentNameFromType(owner.type)) &&
        (info = "\n\nCheck the render method of `" + owner + "`.");
      info ||
        ((parentType = getComponentNameFromType(parentType)) &&
          (info =
            "\n\nCheck the top-level render call using <" + parentType + ">."));
      return info;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return (
        "$" +
        key.replace(/[=:]/g, function (match) {
          return escaperLookup[match];
        })
      );
    }
    function getElementKey(element, index) {
      return "object" === typeof element &&
        null !== element &&
        null != element.key
        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
        : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (
            ("string" === typeof thenable.status
              ? thenable.then(noop$1, noop$1)
              : ((thenable.status = "pending"),
                thenable.then(
                  function (fulfilledValue) {
                    "pending" === thenable.status &&
                      ((thenable.status = "fulfilled"),
                      (thenable.value = fulfilledValue));
                  },
                  function (error) {
                    "pending" === thenable.status &&
                      ((thenable.status = "rejected"),
                      (thenable.reason = error));
                  }
                )),
            thenable.status)
          ) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = !0;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = !0;
                break;
              case REACT_LAZY_TYPE:
                return (
                  (invokeCallback = children._init),
                  mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  )
                );
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey =
          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback)
          ? ((escapedPrefix = ""),
            null != childKey &&
              (escapedPrefix =
                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
              return c;
            }))
          : null != callback &&
            (isValidElement(callback) &&
              (null != callback.key &&
                ((invokeCallback && invokeCallback.key === callback.key) ||
                  checkKeyStringCoercion(callback.key)),
              (escapedPrefix = cloneAndReplaceKey(
                callback,
                escapedPrefix +
                  (null == callback.key ||
                  (invokeCallback && invokeCallback.key === callback.key)
                    ? ""
                    : ("" + callback.key).replace(
                        userProvidedKeyEscapeRegex,
                        "$&/"
                      ) + "/") +
                  childKey
              )),
              "" !== nameSoFar &&
                null != invokeCallback &&
                isValidElement(invokeCallback) &&
                null == invokeCallback.key &&
                invokeCallback._store &&
                !invokeCallback._store.validated &&
                (escapedPrefix._store.validated = 2),
              (callback = escapedPrefix)),
            array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          (nameSoFar = children[i]),
            (type = childKey + getElementKey(nameSoFar, i)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if (((i = getIteratorFn(children)), "function" === typeof i))
        for (
          i === children.entries &&
            (didWarnAboutMaps ||
              console.warn(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ),
            (didWarnAboutMaps = !0)),
            children = i.call(children),
            i = 0;
          !(nameSoFar = children.next()).done;

        )
          (nameSoFar = nameSoFar.value),
            (type = childKey + getElementKey(nameSoFar, i++)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " +
            ("[object Object]" === array
              ? "object with keys {" + Object.keys(children).join(", ") + "}"
              : array) +
            "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function (moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 1), (payload._result = moduleObject);
          },
          function (error) {
            if (0 === payload._status || -1 === payload._status)
              (payload._status = 2), (payload._result = error);
          }
        );
        -1 === payload._status &&
          ((payload._status = 0), (payload._result = ctor));
      }
      if (1 === payload._status)
        return (
          (ctor = payload._result),
          void 0 === ctor &&
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ),
          "default" in ctor ||
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ),
          ctor.default
        );
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (null === enqueueTaskImpl)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(
            module,
            "timers"
          ).setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function (callback) {
            !1 === didWarnAboutMessageChannel &&
              ((didWarnAboutMessageChannel = !0),
              "undefined" === typeof MessageChannel &&
                console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
            var channel = new MessageChannel();
            channel.port1.onmessage = callback;
            channel.port2.postMessage(void 0);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError
        ? new AggregateError(errors)
        : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 &&
        console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue)
        if (0 !== queue.length)
          try {
            flushActQueue(queue);
            enqueueTask(function () {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length
        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          reject(queue))
        : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if (
        "object" !== typeof partialState &&
        "function" !== typeof partialState &&
        null != partialState
      )
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      },
      fnName;
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) &&
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      specialPropKeyWarningShown,
      didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var ownerHasKeyUseWarning = {},
      didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks =
        "function" === typeof queueMicrotask
          ? function (callback) {
              queueMicrotask(function () {
                return queueMicrotask(callback);
              });
            }
          : enqueueTask;
    exports.Children = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function () {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return (
          mapChildren(children, function (child) {
            return child;
          }) || []
        );
      },
      only: function (children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      ReactSharedInternals;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = (ReactSharedInternals.actQueue =
          null !== prevActQueue ? prevActQueue : []),
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          (popActScope(prevActQueue, prevActScopeDepth),
          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      if (
        null !== result &&
        "object" === typeof result &&
        "function" === typeof result.then
      ) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall ||
            didWarnNoAwaitAct ||
            ((didWarnNoAwaitAct = !0),
            console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(
              function (returnValue) {
                popActScope(prevActQueue, prevActScopeDepth);
                if (0 === prevActScopeDepth) {
                  try {
                    flushActQueue(queue),
                      enqueueTask(function () {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                  } catch (error$2) {
                    ReactSharedInternals.thrownErrors.push(error$2);
                  }
                  if (0 < ReactSharedInternals.thrownErrors.length) {
                    var _thrownError = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    );
                    ReactSharedInternals.thrownErrors.length = 0;
                    reject(_thrownError);
                  }
                } else resolve(returnValue);
              },
              function (error) {
                popActScope(prevActQueue, prevActScopeDepth);
                0 < ReactSharedInternals.thrownErrors.length
                  ? ((error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    )),
                    (ReactSharedInternals.thrownErrors.length = 0),
                    reject(error))
                  : reject(error);
              }
            );
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth &&
        (flushActQueue(queue),
        0 !== queue.length &&
          queueSeveralMicrotasks(function () {
            didAwaitActCall ||
              didWarnNoAwaitAct ||
              ((didWarnNoAwaitAct = !0),
              console.error(
                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
              ));
          }),
        (ReactSharedInternals.actQueue = null));
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth
            ? ((ReactSharedInternals.actQueue = queue),
              enqueueTask(function () {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              }))
            : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " +
            element +
            "."
        );
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (
            hasOwnProperty.call(config, "ref") &&
            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) &&
            JSCompiler_inline_result.isReactWarning
          ) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (key = "" + config.key));
        for (propName in config)
          !hasOwnProperty.call(config, propName) ||
            "key" === propName ||
            "__self" === propName ||
            "__source" === propName ||
            ("ref" === propName && void 0 === config.ref) ||
            (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, void 0, void 0, owner, props);
      for (key = 2; key < arguments.length; key++)
        validateChildKeys(arguments[key], props.type);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      if (isValidElementType(type))
        for (var i = 2; i < arguments.length; i++)
          validateChildKeys(arguments[i], type);
      else {
        i = "";
        if (
          void 0 === type ||
          ("object" === typeof type &&
            null !== type &&
            0 === Object.keys(type).length)
        )
          i +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        if (null === type) var typeString = "null";
        else
          isArrayImpl(type)
            ? (typeString = "array")
            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
              ? ((typeString =
                  "<" +
                  (getComponentNameFromType(type.type) || "Unknown") +
                  " />"),
                (i =
                  " Did you accidentally export a JSX literal instead of a component?"))
              : (typeString = typeof type);
        console.error(
          "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          typeString,
          i
        );
      }
      var propName;
      i = {};
      typeString = null;
      if (null != config)
        for (propName in (didWarnAboutOldJSXRuntime ||
          !("__self" in config) ||
          "key" in config ||
          ((didWarnAboutOldJSXRuntime = !0),
          console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )),
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (typeString = "" + config.key)),
        config))
          hasOwnProperty.call(config, propName) &&
            "key" !== propName &&
            "__self" !== propName &&
            "__source" !== propName &&
            (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;
      else if (1 < childrenLength) {
        for (
          var childArray = Array(childrenLength), _i = 0;
          _i < childrenLength;
          _i++
        )
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in ((childrenLength = type.defaultProps), childrenLength))
          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      typeString &&
        defineKeyPropWarningGetter(
          i,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
    };
    exports.createRef = function () {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE
        ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          )
        : "function" !== typeof render
          ? console.error(
              "forwardRef requires a render function but was given %s.",
              null === render ? "null" : typeof render
            )
          : 0 !== render.length &&
            2 !== render.length &&
            console.error(
              "forwardRef render functions accept exactly two parameters: props and ref. %s",
              1 === render.length
                ? "Did you forget to use the ref parameter?"
                : "Any additional parameter will be undefined."
            );
      null != render &&
        null != render.defaultProps &&
        console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name ||
            render.displayName ||
            (Object.defineProperty(render, "name", { value: name }),
            (render.displayName = name));
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function (type, compare) {
      isValidElementType(type) ||
        console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name ||
            type.displayName ||
            (Object.defineProperty(type, "name", { value: name }),
            (type.displayName = name));
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue &&
          null !== returnValue &&
          "function" === typeof returnValue.then &&
          returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition &&
          currentTransition._updatedFibers &&
          ((scope = currentTransition._updatedFibers.size),
          currentTransition._updatedFibers.clear(),
          10 < scope &&
            console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )),
          (ReactSharedInternals.T = prevTransition);
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(
        action,
        initialState,
        permalink
      );
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE &&
        console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, deps) {
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      return resolveDispatcher().useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.0.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function performWorkUntilDeadline() {
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          a: {
            isHostCallbackScheduled = !1;
            isHostTimeoutScheduled &&
              ((isHostTimeoutScheduled = !1),
              localClearTimeout(taskTimeoutID),
              (taskTimeoutID = -1));
            isPerformingWork = !0;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (
                  currentTask = peek(taskQueue);
                  null !== currentTask &&
                  !(
                    currentTask.expirationTime > currentTime &&
                    shouldYieldToHost()
                  );

                ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = !0;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = !0;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer &&
                    requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                  hasMoreWork = !1;
                }
              }
              break a;
            } finally {
              (currentTask = null),
                (currentPriorityLevel = previousPriorityLevel),
                (isPerformingWork = !1);
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork
            ? schedulePerformWorkUntilDeadline()
            : (isMessageLoopRunning = !1);
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = (index - 1) >>> 1,
          parent = heap[parentIndex];
        if (0 < compare(parent, node))
          (heap[parentIndex] = node),
            (heap[index] = parent),
            (index = parentIndex);
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0],
        last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (
          var index = 0, length = heap.length, halfLength = length >>> 1;
          index < halfLength;

        ) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left)
              ? ((heap[index] = right),
                (heap[rightIndex] = last),
                (index = rightIndex))
              : ((heap[index] = left),
                (heap[leftIndex] = last),
                (index = leftIndex));
          else if (rightIndex < length && 0 > compare(right, last))
            (heap[index] = right),
              (heap[rightIndex] = last),
              (index = rightIndex);
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue),
            (timer.sortIndex = timer.expirationTime),
            push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          (isHostCallbackScheduled = !0), requestHostCallback();
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer &&
            requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
        }
    }
    function shouldYieldToHost() {
      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback() {
      isMessageLoopRunning ||
        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      var localPerformance = performance;
      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date,
        initialTime = localDate.now();
      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
      localClearTimeout =
        "function" === typeof clearTimeout ? clearTimeout : null,
      localSetImmediate =
        "undefined" !== typeof setImmediate ? setImmediate : null,
      isMessageLoopRunning = !1,
      taskTimeoutID = -1,
      frameInterval = 5,
      startTime = -1;
    if ("function" === typeof localSetImmediate)
      var schedulePerformWorkUntilDeadline = function () {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(),
        port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function () {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function () {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function () {
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0), requestHostCallback());
    };
    exports.unstable_forceFrameRate = function (fps) {
      0 > fps || 125 < fps
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function () {
      return peek(taskQueue);
    };
    exports.unstable_next = function (eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function () {};
    exports.unstable_requestPaint = function () {};
    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function (
      priorityLevel,
      callback,
      options
    ) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options
        ? ((options = options.delay),
          (options =
            "number" === typeof options && 0 < options
              ? currentTime + options
              : currentTime))
        : (options = currentTime);
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime
        ? ((priorityLevel.sortIndex = options),
          push(timerQueue, priorityLevel),
          null === peek(taskQueue) &&
            priorityLevel === peek(timerQueue) &&
            (isHostTimeoutScheduled
              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
              : (isHostTimeoutScheduled = !0),
            requestHostTimeout(handleTimeout, options - currentTime)))
        : ((priorityLevel.sortIndex = timeout),
          push(taskQueue, priorityLevel),
          isHostCallbackScheduled ||
            isPerformingWork ||
            ((isHostCallbackScheduled = !0), requestHostCallback()));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function (callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ ((module) => {



var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false,
};

function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}

function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);

  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name = parsed.name;
  var value = parsed.value;

  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  try {
    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
  } catch (e) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" +
        value +
        "'. Set options.decodeValues to false to disable this feature.",
      e
    );
  }

  var cookie = {
    name: name,
    value: value,
  };

  parts.forEach(function (part) {
    var sides = part.split("=");
    var key = sides.shift().trimLeft().toLowerCase();
    var value = sides.join("=");
    if (key === "expires") {
      cookie.expires = new Date(value);
    } else if (key === "max-age") {
      cookie.maxAge = parseInt(value, 10);
    } else if (key === "secure") {
      cookie.secure = true;
    } else if (key === "httponly") {
      cookie.httpOnly = true;
    } else if (key === "samesite") {
      cookie.sameSite = value;
    } else if (key === "partitioned") {
      cookie.partitioned = true;
    } else {
      cookie[key] = value;
    }
  });

  return cookie;
}

function parseNameValuePair(nameValuePairStr) {
  // Parses name-value-pair according to rfc6265bis draft

  var name = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
  } else {
    value = nameValuePairStr;
  }

  return { name: name, value: value };
}

function parse(input, options) {
  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }

  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      // for fetch responses - they combine headers of the same type in the headers array,
      // but getSetCookie returns an uncombined array
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      // fast-path for node.js (which automatically normalizes header names to lower-case
      input = input.headers["set-cookie"];
    } else {
      // slow-path for other environments - see #25
      var sch =
        input.headers[
          Object.keys(input.headers).find(function (key) {
            return key.toLowerCase() === "set-cookie";
          })
        ];
      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
      if (!sch && input.headers.cookie && !options.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }

  if (!options.map) {
    return input.filter(isNonEmptyString).map(function (str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
      var cookie = parseString(str, options);
      cookies[cookie.name] = cookie;
      return cookies;
    }, cookies);
  }
}

/*
  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
  that are within a single set-cookie field-value, such as in the Expires portion.

  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
  React Native's fetch does this for *every* header, including set-cookie.

  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
*/
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }

  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;

  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }

  function notSpecialChar() {
    ch = cookiesString.charAt(pos);

    return ch !== "=" && ch !== ";" && ch !== ",";
  }

  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;

    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        // ',' is a cookie separator if we have later first '=', not ';' or ','
        lastComma = pos;
        pos += 1;

        skipWhitespace();
        nextStart = pos;

        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }

        // currently special character
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          // we found cookies separator
          cookiesSeparatorFound = true;
          // pos is inside the next cookie, so back up and return it.
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          // in param ',' or param separator ';',
          // we continue from that comma
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }

    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }

  return cookiesStrings;
}

module.exports = parse;
module.exports.parse = parse;
module.exports.parseString = parseString;
module.exports.splitCookiesString = splitCookiesString;


/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!../node_modules/sass-loader/dist/cjs.js!./index.scss */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/sass-loader/dist/cjs.js!./src/index.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/App.tsx":
/*!*********************!*\
  !*** ./src/App.tsx ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.scss */ "./src/index.scss");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-SYFQ2XB5.mjs");
/* harmony import */ var _pages_AboutPage_AboutPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pages/AboutPage/AboutPage */ "./src/pages/AboutPage/AboutPage.tsx");
/* harmony import */ var _pages_MainPage_MainPage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/MainPage/MainPage */ "./src/pages/MainPage/MainPage.tsx");





var App = function () {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.Link, { to: '/', children: "\u0413\u043B\u0430\u0432\u043D\u0430\u044F " }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.Link, { to: '/about', children: "\u041E \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.Routes, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.Route, { path: '/about', element: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_pages_AboutPage_AboutPage__WEBPACK_IMPORTED_MODULE_2__["default"], {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.Route, { path: '/', element: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_pages_MainPage_MainPage__WEBPACK_IMPORTED_MODULE_3__["default"], {}) })] })] }) }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);


/***/ }),

/***/ "./src/pages/AboutPage/AboutPage.tsx":
/*!*******************************************!*\
  !*** ./src/pages/AboutPage/AboutPage.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

var AboutPage = function () {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: "About Page!" }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AboutPage);


/***/ }),

/***/ "./src/pages/MainPage/MainPage.tsx":
/*!*****************************************!*\
  !*** ./src/pages/MainPage/MainPage.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

var MainPage = function () {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: "MainPage!" }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainPage);


/***/ }),

/***/ "./node_modules/react-router/dist/development/chunk-SYFQ2XB5.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-router/dist/development/chunk-SYFQ2XB5.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Action: () => (/* binding */ Action),
/* harmony export */   Await: () => (/* binding */ Await),
/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),
/* harmony export */   DataRouterContext: () => (/* binding */ DataRouterContext),
/* harmony export */   DataRouterStateContext: () => (/* binding */ DataRouterStateContext),
/* harmony export */   ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),
/* harmony export */   FetchersContext: () => (/* binding */ FetchersContext),
/* harmony export */   Form: () => (/* binding */ Form),
/* harmony export */   FrameworkContext: () => (/* binding */ FrameworkContext),
/* harmony export */   HashRouter: () => (/* binding */ HashRouter),
/* harmony export */   HistoryRouter: () => (/* binding */ HistoryRouter),
/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),
/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   Link: () => (/* binding */ Link),
/* harmony export */   Links: () => (/* binding */ Links),
/* harmony export */   LocationContext: () => (/* binding */ LocationContext),
/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   NavLink: () => (/* binding */ NavLink),
/* harmony export */   Navigate: () => (/* binding */ Navigate),
/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),
/* harmony export */   Outlet: () => (/* binding */ Outlet),
/* harmony export */   PrefetchPageLinks: () => (/* binding */ PrefetchPageLinks),
/* harmony export */   RemixErrorBoundary: () => (/* binding */ RemixErrorBoundary),
/* harmony export */   Route: () => (/* binding */ Route),
/* harmony export */   RouteContext: () => (/* binding */ RouteContext),
/* harmony export */   Router: () => (/* binding */ Router),
/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),
/* harmony export */   Routes: () => (/* binding */ Routes),
/* harmony export */   Scripts: () => (/* binding */ Scripts),
/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),
/* harmony export */   ServerMode: () => (/* binding */ ServerMode),
/* harmony export */   ServerRouter: () => (/* binding */ ServerRouter),
/* harmony export */   SingleFetchRedirectSymbol: () => (/* binding */ SingleFetchRedirectSymbol),
/* harmony export */   StaticRouter: () => (/* binding */ StaticRouter),
/* harmony export */   StaticRouterProvider: () => (/* binding */ StaticRouterProvider),
/* harmony export */   ViewTransitionContext: () => (/* binding */ ViewTransitionContext),
/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),
/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),
/* harmony export */   createClientRoutes: () => (/* binding */ createClientRoutes),
/* harmony export */   createClientRoutesWithHMRRevalidationOptOut: () => (/* binding */ createClientRoutesWithHMRRevalidationOptOut),
/* harmony export */   createCookie: () => (/* binding */ createCookie),
/* harmony export */   createCookieSessionStorage: () => (/* binding */ createCookieSessionStorage),
/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),
/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),
/* harmony export */   createMemorySessionStorage: () => (/* binding */ createMemorySessionStorage),
/* harmony export */   createPath: () => (/* binding */ createPath),
/* harmony export */   createRequestHandler: () => (/* binding */ createRequestHandler),
/* harmony export */   createRouter: () => (/* binding */ createRouter),
/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),
/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromElements),
/* harmony export */   createRoutesStub: () => (/* binding */ createRoutesStub),
/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),
/* harmony export */   createSession: () => (/* binding */ createSession),
/* harmony export */   createSessionStorage: () => (/* binding */ createSessionStorage),
/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler2),
/* harmony export */   createStaticRouter: () => (/* binding */ createStaticRouter),
/* harmony export */   data: () => (/* binding */ data),
/* harmony export */   decodeViaTurboStream: () => (/* binding */ decodeViaTurboStream),
/* harmony export */   deserializeErrors: () => (/* binding */ deserializeErrors2),
/* harmony export */   generatePath: () => (/* binding */ generatePath),
/* harmony export */   getPatchRoutesOnNavigationFunction: () => (/* binding */ getPatchRoutesOnNavigationFunction),
/* harmony export */   getSingleFetchDataStrategy: () => (/* binding */ getSingleFetchDataStrategy),
/* harmony export */   invariant: () => (/* binding */ invariant),
/* harmony export */   isCookie: () => (/* binding */ isCookie),
/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),
/* harmony export */   isSession: () => (/* binding */ isSession),
/* harmony export */   mapRouteProperties: () => (/* binding */ mapRouteProperties),
/* harmony export */   matchPath: () => (/* binding */ matchPath),
/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),
/* harmony export */   parsePath: () => (/* binding */ parsePath),
/* harmony export */   redirect: () => (/* binding */ redirect),
/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),
/* harmony export */   renderMatches: () => (/* binding */ renderMatches),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   setDevServerHooks: () => (/* binding */ setDevServerHooks),
/* harmony export */   shouldHydrateRouteLoader: () => (/* binding */ shouldHydrateRouteLoader),
/* harmony export */   useActionData: () => (/* binding */ useActionData),
/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),
/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),
/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),
/* harmony export */   useBlocker: () => (/* binding */ useBlocker),
/* harmony export */   useFetcher: () => (/* binding */ useFetcher),
/* harmony export */   useFetchers: () => (/* binding */ useFetchers),
/* harmony export */   useFogOFWarDiscovery: () => (/* binding */ useFogOFWarDiscovery),
/* harmony export */   useFormAction: () => (/* binding */ useFormAction),
/* harmony export */   useHref: () => (/* binding */ useHref),
/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),
/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),
/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),
/* harmony export */   useLocation: () => (/* binding */ useLocation),
/* harmony export */   useMatch: () => (/* binding */ useMatch),
/* harmony export */   useMatches: () => (/* binding */ useMatches),
/* harmony export */   useNavigate: () => (/* binding */ useNavigate),
/* harmony export */   useNavigation: () => (/* binding */ useNavigation),
/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),
/* harmony export */   useOutlet: () => (/* binding */ useOutlet),
/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),
/* harmony export */   useParams: () => (/* binding */ useParams),
/* harmony export */   usePrompt: () => (/* binding */ usePrompt),
/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),
/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),
/* harmony export */   useRouteError: () => (/* binding */ useRouteError),
/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),
/* harmony export */   useRoutes: () => (/* binding */ useRoutes),
/* harmony export */   useScrollRestoration: () => (/* binding */ useScrollRestoration),
/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),
/* harmony export */   useSubmit: () => (/* binding */ useSubmit),
/* harmony export */   useViewTransitionState: () => (/* binding */ useViewTransitionState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var turbo_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! turbo-stream */ "./node_modules/turbo-stream/dist/turbo-stream.mjs");
/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cookie */ "./node_modules/react-router/node_modules/cookie/dist/index.js");
/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ "./node_modules/set-cookie-parser/lib/set-cookie.js");
/**
 * react-router v7.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

// lib/router/history.ts
var Action = /* @__PURE__ */ ((Action2) => {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
  return Action2;
})(Action || {});
var PopStateEventType = "popstate";
function createMemoryHistory(options = {}) {
  let { initialEntries = ["/"], initialIndex, v5Compat = false } = options;
  let entries;
  entries = initialEntries.map(
    (entry, index2) => createMemoryLocation(
      entry,
      typeof entry === "string" ? null : entry.state,
      index2 === 0 ? "default" : void 0
    )
  );
  let index = clampIndex(
    initialIndex == null ? entries.length - 1 : initialIndex
  );
  let action = "POP" /* Pop */;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state = null, key) {
    let location = createLocation(
      entries ? getCurrentLocation().pathname : "/",
      to,
      state,
      key
    );
    warning(
      location.pathname.charAt(0) === "/",
      `relative pathnames are not supported in memory history: ${JSON.stringify(
        to
      )}`
    );
    return location;
  }
  function createHref2(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref: createHref2,
    createURL(to) {
      return new URL(createHref2(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = "PUSH" /* Push */;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({ action, location: nextLocation, delta: 1 });
      }
    },
    replace(to, state) {
      action = "REPLACE" /* Replace */;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({ action, location: nextLocation, delta: 0 });
      }
    },
    go(delta) {
      action = "POP" /* Pop */;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({ action, location: nextLocation, delta });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function createHashHistory(options = {}) {
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substring(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(
      location.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        to
      )})`
    );
  }
  return getUrlBasedHistory(
    createHashLocation,
    createHashHref,
    validateHashLocation,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...typeof to === "string" ? parsePath(to) : to,
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP" /* Pop */;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP" /* Pop */;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH" /* Push */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE" /* Replace */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(
      base,
      `No window.location.(origin|href) available to create URL for href: ${href}`
    );
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}

// lib/router/utils.ts
var immutableRouteKeys = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
  return routes.map((route, index) => {
    let treePath = [...parentPath, String(index)];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(
      route.index !== true || !route.children,
      `Cannot specify children on an index route`
    );
    invariant(
      !manifest[id],
      `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
    );
    if (isIndexRoute(route)) {
      let indexRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id
      };
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id,
        children: void 0
      };
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(
          route.children,
          mapRouteProperties2,
          treePath,
          manifest
        );
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let { route, pathname, params } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function generatePath(originalPath, params = {}) {
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(
      false,
      `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
    );
    path = path.replace(/\*$/, "/*");
  }
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = (p) => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    if (isLastSegment && segment === "*") {
      const star = "*";
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, `Missing ":${key}" param`);
      return stringify(param);
    }
    return segment.replace(/\?$/g, "");
  }).filter((segment) => !!segment);
  return prefix + segments.join("/");
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  );
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else {
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
var DataWithResponseInit = class {
  constructor(data2, init) {
    this.type = "DataWithResponseInit";
    this.data = data2;
    this.init = init || null;
  }
};
function data(data2, init) {
  return new DataWithResponseInit(
    data2,
    typeof init === "number" ? { status: init } : init
  );
}
var redirect = (url, init = 302) => {
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = { status: responseInit };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, { ...responseInit, headers });
};
var redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
var replace = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Replace", "true");
  return response;
};
var ErrorResponseImpl = class {
  constructor(status, statusText, data2, internal = false) {
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data2 instanceof Error) {
      this.data = data2.toString();
      this.error = data2;
    } else {
      this.data = data2;
    }
  }
};
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

// lib/router/router.ts
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
var validMutationMethods = new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
var validRequestMethods = new Set(validRequestMethodsArr);
var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
var IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  invariant(
    init.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(
    init.routes,
    mapRouteProperties2,
    void 0,
    manifest
  );
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;
  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;
  let future = {
    ...init.future
  };
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions2 = null;
  let getScrollRestorationKey2 = null;
  let getScrollPosition = null;
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null && !patchRoutesOnNavigationImpl) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let { matches, route } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = { [route.id]: error };
  }
  if (initialMatches && !init.hydrationData) {
    let fogOfWar = checkFogOfWar(
      initialMatches,
      dataRoutes,
      init.history.location.pathname
    );
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    initialized = false;
    initialMatches = [];
    let fogOfWar = checkFogOfWar(
      null,
      dataRoutes,
      init.history.location.pathname
    );
    if (fogOfWar.active && fogOfWar.matches) {
      initialMatches = fogOfWar.matches;
    }
  } else if (initialMatches.some((m) => m.route.lazy)) {
    initialized = false;
  } else if (!initialMatches.some((m) => m.route.loader)) {
    initialized = true;
  } else {
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    if (errors) {
      let idx = initialMatches.findIndex(
        (m) => errors[m.route.id] !== void 0
      );
      initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    } else {
      initialized = initialMatches.every(
        (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
      );
    }
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = "POP" /* Pop */;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */ new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledFetcherLoads = /* @__PURE__ */ new Set();
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeFetchers = /* @__PURE__ */ new Map();
  let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let unblockBlockerHistoryUpdate = void 0;
  let pendingRevalidationDfd = null;
  function initialize() {
    unlistenHistory = init.history.listen(
      ({ action: historyAction, location, delta }) => {
        if (unblockBlockerHistoryUpdate) {
          unblockBlockerHistoryUpdate();
          unblockBlockerHistoryUpdate = void 0;
          return;
        }
        warning(
          blockerFunctions.size === 0 || delta != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let blockerKey = shouldBlockNavigation({
          currentLocation: state.location,
          nextLocation: location,
          historyAction
        });
        if (blockerKey && delta != null) {
          let nextHistoryUpdatePromise = new Promise((resolve) => {
            unblockBlockerHistoryUpdate = resolve;
          });
          init.history.go(delta * -1);
          updateBlocker(blockerKey, {
            state: "blocked",
            location,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location
              });
              nextHistoryUpdatePromise.then(() => init.history.go(delta));
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({ blockers });
            }
          });
          return;
        }
        return startNavigation(historyAction, location);
      }
    );
    if (isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    if (!state.initialized) {
      startNavigation("POP" /* Pop */, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState, opts = {}) {
    state = {
      ...state,
      ...newState
    };
    let unmountedFetchers = [];
    let mountedFetchers = [];
    state.fetchers.forEach((fetcher, key) => {
      if (fetcher.state === "idle") {
        if (fetchersQueuedForDeletion.has(key)) {
          unmountedFetchers.push(key);
        } else {
          mountedFetchers.push(key);
        }
      }
    });
    fetchersQueuedForDeletion.forEach((key) => {
      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
        unmountedFetchers.push(key);
      }
    });
    [...subscribers].forEach(
      (subscriber) => subscriber(state, {
        deletedFetchers: unmountedFetchers,
        viewTransitionOpts: opts.viewTransitionOpts,
        flushSync: opts.flushSync === true
      })
    );
    unmountedFetchers.forEach((key) => deleteFetcher(key));
    mountedFetchers.forEach((key) => state.fetchers.delete(key));
  }
  function completeNavigation(location, newState, { flushSync } = {}) {
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location.state?._isRedirect !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(
      state.loaderData,
      newState.loaderData,
      newState.matches || [],
      newState.errors
    ) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation) {
    } else if (pendingAction === "POP" /* Pop */) {
    } else if (pendingAction === "PUSH" /* Push */) {
      init.history.push(location, location.state);
    } else if (pendingAction === "REPLACE" /* Replace */) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    if (pendingAction === "POP" /* Pop */) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = /* @__PURE__ */ new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(
      {
        ...newState,
        // matches, errors, fetchers go through as-is
        actionData,
        loaderData,
        historyAction: pendingAction,
        location,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        revalidation: "idle",
        restoreScrollPosition: getSavedScrollPosition(
          location,
          newState.matches || state.matches
        ),
        preventScrollReset,
        blockers
      },
      {
        viewTransitionOpts,
        flushSync: flushSync === true
      }
    );
    pendingAction = "POP" /* Pop */;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    pendingRevalidationDfd?.resolve();
    pendingRevalidationDfd = null;
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(
      state.location,
      state.matches,
      basename,
      to,
      opts?.fromRouteId,
      opts?.relative
    );
    let { path, submission, error } = normalizeNavigateOptions(
      false,
      normalizedPath,
      opts
    );
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = {
      ...nextLocation,
      ...init.history.encodeLocation(nextLocation)
    };
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = "PUSH" /* Push */;
    if (userReplace === true) {
      historyAction = "REPLACE" /* Replace */;
    } else if (userReplace === false) {
    } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = "REPLACE" /* Replace */;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync = (opts && opts.flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({ blockers });
        }
      });
      return;
    }
    await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync
    });
  }
  function revalidate() {
    if (!pendingRevalidationDfd) {
      pendingRevalidationDfd = createDeferred();
    }
    interruptActiveLoads();
    updateState({ revalidation: "loading" });
    let promise = pendingRevalidationDfd.promise;
    if (state.navigation.state === "submitting") {
      return promise;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return promise;
    }
    startNavigation(
      pendingAction || state.historyAction,
      state.navigation.location,
      {
        overrideNavigation: state.navigation,
        // Proxy through any rending view transition
        enableViewTransition: pendingViewTransitionEnabled === true
      }
    );
    return promise;
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      let { error, notFoundMatches, route } = handleNavigational404(
        location.pathname
      );
      completeNavigation(
        location,
        {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        },
        { flushSync }
      );
      return;
    }
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, { matches }, { flushSync });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(
      init.history,
      location,
      pendingNavigationController.signal,
      opts && opts.submission
    );
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [
        findNearestBoundary(matches).route.id,
        { type: "error" /* error */, error: opts.pendingError }
      ];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(
        request,
        location,
        opts.submission,
        matches,
        fogOfWar.active,
        { replace: opts.replace, flushSync }
      );
      if (actionResult.shortCircuited) {
        return;
      }
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches = actionResult.matches || matches;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      fogOfWar.active = false;
      request = createClientSideRequest(
        init.history,
        request.url,
        request.signal
      );
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(
      request,
      location,
      matches,
      fogOfWar.active,
      loadingNavigation,
      opts && opts.submission,
      opts && opts.fetcherSubmission,
      opts && opts.replace,
      opts && opts.initialHydration === true,
      flushSync,
      pendingActionResult
    );
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, {
      matches: updatedMatches || matches,
      ...getActionDataForCommit(pendingActionResult),
      loaderData,
      errors
    });
  }
  async function handleAction(request, location, submission, matches, isFogOfWar, opts = {}) {
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({ navigation }, { flushSync: opts.flushSync === true });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        matches,
        location.pathname,
        request.signal
      );
      if (discoverResult.type === "aborted") {
        return { shortCircuited: true };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [
            boundaryId,
            {
              type: "error" /* error */,
              error: discoverResult.error
            }
          ]
        };
      } else if (!discoverResult.matches) {
        let { notFoundMatches, error, route } = handleNavigational404(
          location.pathname
        );
        return {
          matches: notFoundMatches,
          pendingActionResult: [
            route.id,
            {
              type: "error" /* error */,
              error
            }
          ]
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: "error" /* error */,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy(
        "action",
        state,
        request,
        [actionMatch],
        matches,
        null
      );
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        return { shortCircuited: true };
      }
    }
    if (isRedirectResult(result)) {
      let replace2;
      if (opts && opts.replace != null) {
        replace2 = opts.replace;
      } else {
        let location2 = normalizeRedirectLocation(
          result.response.headers.get("Location"),
          new URL(request.url),
          basename
        );
        replace2 = location2 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, true, {
        submission,
        replace: replace2
      });
      return { shortCircuited: true };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = "PUSH" /* Push */;
      }
      return {
        matches,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(
          {
            navigation: loadingNavigation,
            ...actionData !== void 0 ? { actionData } : {}
          },
          {
            flushSync
          }
        );
      }
      let discoverResult = await discoverRoutes(
        matches,
        location.pathname,
        request.signal
      );
      if (discoverResult.type === "aborted") {
        return { shortCircuited: true };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (!discoverResult.matches) {
        let { error, notFoundMatches, route } = handleNavigational404(
          location.pathname
        );
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      activeSubmission,
      location,
      initialHydration === true,
      isRevalidationRequired,
      cancelledFetcherLoads,
      fetchersQueuedForDeletion,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      pendingActionResult
    );
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(
        location,
        {
          matches,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
          ...getActionDataForCommit(pendingActionResult),
          ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
        },
        { flushSync }
      );
      return { shortCircuited: true };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== void 0) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, { flushSync });
    }
    revalidatingFetchers.forEach((rf) => {
      abortFetcher(rf.key);
      if (rf.controller) {
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
    }
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      state,
      matches,
      matchesToLoad,
      revalidatingFetchers,
      request
    );
    if (request.signal.aborted) {
      return { shortCircuited: true };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
    }
    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return { shortCircuited: true };
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return { shortCircuited: true };
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      pendingActionResult,
      revalidatingFetchers,
      fetcherResults
    );
    if (initialHydration && state.errors) {
      errors = { ...state.errors, ...errors };
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return {
      matches,
      loaderData,
      errors,
      ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
    };
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach((rf) => {
      let fetcher = state.fetchers.get(rf.key);
      let revalidatingFetcher = getLoadingFetcher(
        void 0,
        fetcher ? fetcher.data : void 0
      );
      state.fetchers.set(rf.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  async function fetch2(key, routeId, href, opts) {
    abortFetcher(key);
    let flushSync = (opts && opts.flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(
      state.location,
      state.matches,
      basename,
      href,
      routeId,
      opts?.relative
    );
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      setFetcherError(
        key,
        routeId,
        getInternalRouterError(404, { pathname: normalizedPath }),
        { flushSync }
      );
      return;
    }
    let { path, submission, error } = normalizeNavigateOptions(
      true,
      normalizedPath,
      opts
    );
    if (error) {
      setFetcherError(key, routeId, error, { flushSync });
      return;
    }
    let match = getTargetMatch(matches, path);
    let preventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      await handleFetcherAction(
        key,
        routeId,
        path,
        match,
        matches,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission
      );
      return;
    }
    fetchLoadMatches.set(key, { routeId, path });
    await handleFetcherLoader(
      key,
      routeId,
      path,
      match,
      matches,
      fogOfWar.active,
      flushSync,
      preventScrollReset,
      submission
    );
  }
  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        setFetcherError(key, routeId, error, { flushSync });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match)) {
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal,
      submission
    );
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        requestMatches,
        path,
        fetchRequest.signal
      );
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, { flushSync });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: path }),
          { flushSync }
        );
        return;
      } else {
        requestMatches = discoverResult.matches;
        match = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match)) {
          return;
        }
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy(
      "action",
      state,
      fetchRequest,
      [match],
      requestMatches,
      key
    );
    let actionResult = actionResults[match.route.id];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, false, {
            fetcherSubmission: submission,
            preventScrollReset
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(
      init.history,
      nextLocation,
      abortController.signal
    );
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      submission,
      nextLocation,
      false,
      isRevalidationRequired,
      cancelledFetcherLoads,
      fetchersQueuedForDeletion,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      [match.route.id, actionResult]
    );
    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
      let staleKey = rf.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(
        void 0,
        existingFetcher2 ? existingFetcher2.data : void 0
      );
      state.fetchers.set(staleKey, revalidatingFetcher);
      abortFetcher(staleKey);
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({ fetchers: new Map(state.fetchers) });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
    abortController.signal.addEventListener(
      "abort",
      abortPendingFetchRevalidations
    );
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      state,
      matches,
      matchesToLoad,
      revalidatingFetchers,
      revalidationRequest
    );
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener(
      "abort",
      abortPendingFetchRevalidations
    );
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      return startRedirectNavigation(
        revalidationRequest,
        redirect2.result,
        false,
        { preventScrollReset }
      );
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      return startRedirectNavigation(
        revalidationRequest,
        redirect2.result,
        false,
        { preventScrollReset }
      );
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      void 0,
      revalidatingFetchers,
      fetcherResults
    );
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(
          state.loaderData,
          loaderData,
          matches,
          errors
        ),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(
      key,
      getLoadingFetcher(
        submission,
        existingFetcher ? existingFetcher.data : void 0
      ),
      { flushSync }
    );
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal
    );
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        matches,
        path,
        fetchRequest.signal
      );
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, { flushSync });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: path }),
          { flushSync }
        );
        return;
      } else {
        matches = discoverResult.matches;
        match = getTargetMatch(matches, path);
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy(
      "loader",
      state,
      fetchRequest,
      [match],
      matches,
      key
    );
    let result = results[match.route.id];
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result, false, {
          preventScrollReset
        });
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  async function startRedirectNavigation(request, redirect2, isNavigation, {
    submission,
    fetcherSubmission,
    preventScrollReset,
    replace: replace2
  } = {}) {
    if (redirect2.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect2.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(
      location,
      new URL(request.url),
      basename
    );
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init.history.createURL(location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace2) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectNavigationType = replace2 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" /* Replace */ : "PUSH" /* Push */;
    let { formMethod, formAction, formEncType } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectNavigationType, redirectLocation, {
        submission: {
          ...activeSubmission,
          formAction: location
        },
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    } else {
      let overrideNavigation = getLoadingNavigation(
        redirectLocation,
        submission
      );
      await startNavigation(redirectNavigationType, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, state2, request, matchesToLoad, matches, fetcherKey) {
    let results;
    let dataResults = {};
    try {
      results = await callDataStrategyImpl(
        dataStrategyImpl,
        type,
        state2,
        request,
        matchesToLoad,
        matches,
        fetcherKey,
        manifest,
        mapRouteProperties2
      );
    } catch (e) {
      matchesToLoad.forEach((m) => {
        dataResults[m.route.id] = {
          type: "error" /* error */,
          error: e
        };
      });
      return dataResults;
    }
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: "redirect" /* redirect */,
          response: normalizeRelativeRoutingRedirectResponse(
            response,
            request,
            routeId,
            matches,
            basename
          )
        };
      } else {
        dataResults[routeId] = await convertDataStrategyResultToDataResult(
          result
        );
      }
    }
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {
    let loaderResultsPromise = callDataStrategy(
      "loader",
      state2,
      request,
      matchesToLoad,
      matches,
      null
    );
    let fetcherResultsPromise = Promise.all(
      fetchersToLoad.map(async (f) => {
        if (f.matches && f.match && f.controller) {
          let results = await callDataStrategy(
            "loader",
            state2,
            createClientSideRequest(init.history, f.path, f.controller.signal),
            [f.match],
            f.matches,
            f.key
          );
          let result = results[f.match.route.id];
          return { [f.key]: result };
        } else {
          return Promise.resolve({
            [f.key]: {
              type: "error" /* error */,
              error: getInternalRouterError(404, {
                pathname: f.path
              })
            }
          });
        }
      })
    );
    let loaderResults = await loaderResultsPromise;
    let fetcherResults = (await fetcherResultsPromise).reduce(
      (acc, r) => Object.assign(acc, r),
      {}
    );
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.add(key);
      }
      abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts = {}) {
    state.fetchers.set(key, fetcher);
    updateState(
      { fetchers: new Map(state.fetchers) },
      { flushSync: (opts && opts.flushSync) === true }
    );
  }
  function setFetcherError(key, routeId, error, opts = {}) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState(
      {
        errors: {
          [boundaryMatch.route.id]: error
        },
        fetchers: new Map(state.fetchers)
      },
      { flushSync: (opts && opts.flushSync) === true }
    );
  }
  function getFetcher(key) {
    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
    if (fetchersQueuedForDeletion.has(key)) {
      fetchersQueuedForDeletion.delete(key);
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    fetchersQueuedForDeletion.delete(key);
    cancelledFetcherLoads.delete(key);
    state.fetchers.delete(key);
  }
  function queueFetcherForDeletion(key) {
    let count = (activeFetchers.get(key) || 0) - 1;
    if (count <= 0) {
      activeFetchers.delete(key);
      fetchersQueuedForDeletion.add(key);
    } else {
      activeFetchers.set(key, count);
    }
    updateState({ fetchers: new Map(state.fetchers) });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    if (controller) {
      controller.abort();
      fetchControllers.delete(key);
    }
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, `Expected fetcher: ${key}`);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(
      blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
    );
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({ blockers });
  }
  function shouldBlockNavigation({
    currentLocation,
    nextLocation,
    historyAction
  }) {
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, { pathname });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let { matches, route } = getShortCircuitMatches(routesToUse);
    return { notFoundMatches: matches, route, error };
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions2 = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey2 = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({ restoreScrollPosition: y });
      }
    }
    return () => {
      savedScrollPositions2 = null;
      getScrollPosition = null;
      getScrollRestorationKey2 = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey2) {
      let key = getScrollRestorationKey2(
        location,
        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
      );
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions2[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions2) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions2[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (patchRoutesOnNavigationImpl) {
      if (!matches) {
        let fogMatches = matchRoutesImpl(
          routesToUse,
          pathname,
          basename,
          true
        );
        return { active: true, matches: fogMatches || [] };
      } else {
        if (Object.keys(matches[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename,
            true
          );
          return { active: true, matches: partialMatches };
        }
      }
    }
    return { active: false, matches: null };
  }
  async function discoverRoutes(matches, pathname, signal) {
    if (!patchRoutesOnNavigationImpl) {
      return { type: "success", matches };
    }
    let partialMatches = matches;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let localManifest = manifest;
      try {
        await patchRoutesOnNavigationImpl({
          path: pathname,
          matches: partialMatches,
          patch: (routeId, children) => {
            if (signal.aborted) return;
            patchRoutesImpl(
              routeId,
              children,
              routesToUse,
              localManifest,
              mapRouteProperties2
            );
          }
        });
      } catch (e) {
        return { type: "error", error: e, partialMatches };
      } finally {
        if (isNonHMR && !signal.aborted) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return { type: "aborted" };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches) {
        return { type: "success", matches: newMatches };
      }
      let newPartialMatches = matchRoutesImpl(
        routesToUse,
        pathname,
        basename,
        true
      );
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
        (m, i) => m.route.id === newPartialMatches[i].route.id
      )) {
        return { type: "success", matches: null };
      }
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(
      newRoutes,
      mapRouteProperties2,
      void 0,
      manifest
    );
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(
      routeId,
      children,
      routesToUse,
      manifest,
      mapRouteProperties2
    );
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    encodeLocation: (to) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: queueFetcherForDeletion,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
function createStaticHandler(routes, opts) {
  invariant(
    routes.length > 0,
    "You must provide a non-empty routes array to createStaticHandler"
  );
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;
  let dataRoutes = convertRoutesToDataRoutes(
    routes,
    mapRouteProperties2,
    void 0,
    manifest
  );
  async function query(request, {
    requestContext,
    skipLoaderErrorBubbling,
    dataStrategy
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, { method });
      let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, { pathname: location.pathname });
      let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    let result = await queryImpl(
      request,
      location,
      matches,
      requestContext,
      dataStrategy || null,
      skipLoaderErrorBubbling === true,
      null
    );
    if (isResponse(result)) {
      return result;
    }
    return { location, basename, ...result };
  }
  async function queryRoute(request, {
    routeId,
    requestContext,
    dataStrategy
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, { method });
    } else if (!matches) {
      throw getInternalRouterError(404, { pathname: location.pathname });
    }
    let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      throw getInternalRouterError(404, { pathname: location.pathname });
    }
    let result = await queryImpl(
      request,
      location,
      matches,
      requestContext,
      dataStrategy || null,
      false,
      match
    );
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : void 0;
    if (error !== void 0) {
      throw error;
    }
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      return Object.values(result.loaderData)[0];
    }
    return void 0;
  }
  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {
    invariant(
      request.signal,
      "query()/queryRoute() requests must contain an AbortController signal"
    );
    try {
      if (isMutationMethod(request.method)) {
        let result2 = await submit(
          request,
          matches,
          routeMatch || getTargetMatch(matches, location),
          requestContext,
          dataStrategy,
          skipLoaderErrorBubbling,
          routeMatch != null
        );
        return result2;
      }
      let result = await loadRouteData(
        request,
        matches,
        requestContext,
        dataStrategy,
        skipLoaderErrorBubbling,
        routeMatch
      );
      return isResponse(result) ? result : {
        ...result,
        actionData: null,
        actionHeaders: {}
      };
    } catch (e) {
      if (isDataStrategyResult(e) && isResponse(e.result)) {
        if (e.type === "error" /* error */) {
          throw e.result;
        }
        return e.result;
      }
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: "error" /* error */,
        error
      };
    } else {
      let results = await callDataStrategy(
        "action",
        request,
        [actionMatch],
        matches,
        isRouteRequest,
        requestContext,
        dataStrategy
      );
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest);
      }
    }
    if (isRedirectResult(result)) {
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    }
    if (isRouteRequest) {
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: { [actionMatch.route.id]: result.data },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    if (isErrorResult(result)) {
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
      let context2 = await loadRouteData(
        loaderRequest,
        matches,
        requestContext,
        dataStrategy,
        skipLoaderErrorBubbling,
        null,
        [boundaryMatch.route.id, result]
      );
      return {
        ...context2,
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: {
          ...result.headers ? { [actionMatch.route.id]: result.headers } : {}
        }
      };
    }
    let context = await loadRouteData(
      loaderRequest,
      matches,
      requestContext,
      dataStrategy,
      skipLoaderErrorBubbling,
      null
    );
    return {
      ...context,
      actionData: {
        [actionMatch.route.id]: result.data
      },
      // action status codes take precedence over loader status codes
      ...result.statusCode ? { statusCode: result.statusCode } : {},
      actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}
    };
  }
  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
    let isRouteRequest = routeMatch != null;
    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch?.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;
    let matchesToLoad = requestMatches.filter(
      (m) => m.route.loader || m.route.lazy
    );
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce(
          (acc, m) => Object.assign(acc, { [m.route.id]: null }),
          {}
        ),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {}
      };
    }
    let results = await callDataStrategy(
      "loader",
      request,
      matchesToLoad,
      matches,
      isRouteRequest,
      requestContext,
      dataStrategy
    );
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest);
    }
    let context = processRouteLoaderData(
      matches,
      results,
      pendingActionResult,
      true,
      skipLoaderErrorBubbling
    );
    let executedLoaders = new Set(
      matchesToLoad.map((match) => match.route.id)
    );
    matches.forEach((match) => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return {
      ...context,
      matches
    };
  }
  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {
    let results = await callDataStrategyImpl(
      dataStrategy || defaultDataStrategy,
      type,
      null,
      request,
      matchesToLoad,
      matches,
      null,
      manifest,
      mapRouteProperties2,
      requestContext
    );
    let dataResults = {};
    await Promise.all(
      matches.map(async (match) => {
        if (!(match.route.id in results)) {
          return;
        }
        let result = results[match.route.id];
        if (isRedirectDataStrategyResult(result)) {
          let response = result.result;
          throw normalizeRelativeRoutingRedirectResponse(
            response,
            request,
            match.route.id,
            matches,
            basename
          );
        }
        if (isResponse(result.result) && isRouteRequest) {
          throw result;
        }
        dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
      })
    );
    return dataResults;
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
function getStaticContextFromError(routes, context, error) {
  let newContext = {
    ...context,
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  };
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest) {
  if (request.signal.reason !== void 0) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(
    `${method}() call aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
  );
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches, basename, to, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(
    to ? to : ".",
    getResolveToMatches(contextualMatches),
    stripBasename(location.pathname, basename) || location.pathname,
    relative === "path"
  );
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return { path };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, { method: opts.formMethod })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, { type: "invalid-body" })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = rawFormMethod.toUpperCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce(
          (acc, [name, value]) => `${acc}${name}=${value}
`,
          ""
        )
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(
    typeof FormData === "function",
    "FormData is not available in this environment"
  );
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return { path, submission };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = `?${searchParams}`;
  return { path: createPath(parsedPath), submission };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary = false) {
  let index = matches.findIndex((m) => m.route.id === boundaryId);
  if (index >= 0) {
    return matches.slice(0, includeBoundary ? index + 1 : index);
  }
  return matches;
}
function getMatchesToLoad(history, state, matches, submission, location, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryMatches = matches;
  if (initialHydration && state.errors) {
    boundaryMatches = getLoaderMatchesUntilBoundary(
      matches,
      Object.keys(state.errors)[0],
      true
    );
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    boundaryMatches = getLoaderMatchesUntilBoundary(
      matches,
      pendingActionResult[0]
    );
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let { route } = match;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (initialHydration) {
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    }
    if (isNewLoader(state.loaderData, state.matches[index], match)) {
      return true;
    }
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, {
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params,
      ...submission,
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    });
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.has(key)) {
      cancelledFetcherLoads.delete(key);
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params,
        ...submission,
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      });
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy) {
    return true;
  }
  if (!route.loader) {
    return false;
  }
  let hasData = loaderData != null && loaderData[route.id] !== void 0;
  let hasError = errors != null && errors[route.id] !== void 0;
  if (!hasData && hasError) {
    return false;
  }
  if (typeof route.loader === "function" && route.loader.hydrate === true) {
    return true;
  }
  return !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id
  );
  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(
      route,
      `No route found to patch children into: routeId = ${routeId}`
    );
    if (!route.children) {
      route.children = [];
    }
    childrenToPatch = route.children;
  } else {
    childrenToPatch = routesToUse;
  }
  let uniqueChildren = children.filter(
    (newRoute) => !childrenToPatch.some(
      (existingRoute) => isSameRoute(newRoute, existingRoute)
    )
  );
  let newRoutes = convertRoutesToDataRoutes(
    uniqueChildren,
    mapRouteProperties2,
    [routeId || "_", "patch", String(childrenToPatch?.length || "0")],
    manifest
  );
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
    return true;
  }
  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
    return false;
  }
  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
    return true;
  }
  return newRoute.children.every(
    (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))
  );
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(
      !isPropertyStaticallyDefined,
      `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
    );
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, {
    // To keep things framework agnostic, we use the provided `mapRouteProperties`
    // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
    // since the logic will differ between frameworks.
    ...mapRouteProperties2(routeToUpdate),
    lazy: void 0
  });
}
async function defaultDataStrategy({
  matches
}) {
  let matchesToLoad = matches.filter((m) => m.shouldLoad);
  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
  return results.reduce(
    (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),
    {}
  );
}
async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {
  let loadRouteDefinitionsPromises = matches.map(
    (m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0
  );
  let dsMatches = matches.map((match, i) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i];
    let shouldLoad = matchesToLoad.some((m) => m.route.id === match.route.id);
    let resolve = async (handlerOverride) => {
      if (handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
        shouldLoad = true;
      }
      return shouldLoad ? callLoaderOrAction(
        type,
        request,
        match,
        loadRoutePromise,
        handlerOverride,
        requestContext
      ) : Promise.resolve({ type: "data" /* data */, result: void 0 });
    };
    return {
      ...match,
      shouldLoad,
      resolve
    };
  });
  let results = await dataStrategyImpl({
    matches: dsMatches,
    request,
    params: matches[0].params,
    fetcherKey,
    context: requestContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch (e) {
  }
  return results;
}
async function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = (ctx) => {
      if (typeof handler !== "function") {
        return Promise.reject(
          new Error(
            `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match.route.id}]`
          )
        );
      }
      return handler(
        {
          request,
          params: match.params,
          context: staticContext
        },
        ...ctx !== void 0 ? [ctx] : []
      );
    };
    let handlerPromise = (async () => {
      try {
        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
        return { type: "data", result: val };
      } catch (e) {
        return { type: "error", result: e };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (loadRoutePromise) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e) => {
            handlerError = e;
          }),
          loadRoutePromise
        ]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadRoutePromise;
        handler = match.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          return { type: "data" /* data */, result: void 0 };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
  } catch (e) {
    return { type: "error" /* error */, result: e };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let { result, type } = dataStrategyResult;
  if (isResponse(result)) {
    let data2;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data2 = null;
        } else {
          data2 = await result.json();
        }
      } else {
        data2 = await result.text();
      }
    } catch (e) {
      return { type: "error" /* error */, error: e };
    }
    if (type === "error" /* error */) {
      return {
        type: "error" /* error */,
        error: new ErrorResponseImpl(result.status, result.statusText, data2),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: "data" /* data */,
      data: data2,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === "error" /* error */) {
    if (isDataWithResponseInit(result)) {
      if (result.data instanceof Error) {
        return {
          type: "error" /* error */,
          error: result.data,
          statusCode: result.init?.status
        };
      }
      result = new ErrorResponseImpl(
        result.init?.status || 500,
        void 0,
        result.data
      );
    }
    return {
      type: "error" /* error */,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDataWithResponseInit(result)) {
    return {
      type: "data" /* data */,
      data: result.data,
      statusCode: result.init?.status,
      headers: result.init?.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return { type: "data" /* data */, data: result };
}
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {
  let location = response.headers.get("Location");
  invariant(
    location,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  );
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches.slice(
      0,
      matches.findIndex((m) => m.route.id === routeId) + 1
    );
    location = normalizeTo(
      new URL(request.url),
      trimmedMatches,
      basename,
      location
    );
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = { signal };
  if (submission && isMutationMethod(submission.formMethod)) {
    let { formMethod, formEncType } = submission;
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({ "Content-Type": formEncType });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  matches.forEach((match) => {
    if (!(match.route.id in results)) {
      return;
    }
    let id = match.route.id;
    let result = results[id];
    invariant(
      !isRedirectResult(result),
      "Cannot handle redirect results in processLoaderData"
    );
    if (isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0) {
        error = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id] = error;
      } else {
        let boundaryMatch = findNearestBoundary(matches, id);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      if (!isStaticHandler) {
        loaderData[id] = ResetLoaderDataSymbol;
      }
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      loaderData[id] = result.data;
      if (result.statusCode && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = { [pendingActionResult[0]]: pendingError };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
  let { loaderData, errors } = processRouteLoaderData(
    matches,
    results,
    pendingActionResult
  );
  revalidatingFetchers.forEach((rf) => {
    let { key, match, controller } = rf;
    let result = fetcherResults[key];
    invariant(result, "Did not find corresponding fetcher result");
    if (controller && controller.signal.aborted) {
      return;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = {
          ...errors,
          [boundaryMatch.route.id]: result.error
        };
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  });
  return { loaderData, errors };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
    merged[k] = v;
    return merged;
  }, {});
  for (let match of matches) {
    let id = match.route.id;
    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === "/") || {
    id: `__shim-error-route__`
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route
      }
    ],
    route
  };
}
function getInternalRouterError(status, {
  pathname,
  routeId,
  method,
  type,
  message
} = {}) {
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = `No route matches URL "${pathname}"`;
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (method) {
      errorMessage = `Invalid request method "${method.toUpperCase()}"`;
    }
  }
  return new ErrorResponseImpl(
    status || 500,
    statusText,
    new Error(errorMessage),
    true
  );
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i = entries.length - 1; i >= 0; i--) {
    let [key, result] = entries[i];
    if (isRedirectResult(result)) {
      return { key, result };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath({ ...parsedPath, hash: "" });
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    return true;
  } else if (b.hash !== "") {
    return true;
  }
  return false;
}
function isDataStrategyResult(result) {
  return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === "data" /* data */ || result.type === "error" /* error */);
}
function isRedirectDataStrategyResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isErrorResult(result) {
  return result.type === "error" /* error */;
}
function isRedirectResult(result) {
  return (result && result.type) === "redirect" /* redirect */;
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectStatusCode(statusCode) {
  return redirectStatusCodes.has(statusCode);
}
function isRedirectResponse(result) {
  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has("Location");
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toUpperCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toUpperCase());
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v) => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let { formMethod, formAction, formEncType, text, formData, json } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data2) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: data2
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
function getDoneFetcher(data2) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data2
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(
      TRANSITIONS_STORAGE_KEY
    );
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(
        TRANSITIONS_STORAGE_KEY,
        JSON.stringify(json)
      );
    } catch (error) {
      warning(
        false,
        `Failed to save applied view transitions in sessionStorage (${error}).`
      );
    }
  }
}
function createDeferred() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async (val) => {
      res(val);
      try {
        await promise;
      } catch (e) {
      }
    };
    reject = async (error) => {
      rej(error);
      try {
        await promise;
      } catch (e) {
      }
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/components.tsx


// lib/context.ts

var DataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
RouteErrorContext.displayName = "RouteError";

// lib/hooks.tsx

var ENABLE_DEV_WARNINGS = true;
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;
}
function useNavigationType() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;
}
function useMatch(pattern) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useMatch() may be used only in the context of a <Router> component.`
  );
  let { pathname } = useLocation();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matchPath(pattern, decodePath(pathname)),
    [pathname, pattern]
  );
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;
  if (!isStatic) {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
var OutletContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
function useOutletContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, { value: context }, outlet);
  }
  return outlet;
}
function useParams() {
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, { relative } = {}) {
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2 } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (ENABLE_DEV_WARNINGS) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  if (ENABLE_DEV_WARNINGS) {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP" /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  if (ENABLE_DEV_WARNINGS) {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "React Router caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && errors?.[m.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce(
            "route-fallback",
            false,
            "No `HydrateFallback` element provided to render during initial hydration"
          );
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        RenderedRoute,
        {
          match,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        }
      );
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      RenderErrorBoundary,
      {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: { outlet: null, matches: matches2, isDataRoute: true }
      }
    ) : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId("useRouteId" /* UseRouteId */);
}
function useNavigation() {
  let state = useDataRouterState("useNavigation" /* UseNavigation */);
  return state.navigation;
}
function useRevalidator() {
  let dataRouterContext = useDataRouterContext("useRevalidator" /* UseRevalidator */);
  let state = useDataRouterState("useRevalidator" /* UseRevalidator */);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      async revalidate() {
        await dataRouterContext.router.revalidate();
      },
      state: state.revalidation
    }),
    [dataRouterContext.router, state.revalidation]
  );
}
function useMatches() {
  let { matches, loaderData } = useDataRouterState(
    "useMatches" /* UseMatches */
  );
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
    [matches, loaderData]
  );
}
function useLoaderData() {
  let state = useDataRouterState("useLoaderData" /* UseLoaderData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.loaderData[routeId];
}
function useRouteLoaderData(routeId) {
  let state = useDataRouterState("useRouteLoaderData" /* UseRouteLoaderData */);
  return state.loaderData[routeId];
}
function useActionData() {
  let state = useDataRouterState("useActionData" /* UseActionData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.actionData ? state.actionData[routeId] : void 0;
}
function useRouteError() {
  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);
  let state = useDataRouterState("useRouteError" /* UseRouteError */);
  let routeId = useCurrentRouteId("useRouteError" /* UseRouteError */);
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useAsyncValue() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._data;
}
function useAsyncError() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._error;
}
var blockerId = 0;
function useBlocker(shouldBlock) {
  let { router, basename } = useDataRouterContext("useBlocker" /* UseBlocker */);
  let state = useDataRouterState("useBlocker" /* UseBlocker */);
  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (arg) => {
      if (typeof shouldBlock !== "function") {
        return !!shouldBlock;
      }
      if (basename === "/") {
        return shouldBlock(arg);
      }
      let { currentLocation, nextLocation, historyAction } = arg;
      return shouldBlock({
        currentLocation: {
          ...currentLocation,
          pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
        },
        nextLocation: {
          ...nextLocation,
          pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
        },
        historyAction
      });
    },
    [basename, shouldBlock]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}
function useNavigateStable() {
  let { router } = useDataRouterContext("useNavigate" /* UseNavigateStable */);
  let id = useCurrentRouteId("useNavigate" /* UseNavigateStable */);
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}

// lib/server-runtime/warnings.ts
var alreadyWarned2 = {};
function warnOnce(condition, message) {
  if (!condition && !alreadyWarned2[message]) {
    alreadyWarned2[message] = true;
    console.warn(message);
  }
}

// lib/components.tsx
var ENABLE_DEV_WARNINGS2 = true;
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.element) {
        warning(
          false,
          "You should not include both `Component` and `element` on your route - `Component` will be used."
        );
      }
    }
    Object.assign(updates, {
      element: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.hydrateFallbackElement) {
        warning(
          false,
          "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
        );
      }
    }
    Object.assign(updates, {
      hydrateFallbackElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.errorElement) {
        warning(
          false,
          "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
        );
      }
    }
    Object.assign(updates, {
      errorElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createMemoryHistory({
      initialEntries: opts?.initialEntries,
      initialIndex: opts?.initialIndex
    }),
    hydrationData: opts?.hydrationData,
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation
  }).initialize();
}
var Deferred = class {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = (reason) => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
};
function RouterProvider({
  router,
  flushSync: reactDomFlushSyncImpl
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);
  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map());
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
      newState.fetchers.forEach((fetcher, key) => {
        if (fetcher.data !== void 0) {
          fetcherData.current.set(key, fetcher.data);
        }
      });
      deletedFetchers.forEach((key) => fetcherData.current.delete(key));
      warnOnce(
        flushSync === false || reactDomFlushSyncImpl != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === "function";
      warnOnce(
        viewTransitionOpts == null || isViewTransitionAvailable,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      );
      if (!viewTransitionOpts || !isViewTransitionAvailable) {
        if (reactDomFlushSyncImpl && flushSync) {
          reactDomFlushSyncImpl(() => setStateImpl(newState));
        } else {
          react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
        }
        return;
      }
      if (reactDomFlushSyncImpl && flushSync) {
        reactDomFlushSyncImpl(() => {
          if (transition) {
            renderDfd && renderDfd.resolve();
            transition.skipTransition();
          }
          setVtContext({
            isTransitioning: true,
            flushSync: true,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        });
        let t = router.window.document.startViewTransition(() => {
          reactDomFlushSyncImpl(() => setStateImpl(newState));
        });
        t.finished.finally(() => {
          reactDomFlushSyncImpl(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({ isTransitioning: false });
          });
        });
        reactDomFlushSyncImpl(() => setTransition(t));
        return;
      }
      if (transition) {
        renderDfd && renderDfd.resolve();
        transition.skipTransition();
        setInterruption({
          state: newState,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      } else {
        setPendingState(newState);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      }
    },
    [router.window, reactDomFlushSyncImpl, transition, renderDfd]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router.window.document.startViewTransition(async () => {
        react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({ isTransitioning: false });
      });
      setTransition(transition2);
    }
  }, [pendingState, renderDfd, router.window]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  let navigator2 = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: (n) => router.navigate(n),
      push: (to, state2, opts) => router.navigate(to, {
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      }),
      replace: (to, state2, opts) => router.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      router,
      navigator: navigator2,
      static: false,
      basename
    }),
    [router, navigator2, basename]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: navigator2
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      MemoizedDataRoutes,
      {
        routes: router.routes,
        future: router.future,
        state
      }
    )
  ))))), null);
}
var MemoizedDataRoutes = react__WEBPACK_IMPORTED_MODULE_0__.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function MemoryRouter({
  basename,
  children,
  initialEntries,
  initialIndex
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function Navigate({
  to,
  replace: replace2,
  state,
  relative
}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    `<Navigate> may be used only in the context of a <Router> component.`
  );
  let { static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  warning(
    !isStatic,
    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
  );
  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(
    to,
    getResolveToMatches(matches),
    locationPathname,
    relative === "path"
  );
  let jsonPath = JSON.stringify(path);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
  }, [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP" /* Pop */,
  navigator: navigator2,
  static: staticProp = false
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: {}
    }),
    [basename, navigator2, staticProp]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function Await({
  children,
  errorElement,
  resolve
}) {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, { resolve, errorElement }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));
}
var AwaitErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "<Await> caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    let { children, errorElement, resolve } = this.props;
    let promise = null;
    let status = 0 /* pending */;
    if (!(resolve instanceof Promise)) {
      status = 1 /* success */;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_data", { get: () => resolve });
    } else if (this.state.error) {
      status = 2 /* error */;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {
      });
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_error", { get: () => renderError });
    } else if (resolve._tracked) {
      promise = resolve;
      status = "_error" in promise ? 2 /* error */ : "_data" in promise ? 1 /* success */ : 0 /* pending */;
    } else {
      status = 0 /* pending */;
      Object.defineProperty(resolve, "_tracked", { get: () => true });
      promise = resolve.then(
        (data2) => Object.defineProperty(resolve, "_data", { get: () => data2 }),
        (error) => Object.defineProperty(resolve, "_error", { get: () => error })
      );
    }
    if (status === 2 /* error */ && !errorElement) {
      throw promise._error;
    }
    if (status === 2 /* error */) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children: errorElement });
    }
    if (status === 1 /* success */) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children });
    }
    throw promise;
  }
};
function ResolveAwait({
  children
}) {
  let data2 = useAsyncValue();
  let toRender = typeof children === "function" ? children(data2) : children;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {
    if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var createRoutesFromElements = createRoutesFromChildren;
function renderMatches(matches) {
  return _renderMatches(matches);
}

// lib/dom/lib.tsx


// lib/dom/dom.ts
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init = "") {
  return new URLSearchParams(
    typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
      let value = init[key];
      return memo2.concat(
        Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]
      );
    }, [])
  );
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}

// lib/dom/ssr/components.tsx


// lib/dom/ssr/invariant.ts
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// lib/dom/ssr/routeModules.ts
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    /* unsupported import.meta.hot */ undefined) {}
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// lib/dom/ssr/links.ts
function getKeyedLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    let module = routeModules[match.route.id];
    let route = manifest.routes[match.route.id];
    return [
      route && route.css ? route.css.map((href) => ({ rel: "stylesheet", href })) : [],
      module?.links?.() || []
    ];
  }).flat(2);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupeLinkDescriptors(descriptors, preloads);
}
async function prefetchStyleLinks(route, routeModule) {
  if (!route.css && !routeModule.links || !isPreloadSupported()) return;
  let descriptors = [];
  if (route.css) {
    descriptors.push(...route.css.map((href) => ({ rel: "stylesheet", href })));
  }
  if (routeModule.links) {
    descriptors.push(...routeModule.links());
  }
  if (descriptors.length === 0) return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push({
        ...descriptor,
        rel: "preload",
        as: "style"
      });
    }
  }
  let matchingLinks = styleLinks.filter(
    (link) => (!link.media || window.matchMedia(link.media).matches) && !document.querySelector(`link[rel="stylesheet"][href="${link.href}"]`)
  );
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifestPatch.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
var _isPreloadSupported;
function isPreloadSupported() {
  if (_isPreloadSupported !== void 0) {
    return _isPreloadSupported;
  }
  let el = document.createElement("link");
  _isPreloadSupported = el.relList.supports("preload");
  el = null;
  return _isPreloadSupported;
}

// lib/dom/ssr/markup.ts
var ESCAPE_LOOKUP = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
function createHtml(html) {
  return { __html: html };
}

// lib/dom/ssr/single-fetch.tsx



// lib/dom/ssr/data.ts
async function createRequestInit(request) {
  let init = { signal: request.signal };
  if (request.method !== "GET") {
    init.method = request.method;
    let contentType = request.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      init.headers = { "Content-Type": contentType };
      init.body = JSON.stringify(await request.json());
    } else if (contentType && /\btext\/plain\b/.test(contentType)) {
      init.headers = { "Content-Type": contentType };
      init.body = await request.text();
    } else if (contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType)) {
      init.body = new URLSearchParams(await request.text());
    } else {
      init.body = await request.formData();
    }
  }
  return init;
}

// lib/dom/ssr/single-fetch.tsx
var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
function StreamTransfer({
  context,
  identifier,
  reader,
  textDecoder,
  nonce
}) {
  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {
    return null;
  }
  if (!context.renderMeta.streamCache) {
    context.renderMeta.streamCache = {};
  }
  let { streamCache } = context.renderMeta;
  let promise = streamCache[identifier];
  if (!promise) {
    promise = streamCache[identifier] = reader.read().then((result) => {
      streamCache[identifier].result = {
        done: result.done,
        value: textDecoder.decode(result.value, { stream: true })
      };
    }).catch((e) => {
      streamCache[identifier].error = e;
    });
  }
  if (promise.error) {
    throw promise.error;
  }
  if (promise.result === void 0) {
    throw promise;
  }
  let { done, value } = promise.result;
  let scriptTag = value ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      nonce,
      dangerouslySetInnerHTML: {
        __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(
          JSON.stringify(value)
        )});`
      }
    }
  ) : null;
  if (done) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        nonce,
        dangerouslySetInnerHTML: {
          __html: `window.__reactRouterContext.streamController.close();`
        }
      }
    ));
  } else {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      StreamTransfer,
      {
        context,
        identifier: identifier + 1,
        reader,
        textDecoder,
        nonce
      }
    )));
  }
}
function getSingleFetchDataStrategy(manifest, routeModules, getRouter) {
  return async ({ request, matches, fetcherKey }) => {
    if (request.method !== "GET") {
      return singleFetchActionStrategy(request, matches);
    }
    if (fetcherKey) {
      return singleFetchLoaderFetcherStrategy(request, matches);
    }
    return singleFetchLoaderNavigationStrategy(
      manifest,
      routeModules,
      getRouter(),
      request,
      matches
    );
  };
}
async function singleFetchActionStrategy(request, matches) {
  let actionMatch = matches.find((m) => m.shouldLoad);
  invariant2(actionMatch, "No action match found");
  let actionStatus = void 0;
  let result = await actionMatch.resolve(async (handler) => {
    let result2 = await handler(async () => {
      let url = singleFetchUrl(request.url);
      let init = await createRequestInit(request);
      let { data: data2, status } = await fetchAndDecode(url, init);
      actionStatus = status;
      return unwrapSingleFetchResult(
        data2,
        actionMatch.route.id
      );
    });
    return result2;
  });
  if (isResponse(result.result) || isRouteErrorResponse(result.result)) {
    return { [actionMatch.route.id]: result };
  }
  return {
    [actionMatch.route.id]: {
      type: result.type,
      result: data(result.result, actionStatus)
    }
  };
}
async function singleFetchLoaderNavigationStrategy(manifest, routeModules, router, request, matches) {
  let routesParams = /* @__PURE__ */ new Set();
  let foundOptOutRoute = false;
  let routeDfds = matches.map(() => createDeferred2());
  let routesLoadedPromise = Promise.all(routeDfds.map((d) => d.promise));
  let singleFetchDfd = createDeferred2();
  let url = stripIndexParam(singleFetchUrl(request.url));
  let init = await createRequestInit(request);
  let results = {};
  let resolvePromise = Promise.all(
    matches.map(
      async (m, i) => m.resolve(async (handler) => {
        routeDfds[i].resolve();
        let manifestRoute = manifest.routes[m.route.id];
        if (!m.shouldLoad) {
          if (!router.state.initialized) {
            return;
          }
          if (m.route.id in router.state.loaderData && manifestRoute && manifestRoute.hasLoader && routeModules[m.route.id]?.shouldRevalidate) {
            foundOptOutRoute = true;
            return;
          }
        }
        if (manifestRoute && manifestRoute.hasClientLoader) {
          if (manifestRoute.hasLoader) {
            foundOptOutRoute = true;
          }
          try {
            let result = await fetchSingleLoader(
              handler,
              url,
              init,
              m.route.id
            );
            results[m.route.id] = { type: "data", result };
          } catch (e) {
            results[m.route.id] = { type: "error", result: e };
          }
          return;
        }
        if (manifestRoute && manifestRoute.hasLoader) {
          routesParams.add(m.route.id);
        }
        try {
          let result = await handler(async () => {
            let data2 = await singleFetchDfd.promise;
            return unwrapSingleFetchResults(data2, m.route.id);
          });
          results[m.route.id] = {
            type: "data",
            result
          };
        } catch (e) {
          results[m.route.id] = {
            type: "error",
            result: e
          };
        }
      })
    )
  );
  await routesLoadedPromise;
  if ((!router.state.initialized || routesParams.size === 0) && !window.__reactRouterHdrActive) {
    singleFetchDfd.resolve({});
  } else {
    try {
      if (foundOptOutRoute && routesParams.size > 0) {
        url.searchParams.set(
          "_routes",
          matches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
        );
      }
      let data2 = await fetchAndDecode(url, init);
      singleFetchDfd.resolve(data2.data);
    } catch (e) {
      singleFetchDfd.reject(e);
    }
  }
  await resolvePromise;
  return results;
}
async function singleFetchLoaderFetcherStrategy(request, matches) {
  let fetcherMatch = matches.find((m) => m.shouldLoad);
  invariant2(fetcherMatch, "No fetcher match found");
  let result = await fetcherMatch.resolve(async (handler) => {
    let url = stripIndexParam(singleFetchUrl(request.url));
    let init = await createRequestInit(request);
    return fetchSingleLoader(handler, url, init, fetcherMatch.route.id);
  });
  return { [fetcherMatch.route.id]: result };
}
function fetchSingleLoader(handler, url, init, routeId) {
  return handler(async () => {
    let singleLoaderUrl = new URL(url);
    singleLoaderUrl.searchParams.set("_routes", routeId);
    let { data: data2 } = await fetchAndDecode(singleLoaderUrl, init);
    return unwrapSingleFetchResults(data2, routeId);
  });
}
function stripIndexParam(url) {
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return url;
}
function singleFetchUrl(reqUrl) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}
async function fetchAndDecode(url, init) {
  let res = await fetch(url, init);
  if (res.status === 404 && !res.headers.has("X-Remix-Response")) {
    throw new ErrorResponseImpl(404, "Not Found", true);
  }
  invariant2(res.body, "No response body to decode");
  try {
    let decoded = await decodeViaTurboStream(res.body, window);
    return { status: res.status, data: decoded.value };
  } catch (e) {
    throw new Error("Unable to decode turbo-stream response");
  }
}
function decodeViaTurboStream(body, global2) {
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.decode)(body, {
    plugins: [
      (type, ...rest) => {
        if (type === "SanitizedError") {
          let [name, message, stack] = rest;
          let Constructor = Error;
          if (name && name in global2 && typeof global2[name] === "function") {
            Constructor = global2[name];
          }
          let error = new Constructor(message);
          error.stack = stack;
          return { value: error };
        }
        if (type === "ErrorResponse") {
          let [data2, status, statusText] = rest;
          return {
            value: new ErrorResponseImpl(status, statusText, data2)
          };
        }
        if (type === "SingleFetchRedirect") {
          return { value: { [SingleFetchRedirectSymbol]: rest[0] } };
        }
        if (type === "SingleFetchClassInstance") {
          return { value: rest[0] };
        }
        if (type === "SingleFetchFallback") {
          return { value: void 0 };
        }
      }
    ]
  });
}
function unwrapSingleFetchResults(results, routeId) {
  let redirect2 = results[SingleFetchRedirectSymbol];
  if (redirect2) {
    return unwrapSingleFetchResult(redirect2, routeId);
  }
  return results[routeId] !== void 0 ? unwrapSingleFetchResult(results[routeId], routeId) : null;
}
function unwrapSingleFetchResult(result, routeId) {
  if ("error" in result) {
    throw result.error;
  } else if ("redirect" in result) {
    let headers = {};
    if (result.revalidate) {
      headers["X-Remix-Revalidate"] = "yes";
    }
    if (result.reload) {
      headers["X-Remix-Reload-Document"] = "yes";
    }
    if (result.replace) {
      headers["X-Remix-Replace"] = "yes";
    }
    throw redirect(result.redirect, { status: result.status, headers });
  } else if ("data" in result) {
    return result.data;
  } else {
    throw new Error(`No response found for routeId "${routeId}"`);
  }
}
function createDeferred2() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async (val) => {
      res(val);
      try {
        await promise;
      } catch (e) {
      }
    };
    reject = async (error) => {
      rej(error);
      try {
        await promise;
      } catch (e) {
      }
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/dom/ssr/fog-of-war.ts


// lib/dom/ssr/routes.tsx


// lib/dom/ssr/errorBoundaries.tsx

var RemixErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = { error: props.error || null, location: props.location };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return { error: props.error || null, location: props.location };
    }
    return { error: props.error || state.error, location: state.location };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        RemixRootDefaultErrorBoundary,
        {
          error: this.state.error,
          isOutsideRemixApp: true
        }
      );
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error,
  isOutsideRemixApp
}) {
  console.error(error);
  let heyDeveloper = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
        );
      `
      }
    }
  );
  if (isRouteErrorResponse(error)) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: "Unhandled Thrown Response!" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", { style: { fontSize: "24px" } }, error.status, " ", error.statusText), heyDeveloper);
  }
  let errorInstance;
  if (error instanceof Error) {
    errorInstance = error;
  } else {
    let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
    errorInstance = new Error(errorString);
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    BoundaryShell,
    {
      title: "Application Error!",
      isOutsideRemixApp
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "pre",
      {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      },
      errorInstance.stack
    ),
    heyDeveloper
  );
}
function BoundaryShell({
  title,
  renderScripts,
  isOutsideRemixApp,
  children
}) {
  let { routeModules } = useFrameworkContext();
  if (routeModules.root?.Layout && !isOutsideRemixApp) {
    return children;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("html", { lang: "en" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("head", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", null, title)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("body", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, children, renderScripts ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Scripts, null) : null)));
}

// lib/dom/ssr/fallback.tsx

function RemixRootDefaultHydrateFallback() {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: "Loading...", renderScripts: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
              console.log(
                "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://remix.run/route/hydrate-fallback " +
                "for more information."
              );
            `
      }
    }
  ));
}

// lib/dom/ssr/routes.tsx
function groupRoutesByParentId(manifest) {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function getRouteComponents(route, routeModule, isSpaMode) {
  let Component4 = getRouteModuleComponent(routeModule);
  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === "root") ? routeModule.HydrateFallback : route.id === "root" ? RemixRootDefaultHydrateFallback : void 0;
  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === "root" ? () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;
  if (route.id === "root" && routeModule.Layout) {
    return {
      ...Component4 ? {
        element: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component4, null))
      } : { Component: Component4 },
      ...ErrorBoundary ? {
        errorElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, null))
      } : { ErrorBoundary },
      ...HydrateFallback ? {
        hydrateFallbackElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HydrateFallback, null))
      } : { HydrateFallback }
    };
  }
  return { Component: Component4, ErrorBoundary, HydrateFallback };
}
function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {
  return (routesByParentId[parentId] || []).map((route) => {
    let routeModule = routeModules[route.id];
    invariant2(
      routeModule,
      "No `routeModule` available to create server routes"
    );
    let dataRoute = {
      ...getRouteComponents(route, routeModule, isSpaMode),
      caseSensitive: route.caseSensitive,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: routeModule.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0
      // We don't need action/shouldRevalidate on these routes since they're
      // for a static render
    };
    let children = createServerRoutes(
      manifest,
      routeModules,
      future,
      isSpaMode,
      route.id,
      routesByParentId,
      spaModeLazyPromise
    );
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, future, isSpaMode) {
  return createClientRoutes(
    manifest,
    routeModulesCache,
    initialState,
    isSpaMode,
    "",
    groupRoutesByParentId(manifest),
    needsRevalidation
  );
}
function preventInvalidServerHandlerCall(type, route, isSpaMode) {
  if (isSpaMode) {
    let fn2 = type === "action" ? "serverAction()" : "serverLoader()";
    let msg2 = `You cannot call ${fn2} in SPA Mode (routeId: "${route.id}")`;
    console.error(msg2);
    throw new ErrorResponseImpl(400, "Bad Request", new Error(msg2), true);
  }
  let fn = type === "action" ? "serverAction()" : "serverLoader()";
  let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: "${route.id}")`;
  if (type === "loader" && !route.hasLoader || type === "action" && !route.hasAction) {
    console.error(msg);
    throw new ErrorResponseImpl(400, "Bad Request", new Error(msg), true);
  }
}
function noActionDefinedError(type, routeId) {
  let article = type === "clientAction" ? "a" : "an";
  let msg = `Route "${routeId}" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \`${type}\` function to the route`;
  console.error(msg);
  throw new ErrorResponseImpl(405, "Method Not Allowed", new Error(msg), true);
}
function createClientRoutes(manifest, routeModulesCache, initialState, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
  return (routesByParentId[parentId] || []).map((route) => {
    let routeModule = routeModulesCache[route.id];
    function fetchServerHandler(singleFetch) {
      invariant2(
        typeof singleFetch === "function",
        "No single fetch function available for route handler"
      );
      return singleFetch();
    }
    function fetchServerLoader(singleFetch) {
      if (!route.hasLoader) return Promise.resolve(null);
      return fetchServerHandler(singleFetch);
    }
    function fetchServerAction(singleFetch) {
      if (!route.hasAction) {
        throw noActionDefinedError("action", route.id);
      }
      return fetchServerHandler(singleFetch);
    }
    async function prefetchStylesAndCallHandler(handler) {
      let cachedModule = routeModulesCache[route.id];
      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();
      try {
        return handler();
      } finally {
        await linkPrefetchPromise;
      }
    }
    let dataRoute = {
      id: route.id,
      index: route.index,
      path: route.path
    };
    if (routeModule) {
      Object.assign(dataRoute, {
        ...dataRoute,
        ...getRouteComponents(route, routeModule, isSpaMode),
        handle: routeModule.handle,
        shouldRevalidate: getShouldRevalidateFunction(
          routeModule,
          route.id,
          needsRevalidation
        )
      });
      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;
      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;
      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;
      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;
      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);
      dataRoute.loader = async ({ request, params }, singleFetch) => {
        try {
          let result = await prefetchStylesAndCallHandler(async () => {
            invariant2(
              routeModule,
              "No `routeModule` available for critical-route loader"
            );
            if (!routeModule.clientLoader) {
              if (isSpaMode) return null;
              return fetchServerLoader(singleFetch);
            }
            return routeModule.clientLoader({
              request,
              params,
              async serverLoader() {
                preventInvalidServerHandlerCall("loader", route, isSpaMode);
                if (isHydrationRequest) {
                  if (hasInitialData) {
                    return initialData;
                  }
                  if (hasInitialError) {
                    throw initialError;
                  }
                }
                return fetchServerLoader(singleFetch);
              }
            });
          });
          return result;
        } finally {
          isHydrationRequest = false;
        }
      };
      dataRoute.loader.hydrate = shouldHydrateRouteLoader(
        route,
        routeModule,
        isSpaMode
      );
      dataRoute.action = ({ request, params }, singleFetch) => {
        return prefetchStylesAndCallHandler(async () => {
          invariant2(
            routeModule,
            "No `routeModule` available for critical-route action"
          );
          if (!routeModule.clientAction) {
            if (isSpaMode) {
              throw noActionDefinedError("clientAction", route.id);
            }
            return fetchServerAction(singleFetch);
          }
          return routeModule.clientAction({
            request,
            params,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route, isSpaMode);
              return fetchServerAction(singleFetch);
            }
          });
        });
      };
    } else {
      if (!route.hasClientLoader) {
        dataRoute.loader = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {
          if (isSpaMode) return Promise.resolve(null);
          return fetchServerLoader(singleFetch);
        });
      }
      if (!route.hasClientAction) {
        dataRoute.action = ({ request }, singleFetch) => prefetchStylesAndCallHandler(() => {
          if (isSpaMode) {
            throw noActionDefinedError("clientAction", route.id);
          }
          return fetchServerAction(singleFetch);
        });
      }
      dataRoute.lazy = async () => {
        let mod = await loadRouteModuleWithBlockingLinks(
          route,
          routeModulesCache
        );
        let lazyRoute = { ...mod };
        if (mod.clientLoader) {
          let clientLoader = mod.clientLoader;
          lazyRoute.loader = (args, singleFetch) => clientLoader({
            ...args,
            async serverLoader() {
              preventInvalidServerHandlerCall("loader", route, isSpaMode);
              return fetchServerLoader(singleFetch);
            }
          });
        }
        if (mod.clientAction) {
          let clientAction = mod.clientAction;
          lazyRoute.action = (args, singleFetch) => clientAction({
            ...args,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route, isSpaMode);
              return fetchServerAction(singleFetch);
            }
          });
        }
        return {
          ...lazyRoute.loader ? { loader: lazyRoute.loader } : {},
          ...lazyRoute.action ? { action: lazyRoute.action } : {},
          hasErrorBoundary: lazyRoute.hasErrorBoundary,
          shouldRevalidate: getShouldRevalidateFunction(
            lazyRoute,
            route.id,
            needsRevalidation
          ),
          handle: lazyRoute.handle,
          // No need to wrap these in layout since the root route is never
          // loaded via route.lazy()
          Component: lazyRoute.Component,
          ErrorBoundary: lazyRoute.ErrorBoundary
        };
      };
    }
    let children = createClientRoutes(
      manifest,
      routeModulesCache,
      initialState,
      isSpaMode,
      route.id,
      routesByParentId,
      needsRevalidation
    );
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function getShouldRevalidateFunction(route, routeId, needsRevalidation) {
  if (needsRevalidation) {
    return wrapShouldRevalidateForHdr(
      routeId,
      route.shouldRevalidate,
      needsRevalidation
    );
  }
  if (route.shouldRevalidate) {
    let fn = route.shouldRevalidate;
    return (opts) => fn({ ...opts, defaultShouldRevalidate: true });
  }
  return route.shouldRevalidate;
}
function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {
  let handledRevalidation = false;
  return (arg) => {
    if (!handledRevalidation) {
      handledRevalidation = true;
      return needsRevalidation.has(routeId);
    }
    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;
  };
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(route, routeModule);
  return {
    Component: getRouteModuleComponent(routeModule),
    ErrorBoundary: routeModule.ErrorBoundary,
    clientAction: routeModule.clientAction,
    clientLoader: routeModule.clientLoader,
    handle: routeModule.handle,
    links: routeModule.links,
    meta: routeModule.meta,
    shouldRevalidate: routeModule.shouldRevalidate
  };
}
function getRouteModuleComponent(routeModule) {
  if (routeModule.default == null) return void 0;
  let isEmptyObject = typeof routeModule.default === "object" && Object.keys(routeModule.default).length === 0;
  if (!isEmptyObject) {
    return routeModule.default;
  }
}
function shouldHydrateRouteLoader(route, routeModule, isSpaMode) {
  return isSpaMode && route.id !== "root" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);
}

// lib/dom/ssr/fog-of-war.ts
var nextPaths = /* @__PURE__ */ new Set();
var discoveredPathsMaxSize = 1e3;
var discoveredPaths = /* @__PURE__ */ new Set();
var URL_LIMIT = 7680;
function isFogOfWarEnabled(isSpaMode) {
  return !isSpaMode;
}
function getPartialManifest(manifest, router) {
  let routeIds = new Set(router.state.matches.map((m) => m.route.id));
  let segments = router.state.location.pathname.split("/").filter(Boolean);
  let paths = ["/"];
  segments.pop();
  while (segments.length > 0) {
    paths.push(`/${segments.join("/")}`);
    segments.pop();
  }
  paths.forEach((path) => {
    let matches = matchRoutes(router.routes, path, router.basename);
    if (matches) {
      matches.forEach((m) => routeIds.add(m.route.id));
    }
  });
  let initialRoutes = [...routeIds].reduce(
    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),
    {}
  );
  return {
    ...manifest,
    routes: initialRoutes
  };
}
function getPatchRoutesOnNavigationFunction(manifest, routeModules, isSpaMode, basename) {
  if (!isFogOfWarEnabled(isSpaMode)) {
    return void 0;
  }
  return async ({ path, patch }) => {
    if (discoveredPaths.has(path)) {
      return;
    }
    await fetchAndApplyManifestPatches(
      [path],
      manifest,
      routeModules,
      isSpaMode,
      basename,
      patch
    );
  };
}
function useFogOFWarDiscovery(router, manifest, routeModules, isSpaMode) {
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isFogOfWarEnabled(isSpaMode) || navigator.connection?.saveData === true) {
      return;
    }
    function registerElement(el) {
      let path = el.tagName === "FORM" ? el.getAttribute("action") : el.getAttribute("href");
      if (!path) {
        return;
      }
      let url = new URL(path, window.location.origin);
      if (!discoveredPaths.has(url.pathname)) {
        nextPaths.add(url.pathname);
      }
    }
    async function fetchPatches() {
      let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {
        if (discoveredPaths.has(path)) {
          nextPaths.delete(path);
          return false;
        }
        return true;
      });
      if (lazyPaths.length === 0) {
        return;
      }
      try {
        await fetchAndApplyManifestPatches(
          lazyPaths,
          manifest,
          routeModules,
          isSpaMode,
          router.basename,
          router.patchRoutes
        );
      } catch (e) {
        console.error("Failed to fetch manifest patches", e);
      }
    }
    document.body.querySelectorAll("a[data-discover], form[data-discover]").forEach((el) => registerElement(el));
    fetchPatches();
    let debouncedFetchPatches = debounce(fetchPatches, 100);
    function isElement(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    }
    let observer = new MutationObserver((records) => {
      let elements = /* @__PURE__ */ new Set();
      records.forEach((r) => {
        [r.target, ...r.addedNodes].forEach((node) => {
          if (!isElement(node)) return;
          if (node.tagName === "A" && node.getAttribute("data-discover")) {
            elements.add(node);
          } else if (node.tagName === "FORM" && node.getAttribute("data-discover")) {
            elements.add(node);
          }
          if (node.tagName !== "A") {
            node.querySelectorAll("a[data-discover], form[data-discover]").forEach((el) => elements.add(el));
          }
        });
      });
      elements.forEach((el) => registerElement(el));
      debouncedFetchPatches();
    });
    observer.observe(document.documentElement, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["data-discover", "href", "action"]
    });
    return () => observer.disconnect();
  }, [isSpaMode, manifest, routeModules, router]);
}
async function fetchAndApplyManifestPatches(paths, manifest, routeModules, isSpaMode, basename, patchRoutes) {
  let manifestPath = `${basename != null ? basename : "/"}/__manifest`.replace(
    /\/+/g,
    "/"
  );
  let url = new URL(manifestPath, window.location.origin);
  paths.sort().forEach((path) => url.searchParams.append("p", path));
  url.searchParams.set("version", manifest.version);
  if (url.toString().length > URL_LIMIT) {
    nextPaths.clear();
    return;
  }
  let res = await fetch(url);
  if (!res.ok) {
    throw new Error(`${res.status} ${res.statusText}`);
  } else if (res.status >= 400) {
    throw new Error(await res.text());
  }
  let serverPatches = await res.json();
  let knownRoutes = new Set(Object.keys(manifest.routes));
  let patches = Object.values(serverPatches).reduce((acc, route) => {
    if (route && !knownRoutes.has(route.id)) {
      acc[route.id] = route;
    }
    return acc;
  }, {});
  Object.assign(manifest.routes, patches);
  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));
  let parentIds = /* @__PURE__ */ new Set();
  Object.values(patches).forEach((patch) => {
    if (patch && (!patch.parentId || !patches[patch.parentId])) {
      parentIds.add(patch.parentId);
    }
  });
  parentIds.forEach(
    (parentId) => patchRoutes(
      parentId || null,
      createClientRoutes(patches, routeModules, null, isSpaMode, parentId)
    )
  );
}
function addToFifoQueue(path, queue) {
  if (queue.size >= discoveredPathsMaxSize) {
    let first = queue.values().next().value;
    queue.delete(first);
  }
  queue.add(path);
}
function debounce(callback, wait) {
  let timeoutId;
  return (...args) => {
    window.clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => callback(...args), wait);
  };
}

// lib/dom/ssr/components.tsx
function useDataRouterContext2() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function getActiveMatches(matches, errors, isSpaMode) {
  if (isSpaMode && !isHydrated) {
    return [matches[0]];
  }
  if (errors) {
    let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);
    return matches.slice(0, errorIdx + 1);
  }
  return matches;
}
function Links() {
  let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();
  let { errors, matches: routerMatches } = useDataRouterStateContext();
  let matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let keyedLinks = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getKeyedLinksForMatches(matches, routeModules, manifest),
    [matches, routeModules, manifest]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, criticalCss ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("style", { dangerouslySetInnerHTML: { __html: criticalCss } }) : null, keyedLinks.map(
    ({ key, link }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { key, ...link }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key, ...link })
  ));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let { router } = useDataRouterContext2();
  let matches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key: href, rel: "prefetch", as: "fetch", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key: href, rel: "modulepreload", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", { key, ...link })
  )));
}
function Meta() {
  let { isSpaMode, routeModules } = useFrameworkContext();
  let {
    errors,
    matches: routerMatches,
    loaderData
  } = useDataRouterStateContext();
  let location = useLocation();
  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let error = null;
  if (errors) {
    error = errors[_matches[_matches.length - 1].route.id];
  }
  let meta = [];
  let leafMeta = null;
  let matches = [];
  for (let i = 0; i < _matches.length; i++) {
    let _match = _matches[i];
    let routeId = _match.route.id;
    let data2 = loaderData[routeId];
    let params = _match.params;
    let routeModule = routeModules[routeId];
    let routeMeta = [];
    let match = {
      id: routeId,
      data: data2,
      meta: [],
      params: _match.params,
      pathname: _match.pathname,
      handle: _match.route.handle,
      error
    };
    matches[i] = match;
    if (routeModule?.meta) {
      routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data: data2,
        params,
        location,
        matches,
        error
      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;
    } else if (leafMeta) {
      routeMeta = [...leafMeta];
    }
    routeMeta = routeMeta || [];
    if (!Array.isArray(routeMeta)) {
      throw new Error(
        "The route at " + _match.route.path + " returns an invalid value. All route meta functions must return an array of meta objects.\n\nTo reference the meta function API, see https://remix.run/route/meta"
      );
    }
    match.meta = routeMeta;
    matches[i] = match;
    meta = [...routeMeta];
    leafMeta = meta;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, meta.flat().map((metaProps) => {
    if (!metaProps) {
      return null;
    }
    if ("tagName" in metaProps) {
      let { tagName, ...rest } = metaProps;
      if (!isValidMetaTag(tagName)) {
        console.warn(
          `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`
        );
        return null;
      }
      let Comp = tagName;
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, { key: JSON.stringify(rest), ...rest });
    }
    if ("title" in metaProps) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", { key: "title" }, String(metaProps.title));
    }
    if ("charset" in metaProps) {
      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);
      delete metaProps.charset;
    }
    if ("charSet" in metaProps && metaProps.charSet != null) {
      return typeof metaProps.charSet === "string" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { key: "charSet", charSet: metaProps.charSet }) : null;
    }
    if ("script:ld+json" in metaProps) {
      try {
        let json = JSON.stringify(metaProps["script:ld+json"]);
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          "script",
          {
            key: `script:ld+json:${json}`,
            type: "application/ld+json",
            dangerouslySetInnerHTML: { __html: json }
          }
        );
      } catch (err) {
        return null;
      }
    }
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", { key: JSON.stringify(metaProps), ...metaProps });
  }));
}
function isValidMetaTag(tagName) {
  return typeof tagName === "string" && /^(meta|link)$/.test(tagName);
}
var isHydrated = false;
function Scripts(props) {
  let { manifest, serverHandoffString, isSpaMode, renderMeta } = useFrameworkContext();
  let { router, static: isStatic, staticContext } = useDataRouterContext2();
  let { matches: routerMatches } = useDataRouterStateContext();
  let enableFogOfWar = isFogOfWarEnabled(isSpaMode);
  if (renderMeta) {
    renderMeta.didRenderScripts = true;
  }
  let matches = getActiveMatches(routerMatches, null, isSpaMode);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
    let routeModulesScript = !isStatic ? " " : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};
${matches.map(
      (match, index) => `import * as route${index} from ${JSON.stringify(
        manifest.routes[match.route.id].module
      )};`
    ).join("\n")}
  ${enableFogOfWar ? (
      // Inline a minimal manifest with the SSR matches
      `window.__reactRouterManifest = ${JSON.stringify(
        getPartialManifest(manifest, router),
        null,
        2
      )};`
    ) : ""}
  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: createHtml(contextScript),
        type: void 0
      }
    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: createHtml(routeModulesScript),
        type: "module",
        async: true
      }
    ));
  }, []);
  let routePreloads = matches.map((match) => {
    let route = manifest.routes[match.route.id];
    return route ? (route.imports || []).concat([route.module]) : [];
  }).flat(1);
  let preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
  return isHydrated ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !enableFogOfWar ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.url,
      crossOrigin: props.crossOrigin
    }
  ) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.entry.module,
      crossOrigin: props.crossOrigin
    }
  ), dedupe(preloads).map((path) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "link",
    {
      key: path,
      rel: "modulepreload",
      href: path,
      crossOrigin: props.crossOrigin
    }
  )), initialScripts);
}
function dedupe(array) {
  return [...new Set(array)];
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

// lib/dom/lib.tsx
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = "7.1.3";
  }
} catch (e) {
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createBrowserHistory({ window: opts?.window }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    future: opts?.future,
    history: createHashHistory({ window: opts?.window }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function parseHydrationData() {
  let state = window?.__staticRouterHydrationData;
  if (state && state.errors) {
    state = {
      ...state,
      errors: deserializeErrors(state.errors)
    };
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(
        val.status,
        val.statusText,
        val.data,
        val.internal === true
      );
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function HashRouter({ basename, children, window: window2 }) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
function HistoryRouter({
  basename,
  children,
  history
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (newState) => {
      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
HistoryRouter.displayName = "unstable_HistoryRouter";
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  }, forwardedRef) {
    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, link, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link.displayName = "Link";
var NavLink = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    ...props
  }, forwardedRef) => {
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form.displayName = "Form";
function ScrollRestoration({
  getKey,
  storageKey,
  ...props
}) {
  let remixContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  useScrollRestoration({ getKey, storageKey });
  let ssrKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => {
      if (!remixContext || !getKey) return null;
      let userKey = getScrollRestorationKey(
        location,
        matches,
        basename,
        getKey
      );
      return userKey !== location.key ? userKey : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (!remixContext || remixContext.isSpaMode) {
    return null;
  }
  let restoreScroll = ((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  }).toString();
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      ...props,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: `(${restoreScroll})(${JSON.stringify(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY
        )}, ${JSON.stringify(ssrKey)})`
      }
    }
  );
}
ScrollRestoration.displayName = "ScrollRestoration";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError2(hookName));
  return state;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
function useSearchParams(defaultInit) {
  warning(
    typeof URLSearchParams !== "undefined",
    `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`
  );
  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  let location = useLocation();
  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      getSearchParamsForLocation(
        location.search,
        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current
      )
    ),
    [location.search]
  );
  let navigate = useNavigate();
  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (nextInit, navigateOptions) => {
      const newSearchParams = createSearchParams(
        typeof nextInit === "function" ? nextInit(searchParams) : nextInit
      );
      hasSetSearchParamsRef.current = true;
      navigate("?" + newSearchParams, navigateOptions);
    },
    [navigate, searchParams]
  );
  return [searchParams, setSearchParams];
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3("useSubmit" /* UseSubmit */);
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useFetcher({
  key
} = {}) {
  let { router } = useDataRouterContext3("useFetcher" /* UseFetcher */);
  let state = useDataRouterState2("useFetcher" /* UseFetcher */);
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeId = route.matches[route.matches.length - 1]?.route.id;
  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);
  invariant(route, `useFetcher must be used inside a RouteContext`);
  invariant(
    routeId != null,
    `useFetcher can only be used on routes that contain a unique "id"`
  );
  let defaultKey = react__WEBPACK_IMPORTED_MODULE_0__.useId();
  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);
  if (key && key !== fetcherKey) {
    setFetcherKey(key);
  }
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    router.getFetcher(fetcherKey);
    return () => router.deleteFetcher(fetcherKey);
  }, [router, fetcherKey]);
  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (href, opts) => {
      invariant(routeId, "No routeId available for fetcher.load()");
      await router.fetch(fetcherKey, routeId, href, opts);
    },
    [fetcherKey, routeId, router]
  );
  let submitImpl = useSubmit();
  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    async (target, opts) => {
      await submitImpl(target, {
        ...opts,
        navigate: false,
        fetcherKey
      });
    },
    [fetcherKey, submitImpl]
  );
  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let FetcherForm2 = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
      (props, ref) => {
        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, { ...props, navigate: false, fetcherKey, ref });
      }
    );
    FetcherForm2.displayName = "fetcher.Form";
    return FetcherForm2;
  }, [fetcherKey]);
  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
  let data2 = fetcherData.get(fetcherKey);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => ({
      Form: FetcherForm,
      submit,
      load,
      ...fetcher,
      data: data2
    }),
    [FetcherForm, submit, load, fetcher, data2]
  );
  return fetcherWithComponents;
}
function useFetchers() {
  let state = useDataRouterState2("useFetchers" /* UseFetchers */);
  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({
    ...fetcher,
    key
  }));
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function getScrollRestorationKey(location, matches, basename, getKey) {
  let key = null;
  if (getKey) {
    if (basename !== "/") {
      key = getKey(
        {
          ...location,
          pathname: stripBasename(location.pathname, basename) || location.pathname
        },
        matches
      );
    } else {
      key = getKey(location, matches);
    }
  }
  if (key == null) {
    key = location.key;
  }
  return key;
}
function useScrollRestoration({
  getKey,
  storageKey
} = {}) {
  let { router } = useDataRouterContext3("useScrollRestoration" /* UseScrollRestoration */);
  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
    "useScrollRestoration" /* UseScrollRestoration */
  );
  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(
    react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
      if (navigation.state === "idle") {
        let key = getScrollRestorationKey(location, matches, basename, getKey);
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY,
          JSON.stringify(savedScrollPositions)
        );
      } catch (error) {
        warning(
          false,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
        );
      }
      window.history.scrollRestoration = "auto";
    }, [navigation.state, getKey, basename, location, matches, storageKey])
  );
  if (typeof document !== "undefined") {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY
        );
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {
      }
    }, [storageKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      let disableScrollRestoration = router?.enableScrollRestoration(
        savedScrollPositions,
        () => window.scrollY,
        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0
      );
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(
          decodeURIComponent(location.hash.slice(1))
        );
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function useBeforeUnload(callback, options) {
  let { capture } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? { capture } : void 0;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
function usePageHide(callback, options) {
  let { capture } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? { capture } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function usePrompt({
  when,
  message
}) {
  let blocker = useBlocker(when);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState" /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative: opts.relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// lib/dom/server.tsx

function StaticRouter({
  basename,
  children,
  location: locationProp = "/"
}) {
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let action = "POP" /* Pop */;
  let location = {
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state != null ? locationProp.state : null,
    key: locationProp.key || "default"
  };
  let staticNavigator = getStatelessNavigator();
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename,
      children,
      location,
      navigationType: action,
      navigator: staticNavigator,
      static: true
    }
  );
}
function StaticRouterProvider({
  context,
  router,
  hydrate = true,
  nonce
}) {
  invariant(
    router && context,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let dataRouterContext = {
    router,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
  };
  let fetchersContext = /* @__PURE__ */ new Map();
  let hydrateScript = "";
  if (hydrate !== false) {
    let data2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
    };
    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
  }
  let { state } = dataRouterContext.router;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    Router,
    {
      basename: dataRouterContext.basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: dataRouterContext.navigator,
      static: dataRouterContext.static
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      DataRoutes2,
      {
        routes: router.routes,
        future: router.future,
        state
      }
    )
  ))))), hydrateScript ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    "script",
    {
      suppressHydrationWarning: true,
      nonce,
      dangerouslySetInnerHTML: { __html: hydrateScript }
    }
  ) : null);
}
function DataRoutes2({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function serializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = { ...val, __type: "RouteErrorResponse" };
    } else if (val instanceof Error) {
      serialized[key] = {
        message: val.message,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.
        ...val.name !== "Error" ? {
          __subType: val.name
        } : {}
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function getStatelessNavigator() {
  return {
    createHref,
    encodeLocation,
    push(to) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`
      );
    },
    replace(to) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(delta) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        `You cannot use navigator.back() on the server because it is a stateless environment.`
      );
    },
    forward() {
      throw new Error(
        `You cannot use navigator.forward() on the server because it is a stateless environment.`
      );
    }
  };
}
function createStaticHandler2(routes, opts) {
  return createStaticHandler(routes, {
    ...opts,
    mapRouteProperties
  });
}
function createStaticRouter(routes, context, opts = {}) {
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(
    routes,
    mapRouteProperties,
    void 0,
    manifest
  );
  let matches = context.matches.map((match) => {
    let route = manifest[match.route.id] || match.route;
    return {
      ...match,
      route
    };
  });
  let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return context.basename;
    },
    get future() {
      return {
        ...opts?.future
      };
    },
    get state() {
      return {
        historyAction: "POP" /* Pop */,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return void 0;
    },
    initialize() {
      throw msg("initialize");
    },
    subscribe() {
      throw msg("subscribe");
    },
    enableScrollRestoration() {
      throw msg("enableScrollRestoration");
    },
    navigate() {
      throw msg("navigate");
    },
    fetch() {
      throw msg("fetch");
    },
    revalidate() {
      throw msg("revalidate");
    },
    createHref,
    encodeLocation,
    getFetcher() {
      return IDLE_FETCHER;
    },
    deleteFetcher() {
      throw msg("deleteFetcher");
    },
    dispose() {
      throw msg("dispose");
    },
    getBlocker() {
      return IDLE_BLOCKER;
    },
    deleteBlocker() {
      throw msg("deleteBlocker");
    },
    patchRoutes() {
      throw msg("patchRoutes");
    },
    _internalFetchControllers: /* @__PURE__ */ new Map(),
    _internalSetRoutes() {
      throw msg("_internalSetRoutes");
    }
  };
}
function createHref(to) {
  return typeof to === "string" ? to : createPath(to);
}
function encodeLocation(to) {
  let href = typeof to === "string" ? to : createPath(to);
  href = href.replace(/ $/, "%20");
  let encoded = ABSOLUTE_URL_REGEX3.test(href) ? new URL(href) : new URL(href, "http://localhost");
  return {
    pathname: encoded.pathname,
    search: encoded.search,
    hash: encoded.hash
  };
}
var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var ESCAPE_LOOKUP2 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
function htmlEscape(str) {
  return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);
}

// lib/dom/ssr/server.tsx

function ServerRouter({
  context,
  url,
  nonce
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let { manifest, routeModules, criticalCss, serverHandoffString } = context;
  let routes = createServerRoutes(
    manifest.routes,
    routeModules,
    context.future,
    context.isSpaMode
  );
  context.staticHandlerContext.loaderData = {
    ...context.staticHandlerContext.loaderData
  };
  for (let match of context.staticHandlerContext.matches) {
    let routeId = match.route.id;
    let route = routeModules[routeId];
    let manifestRoute = context.manifest.routes[routeId];
    if (route && manifestRoute && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {
      delete context.staticHandlerContext.loaderData[routeId];
    }
  }
  let router = createStaticRouter(routes, context.staticHandlerContext);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    FrameworkContext.Provider,
    {
      value: {
        manifest,
        routeModules,
        criticalCss,
        serverHandoffString,
        future: context.future,
        isSpaMode: context.isSpaMode,
        serializeError: context.serializeError,
        renderMeta: context.renderMeta
      }
    },
    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      StaticRouterProvider,
      {
        router,
        context: context.staticHandlerContext,
        hydrate: false
      }
    ))
  ), context.serverHandoffStream ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    StreamTransfer,
    {
      context,
      identifier: 0,
      reader: context.serverHandoffStream.getReader(),
      textDecoder: new TextDecoder(),
      nonce
    }
  )) : null);
}

// lib/dom/ssr/routes-test-stub.tsx

function createRoutesStub(routes, context = {}) {
  return function RoutesTestStub({
    initialEntries,
    initialIndex,
    hydrationData,
    future
  }) {
    let routerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    let remixContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    if (routerRef.current == null) {
      remixContextRef.current = {
        future: {},
        manifest: {
          routes: {},
          entry: { imports: [], module: "" },
          url: "",
          version: ""
        },
        routeModules: {},
        isSpaMode: false
      };
      let patched = processRoutes(
        // @ts-expect-error loader/action context types don't match :/
        convertRoutesToDataRoutes(routes, (r) => r),
        context,
        remixContextRef.current.manifest,
        remixContextRef.current.routeModules
      );
      routerRef.current = createMemoryRouter(patched, {
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameworkContext.Provider, { value: remixContextRef.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouterProvider, { router: routerRef.current }));
  };
}
function processRoutes(routes, context, manifest, routeModules, parentId) {
  return routes.map((route) => {
    if (!route.id) {
      throw new Error(
        "Expected a route.id in @remix-run/testing processRoutes() function"
      );
    }
    let { loader, action } = route;
    let newRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      Component: route.Component,
      HydrateFallback: route.HydrateFallback,
      ErrorBoundary: route.ErrorBoundary,
      action: action ? (args) => action({ ...args, context }) : void 0,
      loader: loader ? (args) => loader({ ...args, context }) : void 0,
      handle: route.handle,
      shouldRevalidate: route.shouldRevalidate
    };
    let entryRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      parentId,
      hasAction: route.action != null,
      hasLoader: route.loader != null,
      // When testing routes, you should just be stubbing loader/action, not
      // trying to re-implement the full loader/clientLoader/SSR/hydration flow.
      // That is better tested via E2E tests.
      hasClientAction: false,
      hasClientLoader: false,
      hasErrorBoundary: route.ErrorBoundary != null,
      module: "build/stub-path-to-module.js"
      // any need for this?
    };
    manifest.routes[newRoute.id] = entryRoute;
    routeModules[route.id] = {
      default: route.Component || Outlet,
      ErrorBoundary: route.ErrorBoundary || void 0,
      handle: route.handle,
      links: route.links,
      meta: route.meta,
      shouldRevalidate: route.shouldRevalidate
    };
    if (route.children) {
      newRoute.children = processRoutes(
        route.children,
        context,
        manifest,
        routeModules,
        newRoute.id
      );
    }
    return newRoute;
  });
}

// lib/server-runtime/cookies.ts


// lib/server-runtime/crypto.ts
var encoder = new TextEncoder();
var sign = async (value, secret) => {
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["sign"]);
  let signature = await crypto.subtle.sign("HMAC", key, data2);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(
    /=+$/,
    ""
  );
  return value + "." + hash;
};
var unsign = async (cookie, secret) => {
  let index = cookie.lastIndexOf(".");
  let value = cookie.slice(0, index);
  let hash = cookie.slice(index + 1);
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["verify"]);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data2);
  return valid ? value : false;
};
var createKey2 = async (secret, usages) => crypto.subtle.importKey(
  "raw",
  encoder.encode(secret),
  { name: "HMAC", hash: "SHA-256" },
  false,
  usages
);
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// lib/server-runtime/cookies.ts
var createCookie = (name, cookieOptions = {}) => {
  let { secrets = [], ...options } = {
    path: "/",
    sameSite: "lax",
    ...cookieOptions
  };
  warnOnceAboutExpiresCookie(name, options.expires);
  return {
    get name() {
      return name;
    },
    get isSigned() {
      return secrets.length > 0;
    },
    get expires() {
      return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
    },
    async parse(cookieHeader, parseOptions) {
      if (!cookieHeader) return null;
      let cookies = (0,cookie__WEBPACK_IMPORTED_MODULE_2__.parse)(cookieHeader, { ...options, ...parseOptions });
      if (name in cookies) {
        let value = cookies[name];
        if (typeof value === "string" && value !== "") {
          let decoded = await decodeCookieValue(value, secrets);
          return decoded;
        } else {
          return "";
        }
      } else {
        return null;
      }
    },
    async serialize(value, serializeOptions) {
      return (0,cookie__WEBPACK_IMPORTED_MODULE_2__.serialize)(
        name,
        value === "" ? "" : await encodeCookieValue(value, secrets),
        {
          ...options,
          ...serializeOptions
        }
      );
    }
  };
};
var isCookie = (object) => {
  return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
};
async function encodeCookieValue(value, secrets) {
  let encoded = encodeData(value);
  if (secrets.length > 0) {
    encoded = await sign(encoded, secrets[0]);
  }
  return encoded;
}
async function decodeCookieValue(value, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value, secret);
      if (unsignedValue !== false) {
        return decodeData(unsignedValue);
      }
    }
    return null;
  }
  return decodeData(value);
}
function encodeData(value) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
}
function decodeData(value) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value))));
  } catch (error) {
    return {};
  }
}
function myEscape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, code;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (/[\w*+\-./@]/.exec(chr)) {
      result += chr;
    } else {
      code = chr.charCodeAt(0);
      if (code < 256) {
        result += "%" + hex(code, 2);
      } else {
        result += "%u" + hex(code, 4).toUpperCase();
      }
    }
  }
  return result;
}
function hex(code, length) {
  let result = code.toString(16);
  while (result.length < length) result = "0" + result;
  return result;
}
function myUnescape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, part;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (chr === "%") {
      if (str.charAt(index) === "u") {
        part = str.slice(index + 1, index + 5);
        if (/^[\da-f]{4}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 5;
          continue;
        }
      } else {
        part = str.slice(index, index + 2);
        if (/^[\da-f]{2}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 2;
          continue;
        }
      }
    }
    result += chr;
  }
  return result;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(
    !expires,
    `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`
  );
}

// lib/server-runtime/entry.ts
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo2, routeId) => {
    let route = manifest[routeId];
    if (route) {
      memo2[routeId] = route.module;
    }
    return memo2;
  }, {});
}

// lib/server-runtime/mode.ts
var ServerMode = /* @__PURE__ */ ((ServerMode2) => {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
  return ServerMode2;
})(ServerMode || {});
function isServerMode(value) {
  return value === "development" /* Development */ || value === "production" /* Production */ || value === "test" /* Test */;
}

// lib/server-runtime/errors.ts
function sanitizeError(error, serverMode) {
  if (error instanceof Error && serverMode !== "development" /* Development */) {
    let sanitized = new Error("Unexpected Server Error");
    sanitized.stack = void 0;
    return sanitized;
  }
  return error;
}
function sanitizeErrors(errors, serverMode) {
  return Object.entries(errors).reduce((acc, [routeId, error]) => {
    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });
  }, {});
}
function serializeError(error, serverMode) {
  let sanitized = sanitizeError(error, serverMode);
  return {
    message: sanitized.message,
    stack: sanitized.stack
  };
}
function serializeErrors2(errors, serverMode) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = { ...val, __type: "RouteErrorResponse" };
    } else if (val instanceof Error) {
      let sanitized = sanitizeError(val, serverMode);
      serialized[key] = {
        message: sanitized.message,
        stack: sanitized.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...sanitized.name !== "Error" ? {
          __subType: sanitized.name
        } : {}
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}

// lib/server-runtime/routeMatching.ts
function matchServerRoutes(routes, pathname, basename) {
  let matches = matchRoutes(
    routes,
    pathname,
    basename
  );
  if (!matches) return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// lib/server-runtime/data.ts
async function callRouteHandler(handler, args) {
  let result = await handler({
    request: stripRoutesParam(stripIndexParam2(args.request)),
    params: args.params,
    context: args.context
  });
  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {
    throw new Response(null, result.init);
  }
  return result;
}
function stripIndexParam2(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}
function stripRoutesParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_routes");
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}

// lib/server-runtime/invariant.ts
function invariant3(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}

// lib/server-runtime/routes.ts
function groupRoutesByParentId2(manifest) {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
}
function createStaticHandlerDataRoutes(manifest, future, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let commonRoute = {
      // Always include root due to default boundaries
      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      // Need to use RR's version in the param typed here to permit the optional
      // context even though we know it'll always be provided in remix
      loader: route.module.loader ? async (args) => {
        if (args.request.headers.has("X-React-Router-Prerender-Data")) {
          const preRenderedData = args.request.headers.get(
            "X-React-Router-Prerender-Data"
          );
          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;
          invariant3(encoded, "Missing prerendered data for route");
          let uint8array = new TextEncoder().encode(encoded);
          let stream = new ReadableStream({
            start(controller) {
              controller.enqueue(uint8array);
              controller.close();
            }
          });
          let decoded = await decodeViaTurboStream(stream, global);
          let data2 = decoded.value;
          invariant3(
            data2 && route.id in data2,
            "Unable to decode prerendered data"
          );
          let result = data2[route.id];
          invariant3("data" in result, "Unable to process prerendered data");
          return result.data;
        }
        let val = await callRouteHandler(route.module.loader, args);
        return val;
      } : void 0,
      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: true,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createStaticHandlerDataRoutes(
        manifest,
        future,
        route.id,
        routesByParentId
      ),
      ...commonRoute
    };
  });
}

// lib/server-runtime/markup.ts
var ESCAPE_LOOKUP3 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
function escapeHtml2(html) {
  return html.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
}

// lib/server-runtime/serverHandoff.ts
function createServerHandoffString(serverHandoff) {
  return escapeHtml2(JSON.stringify(serverHandoff));
}

// lib/server-runtime/dev.ts
var globalDevServerHooksKey = "__reactRouterDevServerHooks";
function setDevServerHooks(devServerHooks) {
  globalThis[globalDevServerHooksKey] = devServerHooks;
}
function getDevServerHooks() {
  return globalThis[globalDevServerHooksKey];
}

// lib/server-runtime/single-fetch.ts


// lib/server-runtime/headers.ts

function getDocumentHeaders(build, context) {
  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;
  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;
  let errorHeaders;
  if (boundaryIdx >= 0) {
    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;
    context.matches.slice(boundaryIdx).some((match) => {
      let id = match.route.id;
      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {
        errorHeaders = actionHeaders[id];
      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {
        errorHeaders = loaderHeaders[id];
      }
      return errorHeaders != null;
    });
  }
  return matches.reduce((parentHeaders, match, idx) => {
    let { id } = match.route;
    let route = build.routes[id];
    invariant3(route, `Route with id "${id}" not found in build`);
    let routeModule = route.module;
    let loaderHeaders = context.loaderHeaders[id] || new Headers();
    let actionHeaders = context.actionHeaders[id] || new Headers();
    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;
    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
    if (routeModule.headers == null) {
      let headers2 = new Headers(parentHeaders);
      if (includeErrorCookies) {
        prependCookies(errorHeaders, headers2);
      }
      prependCookies(actionHeaders, headers2);
      prependCookies(loaderHeaders, headers2);
      return headers2;
    }
    let headers = new Headers(
      routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
        loaderHeaders,
        parentHeaders,
        actionHeaders,
        errorHeaders: includeErrorHeaders ? errorHeaders : void 0
      }) : routeModule.headers : void 0
    );
    if (includeErrorCookies) {
      prependCookies(errorHeaders, headers);
    }
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// lib/server-runtime/single-fetch.ts
var SINGLE_FETCH_REDIRECT_STATUS = 202;
function getSingleFetchDataStrategy2({
  isActionDataRequest,
  loadRouteIds
} = {}) {
  return async ({ request, matches }) => {
    if (isActionDataRequest && request.method === "GET") {
      return {};
    }
    let matchesToLoad = loadRouteIds ? matches.filter((m) => loadRouteIds.includes(m.route.id)) : matches;
    let results = await Promise.all(
      matchesToLoad.map((match) => match.resolve())
    );
    return results.reduce(
      (acc, result, i) => Object.assign(acc, { [matchesToLoad[i].route.id]: result }),
      {}
    );
  };
}
async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let handlerRequest = new Request(handlerUrl, {
      method: request.method,
      body: request.body,
      headers: request.headers,
      signal: request.signal,
      ...request.body ? { duplex: "half" } : void 0
    });
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: true,
      dataStrategy: getSingleFetchDataStrategy2({
        isActionDataRequest: true
      })
    });
    if (isResponse(result)) {
      return {
        result: getSingleFetchRedirect(
          result.status,
          result.headers,
          build.basename
        ),
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    let context = result;
    let headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
      return {
        result: getSingleFetchRedirect(
          context.statusCode,
          headers,
          build.basename
        ),
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    if (context.errors) {
      Object.values(context.errors).forEach((err) => {
        if (!isRouteErrorResponse(err) || err.error) {
          handleError(err);
        }
      });
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let singleFetchResult;
    if (context.errors) {
      singleFetchResult = { error: Object.values(context.errors)[0] };
    } else {
      singleFetchResult = { data: Object.values(context.actionData || {})[0] };
    }
    return {
      result: singleFetchResult,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    handleError(error);
    return {
      result: { error },
      headers: new Headers(),
      status: 500
    };
  }
}
async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let handlerRequest = new Request(handlerUrl, {
      headers: request.headers,
      signal: request.signal
    });
    let loadRouteIds = new URL(request.url).searchParams.get("_routes")?.split(",") || void 0;
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: true,
      dataStrategy: getSingleFetchDataStrategy2({
        loadRouteIds
      })
    });
    if (isResponse(result)) {
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
            result.status,
            result.headers,
            build.basename
          )
        },
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    let context = result;
    let headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(
            context.statusCode,
            headers,
            build.basename
          )
        },
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    }
    if (context.errors) {
      Object.values(context.errors).forEach((err) => {
        if (!isRouteErrorResponse(err) || err.error) {
          handleError(err);
        }
      });
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let results = {};
    let loadedMatches = loadRouteIds ? context.matches.filter(
      (m) => m.route.loader && loadRouteIds.includes(m.route.id)
    ) : context.matches;
    loadedMatches.forEach((m) => {
      let { id } = m.route;
      if (context.errors && context.errors.hasOwnProperty(id)) {
        results[id] = { error: context.errors[id] };
      } else if (context.loaderData.hasOwnProperty(id)) {
        results[id] = { data: context.loaderData[id] };
      }
    });
    return {
      result: results,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    handleError(error);
    return {
      result: { root: { error } },
      headers: new Headers(),
      status: 500
    };
  }
}
function getSingleFetchRedirect(status, headers, basename) {
  let redirect2 = headers.get("Location");
  if (basename) {
    redirect2 = stripBasename(redirect2, basename) || redirect2;
  }
  return {
    redirect: redirect2,
    status,
    revalidate: (
      // Technically X-Remix-Revalidate isn't needed here - that was an implementation
      // detail of ?_data requests as our way to tell the front end to revalidate when
      // we didn't have a response body to include that information in.
      // With single fetch, we tell the front end via this revalidate boolean field.
      // However, we're respecting it for now because it may be something folks have
      // used in their own responses
      // TODO(v3): Consider removing or making this official public API
      headers.has("X-Remix-Revalidate") || headers.has("Set-Cookie")
    ),
    reload: headers.has("X-Remix-Reload-Document"),
    replace: headers.has("X-Remix-Replace")
  };
}
function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {
  let controller = new AbortController();
  let timeoutId = setTimeout(
    () => controller.abort(new Error("Server Timeout")),
    typeof streamTimeout === "number" ? streamTimeout : 4950
  );
  requestSignal.addEventListener("abort", () => clearTimeout(timeoutId));
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.encode)(data2, {
    signal: controller.signal,
    plugins: [
      (value) => {
        if (value instanceof Error) {
          let { name, message, stack } = serverMode === "production" /* Production */ ? sanitizeError(value, serverMode) : value;
          return ["SanitizedError", name, message, stack];
        }
        if (value instanceof ErrorResponseImpl) {
          let { data: data3, status, statusText } = value;
          return ["ErrorResponse", data3, status, statusText];
        }
        if (value && typeof value === "object" && SingleFetchRedirectSymbol in value) {
          return ["SingleFetchRedirect", value[SingleFetchRedirectSymbol]];
        }
      }
    ],
    postPlugins: [
      (value) => {
        if (!value) return;
        if (typeof value !== "object") return;
        return [
          "SingleFetchClassInstance",
          Object.fromEntries(Object.entries(value))
        ];
      },
      () => ["SingleFetchFallback"]
    ]
  });
}

// lib/server-runtime/server.ts
function derive(build, mode) {
  let routes = createRoutes(build.routes);
  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);
  let serverMode = isServerMode(mode) ? mode : "production" /* Production */;
  let staticHandler = createStaticHandler(dataRoutes, {
    basename: build.basename
  });
  let errorHandler = build.entry.module.handleError || ((error, { request }) => {
    if (serverMode !== "test" /* Test */ && !request.signal.aborted) {
      console.error(
        // @ts-expect-error This is "private" from users but intended for internal use
        isRouteErrorResponse(error) && error.error ? error.error : error
      );
    }
  });
  return {
    routes,
    dataRoutes,
    serverMode,
    staticHandler,
    errorHandler
  };
}
var createRequestHandler = (build, mode) => {
  let _build;
  let routes;
  let serverMode;
  let staticHandler;
  let errorHandler;
  return async function requestHandler(request, loadContext = {}) {
    _build = typeof build === "function" ? await build() : build;
    if (typeof build === "function") {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    }
    let url = new URL(request.url);
    let params = {};
    let handleError = (error) => {
      if (mode === "development" /* Development */) {
        getDevServerHooks()?.processRequestError?.(error);
      }
      errorHandler(error, {
        context: loadContext,
        params,
        request
      });
    };
    let manifestUrl = `${_build.basename ?? "/"}/__manifest`.replace(
      /\/+/g,
      "/"
    );
    if (url.pathname === manifestUrl) {
      try {
        let res = await handleManifestRequest(_build, routes, url);
        return res;
      } catch (e) {
        handleError(e);
        return new Response("Unknown Server Error", { status: 500 });
      }
    }
    let matches = matchServerRoutes(routes, url.pathname, _build.basename);
    if (matches && matches.length > 0) {
      Object.assign(params, matches[0].params);
    }
    let response;
    if (url.pathname.endsWith(".data")) {
      let handlerUrl = new URL(request.url);
      handlerUrl.pathname = handlerUrl.pathname.replace(/\.data$/, "").replace(/^\/_root$/, "/");
      let singleFetchMatches = matchServerRoutes(
        routes,
        handlerUrl.pathname,
        _build.basename
      );
      response = await handleSingleFetchRequest(
        serverMode,
        _build,
        staticHandler,
        request,
        handlerUrl,
        loadContext,
        handleError
      );
      if (_build.entry.module.handleDataRequest) {
        response = await _build.entry.module.handleDataRequest(response, {
          context: loadContext,
          params: singleFetchMatches ? singleFetchMatches[0].params : {},
          request
        });
        if (isRedirectResponse(response)) {
          let result = getSingleFetchRedirect(
            response.status,
            response.headers,
            _build.basename
          );
          if (request.method === "GET") {
            result = {
              [SingleFetchRedirectSymbol]: result
            };
          }
          let headers = new Headers(response.headers);
          headers.set("Content-Type", "text/x-script");
          return new Response(
            encodeViaTurboStream(
              result,
              request.signal,
              _build.entry.module.streamTimeout,
              serverMode
            ),
            {
              status: SINGLE_FETCH_REDIRECT_STATUS,
              headers
            }
          );
        }
      }
    } else if (matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {
      response = await handleResourceRequest(
        serverMode,
        staticHandler,
        matches.slice(-1)[0].route.id,
        request,
        loadContext,
        handleError
      );
    } else {
      let criticalCss = mode === "development" /* Development */ ? await getDevServerHooks()?.getCriticalCss?.(_build, url.pathname) : void 0;
      response = await handleDocumentRequest(
        serverMode,
        _build,
        staticHandler,
        request,
        loadContext,
        handleError,
        criticalCss
      );
    }
    if (request.method === "HEAD") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
};
async function handleManifestRequest(build, routes, url) {
  let patches = {};
  if (url.searchParams.has("p")) {
    for (let path of url.searchParams.getAll("p")) {
      let matches = matchServerRoutes(routes, path, build.basename);
      if (matches) {
        for (let match of matches) {
          let routeId = match.route.id;
          let route = build.assets.routes[routeId];
          if (route) {
            patches[routeId] = route;
          }
        }
      }
    }
    return Response.json(patches, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", { status: 400 });
}
async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {
  let { result, headers, status } = request.method !== "GET" ? await singleFetchAction(
    build,
    serverMode,
    staticHandler,
    request,
    handlerUrl,
    loadContext,
    handleError
  ) : await singleFetchLoaders(
    build,
    serverMode,
    staticHandler,
    request,
    handlerUrl,
    loadContext,
    handleError
  );
  let resultHeaders = new Headers(headers);
  resultHeaders.set("X-Remix-Response", "yes");
  if (status === 304) {
    return new Response(null, { status: 304, headers: resultHeaders });
  }
  resultHeaders.set("Content-Type", "text/x-script");
  return new Response(
    encodeViaTurboStream(
      result,
      request.signal,
      build.entry.module.streamTimeout,
      serverMode
    ),
    {
      status: status || 200,
      headers: resultHeaders
    }
  );
}
async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, criticalCss) {
  let context;
  try {
    context = await staticHandler.query(request, {
      requestContext: loadContext
    });
  } catch (error) {
    handleError(error);
    return new Response(null, { status: 500 });
  }
  if (isResponse(context)) {
    return context;
  }
  let headers = getDocumentHeaders(build, context);
  if (context.statusCode === 304) {
    return new Response(null, { status: 304, headers });
  }
  if (context.errors) {
    Object.values(context.errors).forEach((err) => {
      if (!isRouteErrorResponse(err) || err.error) {
        handleError(err);
      }
    });
    context.errors = sanitizeErrors(context.errors, serverMode);
  }
  let state = {
    loaderData: context.loaderData,
    actionData: context.actionData,
    errors: serializeErrors2(context.errors, serverMode)
  };
  let entryContext = {
    manifest: build.assets,
    routeModules: createEntryRouteModules(build.routes),
    staticHandlerContext: context,
    criticalCss,
    serverHandoffString: createServerHandoffString({
      basename: build.basename,
      criticalCss,
      future: build.future,
      isSpaMode: build.isSpaMode
    }),
    serverHandoffStream: encodeViaTurboStream(
      state,
      request.signal,
      build.entry.module.streamTimeout,
      serverMode
    ),
    renderMeta: {},
    future: build.future,
    isSpaMode: build.isSpaMode,
    serializeError: (err) => serializeError(err, serverMode)
  };
  let handleDocumentRequestFunction = build.entry.module.default;
  try {
    return await handleDocumentRequestFunction(
      request,
      context.statusCode,
      headers,
      entryContext,
      loadContext
    );
  } catch (error) {
    handleError(error);
    let errorForSecondRender = error;
    if (isResponse(error)) {
      try {
        let data2 = await unwrapResponse(error);
        errorForSecondRender = new ErrorResponseImpl(
          error.status,
          error.statusText,
          data2
        );
      } catch (e) {
      }
    }
    context = getStaticContextFromError(
      staticHandler.dataRoutes,
      context,
      errorForSecondRender
    );
    if (context.errors) {
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let state2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors2(context.errors, serverMode)
    };
    entryContext = {
      ...entryContext,
      staticHandlerContext: context,
      serverHandoffString: createServerHandoffString({
        basename: build.basename,
        future: build.future,
        isSpaMode: build.isSpaMode
      }),
      serverHandoffStream: encodeViaTurboStream(
        state2,
        request.signal,
        build.entry.module.streamTimeout,
        serverMode
      ),
      renderMeta: {}
    };
    try {
      return await handleDocumentRequestFunction(
        request,
        context.statusCode,
        headers,
        entryContext,
        loadContext
      );
    } catch (error2) {
      handleError(error2);
      return returnLastResortErrorResponse(error2, serverMode);
    }
  }
}
async function handleResourceRequest(serverMode, staticHandler, routeId, request, loadContext, handleError) {
  try {
    let response = await staticHandler.queryRoute(request, {
      routeId,
      requestContext: loadContext
    });
    invariant3(
      isResponse(response),
      "Expected a Response to be returned from resource route handler"
    );
    return response;
  } catch (error) {
    if (isResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
      return error;
    }
    if (isRouteErrorResponse(error)) {
      if (error) {
        handleError(error);
      }
      return errorResponseToJson(error, serverMode);
    }
    handleError(error);
    return returnLastResortErrorResponse(error, serverMode);
  }
}
function errorResponseToJson(errorResponse, serverMode) {
  return Response.json(
    serializeError(
      // @ts-expect-error This is "private" from users but intended for internal use
      errorResponse.error || new Error("Unexpected Server Error"),
      serverMode
    ),
    {
      status: errorResponse.status,
      statusText: errorResponse.statusText,
      headers: {
        "X-Remix-Error": "yes"
      }
    }
  );
}
function returnLastResortErrorResponse(error, serverMode) {
  let message = "Unexpected Server Error";
  if (serverMode !== "production" /* Production */) {
    message += `

${String(error)}`;
  }
  return new Response(message, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function unwrapResponse(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();
}

// lib/server-runtime/sessions.ts
function flash(name) {
  return `__flash_${name}__`;
}
var createSession = (initialData = {}, id = "") => {
  let map = new Map(Object.entries(initialData));
  return {
    get id() {
      return id;
    },
    get data() {
      return Object.fromEntries(map);
    },
    has(name) {
      return map.has(name) || map.has(flash(name));
    },
    get(name) {
      if (map.has(name)) return map.get(name);
      let flashName = flash(name);
      if (map.has(flashName)) {
        let value = map.get(flashName);
        map.delete(flashName);
        return value;
      }
      return void 0;
    },
    set(name, value) {
      map.set(name, value);
    },
    flash(name, value) {
      map.set(flash(name), value);
    },
    unset(name) {
      map.delete(name);
    }
  };
};
var isSession = (object) => {
  return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
};
function createSessionStorage({
  cookie: cookieArg,
  createData,
  readData,
  updateData,
  deleteData
}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      let id = cookieHeader && await cookie.parse(cookieHeader, options);
      let data2 = id && await readData(id);
      return createSession(data2 || {}, id || "");
    },
    async commitSession(session, options) {
      let { id, data: data2 } = session;
      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;
      if (id) {
        await updateData(id, data2, expires);
      } else {
        id = await createData(data2, expires);
      }
      return cookie.serialize(id, options);
    },
    async destroySession(session, options) {
      await deleteData(session.id);
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(
    cookie.isSigned,
    `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`
  );
}

// lib/server-runtime/sessions/cookieStorage.ts
function createCookieSessionStorage({ cookie: cookieArg } = {}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      return createSession(
        cookieHeader && await cookie.parse(cookieHeader, options) || {}
      );
    },
    async commitSession(session, options) {
      let serializedCookie = await cookie.serialize(session.data, options);
      if (serializedCookie.length > 4096) {
        throw new Error(
          "Cookie length will exceed browser maximum. Length: " + serializedCookie.length
        );
      }
      return serializedCookie;
    },
    async destroySession(_session, options) {
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}

// lib/server-runtime/sessions/memoryStorage.ts
function createMemorySessionStorage({ cookie } = {}) {
  let map = /* @__PURE__ */ new Map();
  return createSessionStorage({
    cookie,
    async createData(data2, expires) {
      let id = Math.random().toString(36).substring(2, 10);
      map.set(id, { data: data2, expires });
      return id;
    },
    async readData(id) {
      if (map.has(id)) {
        let { data: data2, expires } = map.get(id);
        if (!expires || expires > /* @__PURE__ */ new Date()) {
          return data2;
        }
        if (expires) map.delete(id);
      }
      return null;
    },
    async updateData(id, data2, expires) {
      map.set(id, { data: data2, expires });
    },
    async deleteData(id) {
      map.delete(id);
    }
  });
}

// lib/dom/ssr/errors.ts
function deserializeErrors2(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(
        val.status,
        val.statusText,
        val.data,
        val.internal === true
      );
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = val.stack;
            serialized[key] = error;
          } catch (e) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = val.stack;
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}




/***/ }),

/***/ "./node_modules/turbo-stream/dist/turbo-stream.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/turbo-stream/dist/turbo-stream.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
// src/utils.ts
var HOLE = -1;
var NAN = -2;
var NEGATIVE_INFINITY = -3;
var NEGATIVE_ZERO = -4;
var NULL = -5;
var POSITIVE_INFINITY = -6;
var UNDEFINED = -7;
var TYPE_BIGINT = "B";
var TYPE_DATE = "D";
var TYPE_ERROR = "E";
var TYPE_MAP = "M";
var TYPE_NULL_OBJECT = "N";
var TYPE_PROMISE = "P";
var TYPE_REGEXP = "R";
var TYPE_SET = "S";
var TYPE_SYMBOL = "Y";
var TYPE_URL = "U";
var TYPE_PREVIOUS_RESOLVED = "Z";
var Deferred = class {
  promise;
  resolve;
  reject;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function createLineSplittingTransform() {
  const decoder = new TextDecoder();
  let leftover = "";
  return new TransformStream({
    transform(chunk, controller) {
      const str = decoder.decode(chunk, { stream: true });
      const parts = (leftover + str).split("\n");
      leftover = parts.pop() || "";
      for (const part of parts) {
        controller.enqueue(part);
      }
    },
    flush(controller) {
      if (leftover) {
        controller.enqueue(leftover);
      }
    }
  });
}

// src/flatten.ts
function flatten(input) {
  const { indices } = this;
  const existing = indices.get(input);
  if (existing)
    return [existing];
  if (input === void 0)
    return UNDEFINED;
  if (input === null)
    return NULL;
  if (Number.isNaN(input))
    return NAN;
  if (input === Number.POSITIVE_INFINITY)
    return POSITIVE_INFINITY;
  if (input === Number.NEGATIVE_INFINITY)
    return NEGATIVE_INFINITY;
  if (input === 0 && 1 / input < 0)
    return NEGATIVE_ZERO;
  const index = this.index++;
  indices.set(input, index);
  stringify.call(this, input, index);
  return index;
}
function stringify(input, index) {
  const { deferred, plugins, postPlugins } = this;
  const str = this.stringified;
  const stack = [[input, index]];
  while (stack.length > 0) {
    const [input2, index2] = stack.pop();
    const partsForObj = (obj) => Object.keys(obj).map((k) => `"_${flatten.call(this, k)}":${flatten.call(this, obj[k])}`).join(",");
    let error = null;
    switch (typeof input2) {
      case "boolean":
      case "number":
      case "string":
        str[index2] = JSON.stringify(input2);
        break;
      case "bigint":
        str[index2] = `["${TYPE_BIGINT}","${input2}"]`;
        break;
      case "symbol": {
        const keyFor = Symbol.keyFor(input2);
        if (!keyFor) {
          error = new Error(
            "Cannot encode symbol unless created with Symbol.for()"
          );
        } else {
          str[index2] = `["${TYPE_SYMBOL}",${JSON.stringify(keyFor)}]`;
        }
        break;
      }
      case "object": {
        if (!input2) {
          str[index2] = `${NULL}`;
          break;
        }
        const isArray = Array.isArray(input2);
        let pluginHandled = false;
        if (!isArray && plugins) {
          for (const plugin of plugins) {
            const pluginResult = plugin(input2);
            if (Array.isArray(pluginResult)) {
              pluginHandled = true;
              const [pluginIdentifier, ...rest] = pluginResult;
              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
              if (rest.length > 0) {
                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
              }
              str[index2] += "]";
              break;
            }
          }
        }
        if (!pluginHandled) {
          let result = isArray ? "[" : "{";
          if (isArray) {
            for (let i = 0; i < input2.length; i++)
              result += (i ? "," : "") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);
            str[index2] = `${result}]`;
          } else if (input2 instanceof Date) {
            str[index2] = `["${TYPE_DATE}",${input2.getTime()}]`;
          } else if (input2 instanceof URL) {
            str[index2] = `["${TYPE_URL}",${JSON.stringify(input2.href)}]`;
          } else if (input2 instanceof RegExp) {
            str[index2] = `["${TYPE_REGEXP}",${JSON.stringify(
              input2.source
            )},${JSON.stringify(input2.flags)}]`;
          } else if (input2 instanceof Set) {
            if (input2.size > 0) {
              str[index2] = `["${TYPE_SET}",${[...input2].map((val) => flatten.call(this, val)).join(",")}]`;
            } else {
              str[index2] = `["${TYPE_SET}"]`;
            }
          } else if (input2 instanceof Map) {
            if (input2.size > 0) {
              str[index2] = `["${TYPE_MAP}",${[...input2].flatMap(([k, v]) => [
                flatten.call(this, k),
                flatten.call(this, v)
              ]).join(",")}]`;
            } else {
              str[index2] = `["${TYPE_MAP}"]`;
            }
          } else if (input2 instanceof Promise) {
            str[index2] = `["${TYPE_PROMISE}",${index2}]`;
            deferred[index2] = input2;
          } else if (input2 instanceof Error) {
            str[index2] = `["${TYPE_ERROR}",${JSON.stringify(input2.message)}`;
            if (input2.name !== "Error") {
              str[index2] += `,${JSON.stringify(input2.name)}`;
            }
            str[index2] += "]";
          } else if (Object.getPrototypeOf(input2) === null) {
            str[index2] = `["${TYPE_NULL_OBJECT}",{${partsForObj(input2)}}]`;
          } else if (isPlainObject(input2)) {
            str[index2] = `{${partsForObj(input2)}}`;
          } else {
            error = new Error("Cannot encode object with prototype");
          }
        }
        break;
      }
      default: {
        const isArray = Array.isArray(input2);
        let pluginHandled = false;
        if (!isArray && plugins) {
          for (const plugin of plugins) {
            const pluginResult = plugin(input2);
            if (Array.isArray(pluginResult)) {
              pluginHandled = true;
              const [pluginIdentifier, ...rest] = pluginResult;
              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
              if (rest.length > 0) {
                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
              }
              str[index2] += "]";
              break;
            }
          }
        }
        if (!pluginHandled) {
          error = new Error("Cannot encode function or unexpected type");
        }
      }
    }
    if (error) {
      let pluginHandled = false;
      if (postPlugins) {
        for (const plugin of postPlugins) {
          const pluginResult = plugin(input2);
          if (Array.isArray(pluginResult)) {
            pluginHandled = true;
            const [pluginIdentifier, ...rest] = pluginResult;
            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
            if (rest.length > 0) {
              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
            }
            str[index2] += "]";
            break;
          }
        }
      }
      if (!pluginHandled) {
        throw error;
      }
    }
  }
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function isPlainObject(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames;
}

// src/unflatten.ts
var globalObj = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : void 0;
function unflatten(parsed) {
  const { hydrated, values } = this;
  if (typeof parsed === "number")
    return hydrate.call(this, parsed);
  if (!Array.isArray(parsed) || !parsed.length)
    throw new SyntaxError();
  const startIndex = values.length;
  for (const value of parsed) {
    values.push(value);
  }
  hydrated.length = values.length;
  return hydrate.call(this, startIndex);
}
function hydrate(index) {
  const { hydrated, values, deferred, plugins } = this;
  let result;
  const stack = [
    [
      index,
      (v) => {
        result = v;
      }
    ]
  ];
  let postRun = [];
  while (stack.length > 0) {
    const [index2, set] = stack.pop();
    switch (index2) {
      case UNDEFINED:
        set(void 0);
        continue;
      case NULL:
        set(null);
        continue;
      case NAN:
        set(NaN);
        continue;
      case POSITIVE_INFINITY:
        set(Infinity);
        continue;
      case NEGATIVE_INFINITY:
        set(-Infinity);
        continue;
      case NEGATIVE_ZERO:
        set(-0);
        continue;
    }
    if (hydrated[index2]) {
      set(hydrated[index2]);
      continue;
    }
    const value = values[index2];
    if (!value || typeof value !== "object") {
      hydrated[index2] = value;
      set(value);
      continue;
    }
    if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const [type, b, c] = value;
        switch (type) {
          case TYPE_DATE:
            set(hydrated[index2] = new Date(b));
            continue;
          case TYPE_URL:
            set(hydrated[index2] = new URL(b));
            continue;
          case TYPE_BIGINT:
            set(hydrated[index2] = BigInt(b));
            continue;
          case TYPE_REGEXP:
            set(hydrated[index2] = new RegExp(b, c));
            continue;
          case TYPE_SYMBOL:
            set(hydrated[index2] = Symbol.for(b));
            continue;
          case TYPE_SET:
            const newSet = /* @__PURE__ */ new Set();
            hydrated[index2] = newSet;
            for (let i = 1; i < value.length; i++)
              stack.push([
                value[i],
                (v) => {
                  newSet.add(v);
                }
              ]);
            set(newSet);
            continue;
          case TYPE_MAP:
            const map = /* @__PURE__ */ new Map();
            hydrated[index2] = map;
            for (let i = 1; i < value.length; i += 2) {
              const r = [];
              stack.push([
                value[i + 1],
                (v) => {
                  r[1] = v;
                }
              ]);
              stack.push([
                value[i],
                (k) => {
                  r[0] = k;
                }
              ]);
              postRun.push(() => {
                map.set(r[0], r[1]);
              });
            }
            set(map);
            continue;
          case TYPE_NULL_OBJECT:
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index2] = obj;
            for (const key of Object.keys(b).reverse()) {
              const r = [];
              stack.push([
                b[key],
                (v) => {
                  r[1] = v;
                }
              ]);
              stack.push([
                Number(key.slice(1)),
                (k) => {
                  r[0] = k;
                }
              ]);
              postRun.push(() => {
                obj[r[0]] = r[1];
              });
            }
            set(obj);
            continue;
          case TYPE_PROMISE:
            if (hydrated[b]) {
              set(hydrated[index2] = hydrated[b]);
            } else {
              const d = new Deferred();
              deferred[b] = d;
              set(hydrated[index2] = d.promise);
            }
            continue;
          case TYPE_ERROR:
            const [, message, errorType] = value;
            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);
            hydrated[index2] = error;
            set(error);
            continue;
          case TYPE_PREVIOUS_RESOLVED:
            set(hydrated[index2] = hydrated[b]);
            continue;
          default:
            if (Array.isArray(plugins)) {
              const r = [];
              const vals = value.slice(1);
              for (let i = 0; i < vals.length; i++) {
                const v = vals[i];
                stack.push([
                  v,
                  (v2) => {
                    r[i] = v2;
                  }
                ]);
              }
              postRun.push(() => {
                for (const plugin of plugins) {
                  const result2 = plugin(value[0], ...r);
                  if (result2) {
                    set(hydrated[index2] = result2.value);
                    return;
                  }
                }
                throw new SyntaxError();
              });
              continue;
            }
            throw new SyntaxError();
        }
      } else {
        const array = [];
        hydrated[index2] = array;
        for (let i = 0; i < value.length; i++) {
          const n = value[i];
          if (n !== HOLE) {
            stack.push([
              n,
              (v) => {
                array[i] = v;
              }
            ]);
          }
        }
        set(array);
        continue;
      }
    } else {
      const object = {};
      hydrated[index2] = object;
      for (const key of Object.keys(value).reverse()) {
        const r = [];
        stack.push([
          value[key],
          (v) => {
            r[1] = v;
          }
        ]);
        stack.push([
          Number(key.slice(1)),
          (k) => {
            r[0] = k;
          }
        ]);
        postRun.push(() => {
          object[r[0]] = r[1];
        });
      }
      set(object);
      continue;
    }
  }
  while (postRun.length > 0) {
    postRun.pop()();
  }
  return result;
}

// src/turbo-stream.ts
async function decode(readable, options) {
  const { plugins } = options ?? {};
  const done = new Deferred();
  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();
  const decoder = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins
  };
  const decoded = await decodeInitial.call(decoder, reader);
  let donePromise = done.promise;
  if (decoded.done) {
    done.resolve();
  } else {
    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {
      for (const deferred of Object.values(decoder.deferred)) {
        deferred.reject(reason);
      }
      done.reject(reason);
    });
  }
  return {
    done: donePromise.then(() => reader.closed),
    value: decoded.value
  };
}
async function decodeInitial(reader) {
  const read = await reader.read();
  if (!read.value) {
    throw new SyntaxError();
  }
  let line;
  try {
    line = JSON.parse(read.value);
  } catch (reason) {
    throw new SyntaxError();
  }
  return {
    done: read.done,
    value: unflatten.call(this, line)
  };
}
async function decodeDeferred(reader) {
  let read = await reader.read();
  while (!read.done) {
    if (!read.value)
      continue;
    const line = read.value;
    switch (line[0]) {
      case TYPE_PROMISE: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.resolve(value);
        break;
      }
      case TYPE_ERROR: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.reject(value);
        break;
      }
      default:
        throw new SyntaxError();
    }
    read = await reader.read();
  }
}
function encode(input, options) {
  const { plugins, postPlugins, signal } = options ?? {};
  const encoder = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */ new Map(),
    stringified: [],
    plugins,
    postPlugins,
    signal
  };
  const textEncoder = new TextEncoder();
  let lastSentIndex = 0;
  const readable = new ReadableStream({
    async start(controller) {
      const id = flatten.call(encoder, input);
      if (Array.isArray(id)) {
        throw new Error("This should never happen");
      }
      if (id < 0) {
        controller.enqueue(textEncoder.encode(`${id}
`));
      } else {
        controller.enqueue(
          textEncoder.encode(`[${encoder.stringified.join(",")}]
`)
        );
        lastSentIndex = encoder.stringified.length - 1;
      }
      const seenPromises = /* @__PURE__ */ new WeakSet();
      while (Object.keys(encoder.deferred).length > 0) {
        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {
          if (seenPromises.has(deferred))
            continue;
          seenPromises.add(
            encoder.deferred[Number(deferredId)] = raceSignal(
              deferred,
              encoder.signal
            ).then(
              (resolved) => {
                const id2 = flatten.call(encoder, resolved);
                if (Array.isArray(id2)) {
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_PROMISE}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                    )
                  );
                  encoder.index++;
                  lastSentIndex++;
                } else if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_PROMISE}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              },
              (reason) => {
                if (!reason || typeof reason !== "object" || !(reason instanceof Error)) {
                  reason = new Error("An unknown error occurred");
                }
                const id2 = flatten.call(encoder, reason);
                if (Array.isArray(id2)) {
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_ERROR}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`
                    )
                  );
                  encoder.index++;
                  lastSentIndex++;
                } else if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_ERROR}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              }
            ).finally(() => {
              delete encoder.deferred[Number(deferredId)];
            })
          );
        }
        await Promise.race(Object.values(encoder.deferred));
      }
      await Promise.all(Object.values(encoder.deferred));
      controller.close();
    }
  });
  return readable;
}
function raceSignal(promise, signal) {
  if (!signal)
    return promise;
  if (signal.aborted)
    return Promise.reject(signal.reason || new Error("Signal was aborted."));
  const abort = new Promise((resolve, reject) => {
    signal.addEventListener("abort", (event) => {
      reject(signal.reason || new Error("Signal was aborted."));
    });
    promise.then(resolve).catch(reject);
  });
  abort.catch(() => {
  });
  return Promise.race([abort, promise]);
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App */ "./src/App.tsx");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-SYFQ2XB5.mjs");




var rootElement = document.getElementById('root');
var root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(rootElement);
root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_router_dom__WEBPACK_IMPORTED_MODULE_3__.BrowserRouter, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_App__WEBPACK_IMPORTED_MODULE_2__["default"], {}) }));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5hMmFjY2UyN2RhZTUzNzVlMWU4YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMwRztBQUNqQjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxPQUFPLGlGQUFpRixVQUFVLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLDRCQUE0QixlQUFlLDJCQUEyQix1QkFBdUIscUJBQXFCLEdBQUcsVUFBVSxvQkFBb0IsR0FBRyxhQUFhLDhCQUE4QixpQkFBaUIsY0FBYyx1QkFBdUIscUJBQXFCLG9CQUFvQix1QkFBdUIsb0JBQW9CLHVDQUF1QywrQ0FBK0MsR0FBRyxtQkFBbUI7QUFDcnNCO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7O0FDN0IxQjs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcEZhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esd0JBQXdCLFdBQVcsZ0JBQWdCO0FBQ25ELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCxtQ0FBbUMsV0FBVywyQkFBMkI7QUFDekUsNkJBQTZCLFdBQVcscUJBQXFCO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQXlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLGtCQUFrQiw0Q0FBNEM7QUFDOUQsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsOEJBQThCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdOQUFnTjtBQUNoTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osaUJBQWlCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQixtREFBbUQsbUJBQW1CLFdBQVcsK0JBQStCO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQjtBQUMvQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBa0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQWtEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTUFBaU0sR0FBRztBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBb0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTUFBME0sR0FBRztBQUM3TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQWdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQyw4RUFBOEUsaUJBQWlCLGdCQUFnQixHQUFHLGFBQWE7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxjQUFjO0FBQ2Q7QUFDQSwrQ0FBK0M7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZDQUE2QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQ0FBbUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNk1BQTZNLDBDQUEwQyxFQUFFO0FBQ3pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2S0FBNkssMENBQTBDLEVBQUU7QUFDek47QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILG1CQUFtQixXQUFXLCtCQUErQjtBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDhCQUE4QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxLQUFLLGFBQWEsS0FBSztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSxLQUFLLGFBQWEsS0FBSztBQUN4SjtBQUNBO0FBQ0EsMEZBQTBGLEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQTJDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxvREFBVztBQUN2QyxjQUFjLG1CQUFPLENBQUMsNENBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsb0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQ0FBa0Msb0JBQW9CLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLHlCQUF5QixpQkFBaUI7QUFDOUU7QUFDQSxxQ0FBcUMsc0JBQXNCLGtCQUFrQjtBQUM3RTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxvQkFBb0IsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCwyREFBMkQ7QUFDM0Qsa0RBQWtEO0FBQ2xELGlEQUFpRDtBQUNqRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFnRSxlQUFlLG9DQUFvQztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSkFBK0oseUJBQXlCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7Ozs7Ozs7O0FDM293Qkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQW9FO0FBQ3hFO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsVUFBVTtBQUNWO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQztBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7Ozs7Ozs7OztBQ3ZhVTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFLMUMsQ0FBQztBQUNGLEVBQUUsaUpBQWlFO0FBQ25FOzs7Ozs7Ozs7OztBQ3JDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFLMUMsQ0FBQztBQUNGLEVBQUUsbUlBQTBEO0FBQzVEOzs7Ozs7Ozs7OztBQ3JDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxrQ0FBa0MsS0FBSztBQUNoRztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esd0JBQXdCLFdBQVcsZ0JBQWdCO0FBQ25ELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCxtQ0FBbUMsV0FBVywyQkFBMkI7QUFDekUsNkJBQTZCLFdBQVcscUJBQXFCO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0Q7QUFDaEUsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0MsT0FBTztBQUN6RTtBQUNBLGdHQUFnRyxTQUFTLFVBQVUsc0ZBQXNGLGFBQWEsVUFBVSxVQUFVO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDRDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7O0FDL29CSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb01BQW9NO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLHVFQUF1RTtBQUMzRTtBQUNBLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdOQUFnTjtBQUNoTjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFrRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLDJCQUEyQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBLElBQUksdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7QUNoL0NVOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SEFBc0Q7QUFDeEQ7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLCtJQUFrRTtBQUNwRTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSSxxQ0FBcUM7QUFDekMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUM7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7Ozs7Ozs7O0FDM1dVOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSUFBMEQ7QUFDNUQ7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0Esc0VBQXNFO0FBQ3RFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTSxjQUFjO0FBQ2xOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsaUNBQWlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlOakMsTUFBK0Y7QUFDL0YsTUFBcUY7QUFDckYsTUFBNEY7QUFDNUYsTUFBK0c7QUFDL0csTUFBd0c7QUFDeEcsTUFBd0c7QUFDeEcsTUFBd0s7QUFDeEs7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIscUdBQW1CO0FBQy9DLHdCQUF3QixrSEFBYTs7QUFFckMsdUJBQXVCLHVHQUFhO0FBQ3BDO0FBQ0EsaUJBQWlCLCtGQUFNO0FBQ3ZCLDZCQUE2QixzR0FBa0I7O0FBRS9DLGFBQWEsMEdBQUcsQ0FBQyxvSkFBTzs7OztBQUlrSDtBQUMxSSxPQUFPLGlFQUFlLG9KQUFPLElBQUksb0pBQU8sVUFBVSxvSkFBTyxtQkFBbUIsRUFBQzs7Ozs7Ozs7Ozs7QUMxQmhFOztBQUViO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDbkZhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2pDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDVGE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNUYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzVEYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JzRjtBQUNoRTtBQUNpQztBQUNIO0FBQ0g7QUFDakQ7QUFDQSxZQUFZLHNEQUFJLENBQUMsdURBQVMsSUFBSSxVQUFVLHVEQUFLLFVBQVUsV0FBVyxzREFBSSxDQUFDLGtEQUFJLElBQUksa0VBQWtFLEdBQUcsc0RBQUksQ0FBQyxrREFBSSxJQUFJLG1GQUFtRixHQUFHLHVEQUFLLENBQUMsb0RBQU0sSUFBSSxXQUFXLHNEQUFJLENBQUMsbURBQUssSUFBSSx5QkFBeUIsc0RBQUksQ0FBQyxrRUFBUyxJQUFJLEdBQUcsR0FBRyxzREFBSSxDQUFDLG1EQUFLLElBQUksb0JBQW9CLHNEQUFJLENBQUMsZ0VBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxHQUFHO0FBQ2xaO0FBQ0EsaUVBQWUsR0FBRyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDUjZCO0FBQ2hEO0FBQ0EsWUFBWSxzREFBSSxVQUFVLHlCQUF5QjtBQUNuRDtBQUNBLGlFQUFlLFNBQVMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0p1QjtBQUNoRDtBQUNBLFlBQVksc0RBQUksVUFBVSx1QkFBdUI7QUFDakQ7QUFDQSxpRUFBZSxRQUFRLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0p4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWM7QUFDZjtBQUNBLHlDQUF5QztBQUN6QyxRQUFRLHlEQUF5RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1Q0FBdUM7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixRQUFRLDJEQUEyRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBMkM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0NBQXdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLHVCQUF1QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLEtBQUs7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLG1DQUFtQywwQkFBMEIsd0lBQXdJLDBCQUEwQjtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLLG1DQUFtQywwQkFBMEIsd0lBQXdJLDBCQUEwQjtBQUN2UDtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUJBQXVCLE1BQU0sZ0hBQWdILE1BQU07QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUssMkNBQTJDLE1BQU0sWUFBWTtBQUNoRztBQUNBLElBQUkseUNBQXlDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLElBQUksV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksSUFBSSxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLG1GQUFtRix5REFBeUQ7QUFDNUk7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFLFNBQVM7QUFDVCxVQUFVO0FBQ1Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEJBQTBCO0FBQ2hFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw4REFBOEQsV0FBVztBQUN6RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw4REFBOEQsV0FBVztBQUN6RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLFFBQVEsbUNBQW1DO0FBQzNDLFFBQVE7QUFDUjtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWUsS0FBSyxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hELFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdEQUFnRCw2QkFBNkI7QUFDN0UsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELE1BQU07QUFDTiwwQ0FBMEMsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5Q0FBeUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0JBQStCLGdDQUFnQyxJQUFJO0FBQ25FLHdDQUF3Qyx5Q0FBeUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPLHFEQUFxRCxnQkFBZ0IsRUFBRSxZQUFZO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSSxFQUFFLEtBQUssR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUIsMkJBQTJCLGtCQUFrQix3R0FBd0csa0JBQWtCO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFDQUFxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSyxjQUFjLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUSxjQUFjLFNBQVMsZ0RBQWdELFFBQVE7QUFDMUgsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw2QkFBNkIsUUFBUSx3QkFBd0IsU0FBUztBQUN0RSxJQUFJO0FBQ0o7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IsY0FBYyxTQUFTLGlEQUFpRCxRQUFRO0FBQ3pJLE1BQU07QUFDTixnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBNEQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0M7O0FBRWhDO0FBQytCO0FBQy9CLHdCQUF3QixnREFBbUI7QUFDM0M7QUFDQSw2QkFBNkIsZ0RBQW1CO0FBQ2hEO0FBQ0EsNEJBQTRCLGdEQUFtQjtBQUMvQztBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFtQjtBQUN0QztBQUNBLHdCQUF3QixnREFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3QixnREFBbUI7QUFDM0M7O0FBRUE7QUFDZ0M7QUFDaEM7QUFDQSx1QkFBdUIsV0FBVyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0NBQWtDLEVBQUUsNkNBQWlCO0FBQzdELFFBQVEseUJBQXlCLHdCQUF3QixVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QztBQUN6RTtBQUNBO0FBQ0EsU0FBUyw2Q0FBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQWlCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTLDZDQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CLFNBQVMsMENBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFpQjtBQUNsQztBQUNBLElBQUksa0RBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYyxFQUFFLDZDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQWlCO0FBQzNDLFFBQVEsa0NBQWtDLEVBQUUsNkNBQWlCO0FBQzdELFFBQVEsVUFBVSxFQUFFLDZDQUFpQjtBQUNyQyxRQUFRLDZCQUE2QjtBQUNyQztBQUNBLGtCQUFrQix5Q0FBYTtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBa0I7QUFDbkMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQW9CO0FBQ3hDO0FBQ0EsU0FBUyw2Q0FBaUI7QUFDMUI7QUFDQTtBQUNBLGVBQWUsNkNBQWlCO0FBQ2hDO0FBQ0EsMkJBQTJCLGdEQUFvQiwyQkFBMkIsZ0JBQWdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVLEVBQUUsNkNBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLElBQUk7QUFDOUMsUUFBUSxVQUFVLEVBQUUsNkNBQWlCO0FBQ3JDLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0EsU0FBUywwQ0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCLEVBQUUsNkNBQWlCO0FBQ25ELFFBQVEseUJBQXlCLEVBQUUsNkNBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGVBQWUsd0JBQXdCLFdBQVc7O0FBRTVILHdDQUF3QyxXQUFXLHFCQUFxQiw4QkFBOEIsV0FBVyxJQUFJO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpUEFBaVAsbUJBQW1CLGtCQUFrQiwyQkFBMkI7QUFDalQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYyxFQUFFLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQW9CLENBQUMsMkNBQWUsd0JBQXdCLGdEQUFvQixnQkFBZ0IsT0FBTyxpQkFBaUIsTUFBTSxvQkFBb0IsZ0RBQW9CLDRIQUE0SCxnREFBb0IsV0FBVyxtQkFBbUIsZ0RBQWdELGdEQUFvQixXQUFXLG1CQUFtQjtBQUNwZDtBQUNBLHlCQUF5QixnREFBb0IsQ0FBQywyQ0FBZSx3QkFBd0IsZ0RBQW9CLCtEQUErRCxnREFBb0IsU0FBUyxTQUFTLHVCQUF1QixvQ0FBb0MsZ0RBQW9CLFVBQVUsa0JBQWtCO0FBQ3pUO0FBQ0EsMENBQTBDLGdEQUFvQjtBQUM5RCx3Q0FBd0MsNENBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdEQUFvQiwwQkFBMEIsZ0NBQWdDLGtCQUFrQixnREFBb0I7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQsMEJBQTBCLDZDQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW9CLDBCQUEwQixxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLG1DQUFtQyxnREFBb0I7QUFDdkQsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILGdEQUFvQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVksNkNBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxVQUFVO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0EsU0FBUywwQ0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0Esb0NBQW9DLDJDQUFlO0FBQ25ELHdCQUF3Qiw4Q0FBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBLGtCQUFrQix5Q0FBYTtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBa0I7QUFDbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW9CO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQW9CO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQW9CO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QiwyQ0FBZTtBQUM3Qyx3Q0FBd0MsMkNBQWU7QUFDdkQsa0NBQWtDLDJDQUFlO0FBQ2pEO0FBQ0EsR0FBRztBQUNILGtDQUFrQywyQ0FBZTtBQUNqRCxvQ0FBb0MsMkNBQWU7QUFDbkQsd0NBQXdDLDJDQUFlO0FBQ3ZELG9CQUFvQix5Q0FBYTtBQUNqQyxpQkFBaUIsOENBQWtCO0FBQ25DLGlCQUFpQixnREFBZ0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscU5BQXFOLGlCQUFpQjtBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVSxrREFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsa0RBQXNCO0FBQ3hCLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQXNCO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsMENBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEIsMENBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLGdEQUFvQixDQUFDLDJDQUFlLHdCQUF3QixnREFBb0IsK0JBQStCLDBCQUEwQixrQkFBa0IsZ0RBQW9CLG9DQUFvQyxjQUFjLGtCQUFrQixnREFBb0IsNkJBQTZCLDRCQUE0QixrQkFBa0IsZ0RBQW9CLG1DQUFtQyxrQkFBa0Isa0JBQWtCLGdEQUFvQjtBQUMxZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGdEQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUNBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLHlDQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBZTtBQUM3QztBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBa0I7QUFDbkM7QUFDQSxNQUFNLGtEQUFzQjtBQUM1QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsa0RBQXNCO0FBQ3hCLHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CLEVBQUUsNkNBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVLEVBQUUsNkNBQWlCO0FBQ3JDLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQixxQ0FBcUMsb0NBQW9DO0FBQ3pFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCLDBDQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCLFNBQVMsbUNBQW1DLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsK0JBQStCLDBCQUEwQixrQkFBa0IsZ0RBQW9CLDZCQUE2QixrQ0FBa0M7QUFDM007QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QixnREFBb0IsdUJBQXVCLHVCQUF1QixrQkFBa0IsZ0RBQW9CO0FBQ2pJO0FBQ0EsdUNBQXVDLDRDQUFnQjtBQUN2RDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEUsZ0RBQWdELG9CQUFvQjtBQUNwRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1EQUFtRCxpQkFBaUI7QUFDcEUsaURBQWlELHdCQUF3QjtBQUN6RSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFvQiwwQkFBMEIsd0NBQXdDO0FBQ25IO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQW9CLDBCQUEwQiwwQkFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBZTtBQUNqQixTQUFTLGlEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0VBQW9FO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUSxzRkFBc0YsZUFBZTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEMsMkJBQTJCLE9BQU87QUFDbEMsMkJBQTJCLE9BQU87QUFDbEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ2dDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFlLEVBQUUsRUFFaEI7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLFVBQVU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0MsSUFBSTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ2dDO0FBQ007O0FBRXRDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ04sdUJBQXVCO0FBQ3ZCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCLDBDQUEwQyxnREFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBb0IsQ0FBQywyQ0FBZSxtQ0FBbUMsZ0RBQW9CO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyQkFBMkIsZ0RBQW9CLENBQUMsMkNBQWUsbUNBQW1DLGdEQUFvQixDQUFDLDJDQUFlLHdCQUF3QixnREFBb0I7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsWUFBWTtBQUNaLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEUsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0M7O0FBRWhDO0FBQ2dDOztBQUVoQztBQUNnQztBQUNoQyx1Q0FBdUMsNENBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxQ0FBcUMsZ0RBQW9CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8saUJBQWlCLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQixrQkFBa0IscUNBQXFDLGtCQUFrQixnREFBb0IsU0FBUyxTQUFTLG9CQUFvQjtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixnREFBb0IsU0FBUyxTQUFTLG9CQUFvQjtBQUM5RSxvQkFBb0IsZ0RBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsV0FBVyxZQUFZLGtCQUFrQixnREFBb0IsK0JBQStCLGdEQUFvQixXQUFXLGtCQUFrQixtQkFBbUIsZ0RBQW9CO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQW9CLHlDQUF5QyxnREFBb0IsK0JBQStCLGdEQUFvQixXQUFXLFNBQVMsd0RBQXdELDRDQUE0QyxnREFBb0I7QUFDclM7O0FBRUE7QUFDZ0M7QUFDaEM7QUFDQSx5QkFBeUIsZ0RBQW9CLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLGdEQUFvQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8saUJBQWlCLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCxnREFBb0Isa0NBQWtDLHdCQUF3QjtBQUN4TTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQW9CLDJDQUEyQyxnREFBb0I7QUFDcEgsUUFBUSxJQUFJLHVCQUF1QjtBQUNuQztBQUNBLHNDQUFzQyxnREFBb0IsMkNBQTJDLGdEQUFvQjtBQUN6SCxRQUFRLElBQUksZUFBZTtBQUMzQjtBQUNBLGdEQUFnRCxnREFBb0IsMkNBQTJDLGdEQUFvQjtBQUNuSSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsaUxBQWlMLHVCQUF1QjtBQUN4TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyx5QkFBeUIsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJLHlDQUF5QyxNQUFNLGFBQWEsU0FBUztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRLGtCQUFrQixTQUFTLEVBQUUsS0FBSyxnRUFBZ0UsU0FBUyxJQUFJLEtBQUs7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCLElBQUk7QUFDakUsa0NBQWtDLDJCQUEyQixJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSxFQUFFLGVBQWU7QUFDcEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFvQjtBQUMzQztBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBaUI7QUFDMUMsMENBQTBDLDJDQUFlO0FBQ3pELDRDQUE0QywyQ0FBZTtBQUMzRCxRQUFRLDREQUE0RDtBQUNwRSxZQUFZLHlDQUFhO0FBQ3pCLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQWlEO0FBQ3pELFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0EsbUJBQW1CLDBDQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsQ0FBQywyQ0FBZSxzQ0FBc0MsZ0RBQW9CLFlBQVksMkJBQTJCLHVCQUF1QjtBQUNyTCxPQUFPLFdBQVcsa0RBQWtELGdEQUFvQixzQkFBc0IsY0FBYyxvQkFBb0IsZ0RBQW9CLFdBQVcsY0FBYztBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVEsU0FBUztBQUNqQixnQkFBZ0IsMENBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFvQiwwQkFBMEIsaUNBQWlDO0FBQ3hHO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQyxvREFBb0QsMkNBQWU7QUFDbkUsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQyxRQUFRLHNCQUFzQjtBQUM5QiwwQkFBMEIsMENBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFvQixDQUFDLDJDQUFlLGdEQUFnRCxnREFBb0IsV0FBVyw2REFBNkQsOENBQThDLGdEQUFvQixXQUFXLHFEQUFxRCw4QkFBOEIsV0FBVztBQUNwWDtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFvQixXQUFXLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsQ0FBQywyQ0FBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBb0IsU0FBUyxvQ0FBb0M7QUFDOUY7QUFDQTtBQUNBLDZCQUE2QixnREFBb0IsWUFBWSxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnREFBb0IsV0FBVyw0Q0FBNEM7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQW9CO0FBQ25EO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBb0IsV0FBVyw4Q0FBOEM7QUFDeEcsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQXVEO0FBQy9ELFFBQVEsMENBQTBDO0FBQ2xELFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsMENBQWM7QUFDckMsaUZBQWlGLGtCQUFrQiw0REFBNEQsdUNBQXVDO0FBQ3RNLHlFQUF5RSxxQkFBcUIsRUFBRSxhQUFhO0FBQzdHLGtEQUFrRCxrQ0FBa0Msc0NBQXNDLE9BQU8sRUFBRSw0QkFBNEIsNkJBQTZCO0FBQzVMLEVBQUU7QUFDRiw0Q0FBNEMsT0FBTyxPQUFPO0FBQzFEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQyxFQUFFLGlDQUFpQywrQkFBK0IsUUFBUSxNQUFNOztBQUV0SCxTQUFTLHNDQUFzQyxFQUFFO0FBQ2pELDJCQUEyQixnREFBb0IsQ0FBQywyQ0FBZSx3QkFBd0IsZ0RBQW9CO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkNBQTZDLGdEQUFvQixDQUFDLDJDQUFlLDBDQUEwQyxnREFBb0I7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0RBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLHlDQUFjO0FBQ2pDO0FBQ0EsZ0RBQWdELGlDQUFpQztBQUNqRjtBQUNBO0FBQ0EsOEJBQThCLDJDQUFnQjtBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBbUI7QUFDcEM7QUFDQSxNQUFNLGtEQUF1QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsa0RBQXVCO0FBQ3pCLHlCQUF5QixnREFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNELG1CQUFtQix5Q0FBYztBQUNqQztBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBZ0I7QUFDOUM7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsOENBQW1CO0FBQ3BDO0FBQ0EsTUFBTSxrREFBdUI7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFLGtEQUF1QjtBQUN6Qix5QkFBeUIsZ0RBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLDJDQUFnQjtBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBbUI7QUFDcEM7QUFDQSxNQUFNLGtEQUF1QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsa0RBQXVCO0FBQ3pCLHlCQUF5QixnREFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSxXQUFXLEVBQUUsNkNBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdEQUFxQixDQUFDLDJDQUFnQiw4QkFBOEIsZ0RBQXFCLHNCQUFzQixZQUFZO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQSxzQkFBc0IsNkNBQWtCO0FBQ3hDLFVBQVUsa0NBQWtDLEVBQUUsNkNBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJCQUEyQixnREFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIsNkNBQWtCO0FBQ3ZDLFFBQVEsV0FBVyxFQUFFLDZDQUFrQjtBQUN2QztBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QyxlQUFlLDBDQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixnREFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLElBQUk7QUFDdEM7QUFDQSxVQUFVLElBQUksdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsWUFBWSw2Q0FBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QyxTQUFTLDhDQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBYztBQUM3Qyw4QkFBOEIseUNBQWM7QUFDNUM7QUFDQSxxQkFBcUIsMENBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLFFBQVEsU0FBUztBQUNqQixRQUFRLFdBQVcsRUFBRSw2Q0FBa0I7QUFDdkM7QUFDQSxTQUFTLDhDQUFtQjtBQUM1QiwrQkFBK0I7QUFDL0IsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLElBQUk7QUFDaEQsUUFBUSxXQUFXLEVBQUUsNkNBQWtCO0FBQ3ZDLHFCQUFxQiw2Q0FBa0I7QUFDdkM7QUFDQTtBQUNBLGVBQWUsNENBQTRDLFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixRQUFRLFNBQVM7QUFDakI7QUFDQSxvQkFBb0IsNkNBQWtCO0FBQ3RDLGNBQWMsNkNBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdDQUFhO0FBQ2hDLG9DQUFvQywyQ0FBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBaUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhLDhDQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBZTtBQUNuQyx1QkFBdUIsNkNBQWtCO0FBQ3pDO0FBQ0EsK0JBQStCLGdEQUFxQixTQUFTLDRDQUE0QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLDBDQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixRQUFRLFNBQVM7QUFDakIsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBLFFBQVEsV0FBVyxFQUFFLDZDQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksOENBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsOEdBQThHLE1BQU07QUFDcEg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLGtEQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTCxJQUFJLGtEQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrREFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEIsRUFBRSw0Q0FBaUI7QUFDbkIsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVEsVUFBVTtBQUNsQixFQUFFLDRDQUFpQjtBQUNuQixtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUUsNENBQWlCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2Q0FBNkM7QUFDN0Msa0JBQWtCLDZDQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsS0FBSyxFQUFFO0FBQzlFO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLHlCQUF5QixnREFBcUIsQ0FBQywyQ0FBZ0Isd0JBQXdCLGdEQUFxQiwrQkFBK0IsMEJBQTBCLGtCQUFrQixnREFBcUIsb0NBQW9DLGNBQWMsa0JBQWtCLGdEQUFxQiw2QkFBNkIsd0JBQXdCLGtCQUFrQixnREFBcUIsbUNBQW1DLFNBQVMsMEJBQTBCLGtCQUFrQixnREFBcUI7QUFDOWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGdEQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnREFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRKQUE0SixtQkFBbUI7QUFDL0s7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtKQUErSixtQkFBbUIsSUFBSSxlQUFlO0FBQ3JNO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwSkFBMEosTUFBTTtBQUNoSztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQTJEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBcUIsQ0FBQywyQ0FBZ0Isd0JBQXdCLGdEQUFxQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGdEQUFxQix1QkFBdUIsaUNBQWlDLGtCQUFrQixnREFBcUI7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0RBQXFCLENBQUMsMkNBQWdCLHdCQUF3QixnREFBcUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUM7QUFDakMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLHlDQUFjO0FBQ2xDLDBCQUEwQix5Q0FBYztBQUN4QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esb0JBQW9CO0FBQ3BCLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkIsZ0RBQXFCLDhCQUE4QixnQ0FBZ0Msa0JBQWtCLGdEQUFxQixtQkFBbUIsMkJBQTJCO0FBQ25NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RCwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUMsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBSyxpQkFBaUIsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxpREFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyx5T0FBeU8sU0FBUyx3RUFBd0UsU0FBUztBQUNwVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBNkM7QUFDN0UsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzQzs7QUFFdEM7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQXVEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFDQUFxQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ04sNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixRQUFRLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGNBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLG9CQUFvQixJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsU0FBUyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWtIRTs7Ozs7Ozs7Ozs7Ozs7OztBQ2w1U0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usc0JBQXNCLElBQUksMkJBQTJCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWSxLQUFLLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCLFlBQVksSUFBSSx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBLG1DQUFtQyxpREFBaUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEMsWUFBWTtBQUNaLCtCQUErQixVQUFVLElBQUksaUJBQWlCO0FBQzlELFlBQVk7QUFDWiwrQkFBK0IsU0FBUyxJQUFJLDRCQUE0QjtBQUN4RSxZQUFZO0FBQ1osK0JBQStCLFlBQVksSUFBSTtBQUMvQztBQUNBLGNBQWMsR0FBRyw2QkFBNkI7QUFDOUMsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDLFNBQVMsSUFBSSw0REFBNEQ7QUFDMUcsY0FBYztBQUNkLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDLFNBQVMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLFlBQVk7QUFDWiwrQkFBK0IsYUFBYSxJQUFJLE9BQU87QUFDdkQ7QUFDQSxZQUFZO0FBQ1osK0JBQStCLFdBQVcsSUFBSSwrQkFBK0I7QUFDN0U7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQSxZQUFZO0FBQ1osK0JBQStCLGlCQUFpQixHQUFHLEVBQUUscUJBQXFCO0FBQzFFLFlBQVk7QUFDWiw0QkFBNEIsRUFBRSxxQkFBcUI7QUFDbkQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFO0FBQ0EsbUNBQW1DLGlEQUFpRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQSxpQ0FBaUMsaURBQWlEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFFBQVE7QUFDUjtBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxFQUFFLFdBQVcsTUFBTSx1QkFBdUIsSUFBSSxPQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwwQ0FBMEMsYUFBYSxFQUFFLFdBQVcsR0FBRztBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEVBQUUsV0FBVyxJQUFJLE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsRUFBRSxXQUFXLE1BQU0sdUJBQXVCLElBQUksT0FBTztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMENBQTBDLFdBQVcsRUFBRSxXQUFXLEdBQUc7QUFDckU7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxFQUFFLFdBQVcsSUFBSSxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUlFOzs7Ozs7O1VDaHFCRjtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7Ozs7Ozs7Ozs7Ozs7OztBQ0FnRDtBQUNGO0FBQ3RCO0FBQ3lCO0FBQ2pEO0FBQ0EsV0FBVyw0REFBVTtBQUNyQixZQUFZLHNEQUFJLENBQUMsMkRBQWEsSUFBSSxVQUFVLHNEQUFJLENBQUMsNENBQUcsSUFBSSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL3NyYy9pbmRleC5zY3NzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLWNsaWVudC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvY29va2llL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vc3JjL2luZGV4LnNjc3M/NzM5ZSIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9zcmMvQXBwLnRzeCIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zLy4vc3JjL3BhZ2VzL0Fib3V0UGFnZS9BYm91dFBhZ2UudHN4Iiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9zcmMvcGFnZXMvTWFpblBhZ2UvTWFpblBhZ2UudHN4Iiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvY2h1bmstU1lGUTJYQjUubWpzIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvLi9ub2RlX21vZHVsZXMvdHVyYm8tc3RyZWFtL2Rpc3QvdHVyYm8tc3RyZWFtLm1qcyIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3JlYWN0X2xlc3NvbnMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yZWFjdF9sZXNzb25zL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vcmVhY3RfbGVzc29ucy8uL3NyYy9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCoge1xuICBwYWRkaW5nOiAwO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIG1hcmdpbi10b3A6IDEwcHg7XG59XG5cbi5hcHAge1xuICBmb250LXNpemU6IDMwcHg7XG59XG5cbi5idXR0b24ge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMGZmO1xuICBjb2xvcjogd2hpdGU7XG4gIGJvcmRlcjogMDtcbiAgcGFkZGluZzogMTVweCAyMHB4O1xuICBtaW4td2lkdGg6IDE1MHB4O1xuICBmb250LXNpemU6IDE2cHg7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zIGVhc2Utb3V0O1xuICBib3gtc2hhZG93OiAxcHggMXB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMik7XG59YCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvaW5kZXguc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLFVBQUE7RUFDQSxzQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZ0JBQUE7QUFDRjs7QUFFQTtFQUNFLGVBQUE7QUFDRjs7QUFFQTtFQUNFLHlCQUFBO0VBQ0EsWUFBQTtFQUNBLFNBQUE7RUFDQSxrQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLGtDQUFBO0VBQ0EsMENBQUE7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIqIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogMTBweDtcXG59XFxuXFxuLmFwcCB7XFxuICBmb250LXNpemU6IDMwcHg7XFxufVxcblxcbi5idXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDBmZjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMDtcXG4gIHBhZGRpbmc6IDE1cHggMjBweDtcXG4gIG1pbi13aWR0aDogMTUwcHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zIGVhc2Utb3V0O1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1jbGllbnQuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBmaW5kSG9vayhmaWJlciwgaWQpIHtcbiAgICAgIGZvciAoZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlOyBudWxsICE9PSBmaWJlciAmJiAwIDwgaWQ7IClcbiAgICAgICAgKGZpYmVyID0gZmliZXIubmV4dCksIGlkLS07XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aClcbiAgICAgICAgY29uc29sZS53YXJuKFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoXG4gICAgICAgID8gKCh1cGRhdGVkW25ld1BhdGhbaW5kZXhdXSA9IHVwZGF0ZWRbb2xkS2V5XSksXG4gICAgICAgICAgaXNBcnJheUltcGwodXBkYXRlZClcbiAgICAgICAgICAgID8gdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKVxuICAgICAgICAgICAgOiBkZWxldGUgdXBkYXRlZFtvbGRLZXldKVxuICAgICAgICA6ICh1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoXG4gICAgICAgICAgICBvYmpbb2xkS2V5XSxcbiAgICAgICAgICAgIG9sZFBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgaW5kZXggKyAxXG4gICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpID8gdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKSA6IGRlbGV0ZSB1cGRhdGVkW2tleV0sXG4gICAgICAgICAgdXBkYXRlZFxuICAgICAgICApO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFN1c3BlbmRJbXBsKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRFcnJvckltcGwoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXIodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDIoKSB7fVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KCkge31cbiAgICBmdW5jdGlvbiBzZXRUb1NvcnRlZFN0cmluZyhzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpIHtcbiAgICAgIHJvb3QuY29udGV4dCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0ICYmXG4gICAgICAgICh1cGRhdGVDb250YWluZXJTeW5jKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpLCBmbHVzaFN5bmNXb3JrJDEoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNvbHZlRmFtaWx5KSB7XG4gICAgICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXM7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTeW5jV29yayQxKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFJlZnJlc2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICAhbm9kZSB8fFxuICAgICAgICAoMSAhPT0gbm9kZS5ub2RlVHlwZSAmJiA5ICE9PSBub2RlLm5vZGVUeXBlICYmIDExICE9PSBub2RlLm5vZGVUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tT3duZXIob3duZXIpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiID09PSB0eXBlb2Ygb3duZXIudGFnXG4gICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcilcbiAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3duZXIubmFtZVxuICAgICAgICAgID8gb3duZXIubmFtZVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gXCJDYWNoZVwiO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgcmV0dXJuIFwiRGVoeWRyYXRlZEZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IHR5cGUucmVuZGVyKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAgIChcIlwiICE9PSBmaWJlciA/IFwiRm9yd2FyZFJlZihcIiArIGZpYmVyICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gXCJSb290XCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gXCJUZXh0XCI7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID8gXCJTdHJpY3RNb2RlXCIgOiBcIk1vZGVcIjtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJldHVybiBcIlNjb3BlXCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gXCJUcmFjaW5nTWFya2VyXCI7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0eXBlID0gZmliZXIuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAobnVsbCAhPSB0eXBlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHR5cGUubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZVtpXS5uYW1lKSByZXR1cm4gdHlwZVtpXS5uYW1lO1xuICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlci5yZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlci5yZXR1cm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKSksIGZpYmVyO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyLCAhMSkpLCBmaWJlclxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMCkpLCBmaWJlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgICAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm8sXG4gICAgICAgICAgICAgICAgICBlbnYgPSBlbnRyeS5lbnY7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICAgICAgZW50cnkubmFtZSArIChlbnYgPyBcIiBbXCIgKyBlbnYgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHJldHVybiBudWxsICE9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lcihvd25lcikgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnQgPyBcIlwiIDogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudCA9IHByZXZpb3VzRmliZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJydW5XaXRoRmliZXJJbkRFViBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG4gICAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSBmb3IgKDsgbm9kZS5yZXR1cm47ICkgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZpYmVyID0gbm9kZTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiYgKG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm4pLFxuICAgICAgICAgICAgKGZpYmVyID0gbm9kZS5yZXR1cm4pO1xuICAgICAgICB3aGlsZSAoZmliZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbmVhcmVzdE1vdW50ZWQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIG51bGwgPT09IHN1c3BlbnNlU3RhdGUgJiZcbiAgICAgICAgICAoKGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBmaWJlciAmJiAoc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHN1c3BlbnNlU3RhdGUpIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICAgICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG4gICAgICAgIGlmIChudWxsID09PSBhbHRlcm5hdGUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICByZXR1cm4gYWx0ZXJuYXRlICE9PSBmaWJlciA/IG51bGwgOiBmaWJlcjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGEgPSBmaWJlciwgYiA9IGFsdGVybmF0ZTsgOyApIHtcbiAgICAgICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEEpIGJyZWFrO1xuICAgICAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50Qikge1xuICAgICAgICAgIGIgPSBwYXJlbnRBLnJldHVybjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gYikge1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgICAgICBmb3IgKHBhcmVudEIgPSBwYXJlbnRBLmNoaWxkOyBwYXJlbnRCOyApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRCID09PSBhKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBmaWJlcjtcbiAgICAgICAgICAgIGlmIChwYXJlbnRCID09PSBiKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBhbHRlcm5hdGU7XG4gICAgICAgICAgICBwYXJlbnRCID0gcGFyZW50Qi5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikgKGEgPSBwYXJlbnRBKSwgKGIgPSBwYXJlbnRCKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgZGlkRmluZENoaWxkID0gITEsIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7IF9jaGlsZDsgKSB7XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgICAgZm9yIChfY2hpbGQgPSBwYXJlbnRCLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgzICE9PSBhLnRhZylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgcmV0dXJuIGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEgPyBmaWJlciA6IGFsdGVybmF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZykgcmV0dXJuIG5vZGU7XG4gICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgdGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gdGFnKSByZXR1cm4gdGFnO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICAgICAgMCA+IGluZGV4JGpzY29tcCQwXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgcG9wLlwiKVxuICAgICAgICA6IChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC5cIiksXG4gICAgICAgICAgKGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0pLFxuICAgICAgICAgICh2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIChmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIGluZGV4JGpzY29tcCQwLS0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gICAgICBpbmRleCRqc2NvbXAkMCsrO1xuICAgICAgdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBjdXJzb3IuY3VycmVudDtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gZmliZXI7XG4gICAgICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICAgbnVsbCA9PT0gYyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICAgICAgdmFyIG5leHRSb290Q29udGV4dCA9IG5leHRSb290SW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgICBzd2l0Y2ggKG5leHRSb290Q29udGV4dCkge1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgbmV4dFJvb3RDb250ZXh0ID0gOSA9PT0gbmV4dFJvb3RDb250ZXh0ID8gXCIjZG9jdW1lbnRcIiA6IFwiI2ZyYWdtZW50XCI7XG4gICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IChuZXh0Um9vdEluc3RhbmNlID1cbiAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50KVxuICAgICAgICAgICAgPyAobmV4dFJvb3RJbnN0YW5jZSA9IG5leHRSb290SW5zdGFuY2UubmFtZXNwYWNlVVJJKVxuICAgICAgICAgICAgICA/IGdldE93bkhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpXG4gICAgICAgICAgICAgIDogSG9zdENvbnRleHROYW1lc3BhY2VOb25lXG4gICAgICAgICAgICA6IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKG5leHRSb290SW5zdGFuY2UgPVxuICAgICAgICAgICAgICA4ID09PSBuZXh0Um9vdENvbnRleHRcbiAgICAgICAgICAgICAgICA/IG5leHRSb290SW5zdGFuY2UucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgIDogbmV4dFJvb3RJbnN0YW5jZSksXG4gICAgICAgICAgICAobmV4dFJvb3RDb250ZXh0ID0gbmV4dFJvb3RJbnN0YW5jZS50YWdOYW1lKSxcbiAgICAgICAgICAgIChuZXh0Um9vdEluc3RhbmNlID0gbmV4dFJvb3RJbnN0YW5jZS5uYW1lc3BhY2VVUkkpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXh0Um9vdEluc3RhbmNlID0gZ2V0T3duSG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSkpLFxuICAgICAgICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IGdldENoaWxkSG9zdENvbnRleHRQcm9kKFxuICAgICAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbmV4dFJvb3RDb250ZXh0XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN3aXRjaCAobmV4dFJvb3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgICAgICBuZXh0Um9vdEluc3RhbmNlID0gSG9zdENvbnRleHROYW1lc3BhY2VTdmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IEhvc3RDb250ZXh0TmFtZXNwYWNlTWF0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBuZXh0Um9vdEluc3RhbmNlID0gSG9zdENvbnRleHROYW1lc3BhY2VOb25lO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dFJvb3RDb250ZXh0ID0gbmV4dFJvb3RDb250ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0Um9vdENvbnRleHQgPSB1cGRhdGVkQW5jZXN0b3JJbmZvRGV2KG51bGwsIG5leHRSb290Q29udGV4dCk7XG4gICAgICBuZXh0Um9vdENvbnRleHQgPSB7XG4gICAgICAgIGNvbnRleHQ6IG5leHRSb290SW5zdGFuY2UsXG4gICAgICAgIGFuY2VzdG9ySW5mbzogbmV4dFJvb3RDb250ZXh0XG4gICAgICB9O1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgcHVzaChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QoY29udGV4dC5jb250ZXh0LCB0eXBlKTtcbiAgICAgIHR5cGUgPSB1cGRhdGVkQW5jZXN0b3JJbmZvRGV2KGNvbnRleHQuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICAgIG5leHRDb250ZXh0ID0geyBjb250ZXh0OiBuZXh0Q29udGV4dCwgYW5jZXN0b3JJbmZvOiB0eXBlIH07XG4gICAgICBjb250ZXh0ICE9PSBuZXh0Q29udGV4dCAmJlxuICAgICAgICAocHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKSxcbiAgICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKSwgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcikpO1xuICAgICAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgICAgICAocG9wKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKSxcbiAgICAgICAgKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gTm90UGVuZGluZ1RyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSwgITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRm9ybSBmaWVsZCB2YWx1ZXMgKHZhbHVlLCBjaGVja2VkLCBkZWZhdWx0VmFsdWUsIG9yIGRlZmF1bHRDaGVja2VkIHByb3BzKSBtdXN0IGJlIHN0cmluZ3MsIG5vdCAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHJldHVybiAhMTtcbiAgICAgIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICAgICAgaWYgKGhvb2suaXNEaXNhYmxlZCkgcmV0dXJuICEwO1xuICAgICAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiBodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LWRldnRvb2xzXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICEwXG4gICAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICAocmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscykpLCAoaW5qZWN0ZWRIb29rID0gaG9vayk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuXCIsIGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9vay5jaGVja0RDRSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkaWRFcnJvciA9IDEyOCA9PT0gKHJvb3QuY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3dpdGNoIChldmVudFByaW9yaXR5KSB7XG4gICAgICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QoXG4gICAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5LFxuICAgICAgICAgICAgZGlkRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9nJDEgJiZcbiAgICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCwgbmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gICAgICB4ID4+Pj0gMDtcbiAgICAgIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyh4KSAvIExOMikgfCAwKSkgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuICAgICAgaWYgKGxhbmUgJiAxKSByZXR1cm4gXCJTeW5jSHlkcmF0aW9uTGFuZVwiO1xuICAgICAgaWYgKGxhbmUgJiAyKSByZXR1cm4gXCJTeW5jXCI7XG4gICAgICBpZiAobGFuZSAmIDQpIHJldHVybiBcIklucHV0Q29udGludW91c0h5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA4KSByZXR1cm4gXCJJbnB1dENvbnRpbnVvdXNcIjtcbiAgICAgIGlmIChsYW5lICYgMTYpIHJldHVybiBcIkRlZmF1bHRIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMzIpIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgIGlmIChsYW5lICYgNjQpIHJldHVybiBcIlRyYW5zaXRpb25IeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNDE5NDE3NikgcmV0dXJuIFwiVHJhbnNpdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA2MjkxNDU2MCkgcmV0dXJuIFwiUmV0cnlcIjtcbiAgICAgIGlmIChsYW5lICYgNjcxMDg4NjQpIHJldHVybiBcIlNlbGVjdGl2ZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMzQyMTc3MjgpIHJldHVybiBcIklkbGVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMjY4NDM1NDU2KSByZXR1cm4gXCJJZGxlXCI7XG4gICAgICBpZiAobGFuZSAmIDUzNjg3MDkxMikgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICBpZiAobGFuZSAmIDEwNzM3NDE4MjQpIHJldHVybiBcIkRlZmVycmVkXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA0MTk0MTc2O1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICAgIHJldHVybiAxMzQyMTc3Mjg7XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSByZXR1cm4gMDtcbiAgICAgIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gICAgICByb290ID0gMCAhPT0gcm9vdC5maW5pc2hlZExhbmVzO1xuICAgICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiAxMzQyMTc3Mjc7XG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKChwZW5kaW5nTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBwZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgICAgICA6ICgocGluZ2VkTGFuZXMgJj0gbm9uSWRsZVBlbmRpbmdMYW5lcyksXG4gICAgICAgICAgICAgIDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSkpXG4gICAgICAgIDogKChub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSk7XG4gICAgICByZXR1cm4gMCA9PT0gbmV4dExhbmVzXG4gICAgICAgID8gMFxuICAgICAgICA6IDAgIT09IHdpcExhbmVzICYmXG4gICAgICAgICAgICB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgICAgICgoc3VzcGVuZGVkTGFuZXMgPSBuZXh0TGFuZXMgJiAtbmV4dExhbmVzKSxcbiAgICAgICAgICAgICh3YXJtTGFuZXMgPSB3aXBMYW5lcyAmIC13aXBMYW5lcyksXG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAod2FybUxhbmVzICYgNDE5NDE3NikpKVxuICAgICAgICAgID8gd2lwTGFuZXNcbiAgICAgICAgICA6IG5leHRMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCByZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgMCA9PT1cbiAgICAgICAgKHJvb3QucGVuZGluZ0xhbmVzICZcbiAgICAgICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgICAgIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBzd2l0Y2ggKGxhbmUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1ZTM7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC0xXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0VHJhbnNpdGlvbkxhbmUgJiA0MTk0MTc2KSAmJiAobmV4dFRyYW5zaXRpb25MYW5lID0gMTI4KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gICAgICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRSZXRyeUxhbmUgJiA2MjkxNDU2MCkgJiYgKG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgICAgIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gICAgICByZXR1cm4gbGFuZU1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgICAgIDI2ODQzNTQ1NiAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkTGFuZXMsXG4gICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICAgICAgcm9vdC53YXJtTGFuZXMgPSAwO1xuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gICAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gICAgICBmb3IgKFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gICAgICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IDA7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSAtMTtcbiAgICAgICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG4gICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsLCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleF07XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gICAgICAwICE9PSBzdXNwZW5kZWRSZXRyeUxhbmVzICYmXG4gICAgICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgICAgICAwICE9PSByb290LnRhZyAmJlxuICAgICAgICAocm9vdC5zdXNwZW5kZWRMYW5lcyB8PVxuICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gICAgICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IDMxIC0gY2x6MzIoc3Bhd25lZExhbmUpO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8XG4gICAgICAgIDEwNzM3NDE4MjQgfFxuICAgICAgICAoZW50YW5nbGVkTGFuZXMgJiA0MTk0MjE4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHZhciByb290RW50YW5nbGVkTGFuZXMgPSAocm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICBmb3IgKHJvb3QgPSByb290LmVudGFuZ2xlbWVudHM7IHJvb3RFbnRhbmdsZWRMYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocm9vdEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgKGxhbmUgJiBlbnRhbmdsZWRMYW5lcykgfCAocm9vdFtpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykgJiZcbiAgICAgICAgICAocm9vdFtpbmRleF0gfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgICByb290RW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChyb290ID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgcm9vdFtpbmRleF0uYWRkKGZpYmVyKTtcbiAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICAgICAgICAgIHJvb3QgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGluZGV4ID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgICAgICAgMCA8IGluZGV4LnNpemUgJiZcbiAgICAgICAgICAgIChpbmRleC5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIG1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpIHx8XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleC5jbGVhcigpKTtcbiAgICAgICAgICBsYW5lcyAmPSB+cm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICAgICAgbGFuZXMgJj0gLWxhbmVzO1xuICAgICAgcmV0dXJuIDAgIT09IERpc2NyZXRlRXZlbnRQcmlvcml0eSAmJiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPCBsYW5lc1xuICAgICAgICA/IDAgIT09IENvbnRpbnVvdXNFdmVudFByaW9yaXR5ICYmIENvbnRpbnVvdXNFdmVudFByaW9yaXR5IDwgbGFuZXNcbiAgICAgICAgICA/IDAgIT09IChsYW5lcyAmIDEzNDIxNzcyNylcbiAgICAgICAgICAgID8gRGVmYXVsdEV2ZW50UHJpb3JpdHlcbiAgICAgICAgICAgIDogSWRsZUV2ZW50UHJpb3JpdHlcbiAgICAgICAgICA6IENvbnRpbnVvdXNFdmVudFByaW9yaXR5XG4gICAgICAgIDogRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKSB7XG4gICAgICB2YXIgdXBkYXRlUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgaWYgKDAgIT09IHVwZGF0ZVByaW9yaXR5KSByZXR1cm4gdXBkYXRlUHJpb3JpdHk7XG4gICAgICB1cGRhdGVQcmlvcml0eSA9IHdpbmRvdy5ldmVudDtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IHVwZGF0ZVByaW9yaXR5XG4gICAgICAgID8gRGVmYXVsdEV2ZW50UHJpb3JpdHlcbiAgICAgICAgOiBnZXRFdmVudFByaW9yaXR5KHVwZGF0ZVByaW9yaXR5LnR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkocHJpb3JpdHksIGZuKSB7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmlvcml0eSksIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoRGVsZXRlZEluc3RhbmNlKG5vZGUpIHtcbiAgICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxQcm9wc0tleV07XG4gICAgICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuICAgICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXldO1xuICAgICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gICAgICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gICAgICBpZiAodGFyZ2V0SW5zdCkgcmV0dXJuIHRhcmdldEluc3Q7XG4gICAgICBmb3IgKHZhciBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlOyBwYXJlbnROb2RlOyApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh0YXJnZXRJbnN0ID1cbiAgICAgICAgICAgIHBhcmVudE5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgICAgIHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcmVudE5vZGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSB0YXJnZXRJbnN0LmNoaWxkIHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gcGFyZW50Tm9kZSAmJiBudWxsICE9PSBwYXJlbnROb2RlLmNoaWxkKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICBudWxsICE9PSB0YXJnZXROb2RlO1xuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKChwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICAgICAgaWYgKFxuICAgICAgICAobm9kZSA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHwgbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSlcbiAgICAgICkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICA1ID09PSB0YWcgfHxcbiAgICAgICAgICA2ID09PSB0YWcgfHxcbiAgICAgICAgICAxMyA9PT0gdGFnIHx8XG4gICAgICAgICAgMjYgPT09IHRhZyB8fFxuICAgICAgICAgIDI3ID09PSB0YWcgfHxcbiAgICAgICAgICAzID09PSB0YWdcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAgICAgdmFyIHRhZyA9IGluc3QudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gICAgICB0aHJvdyBFcnJvcihcImdldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXNvdXJjZXNGcm9tUm9vdChyb290KSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0gcm9vdFtpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5XTtcbiAgICAgIHJlc291cmNlcyB8fFxuICAgICAgICAocmVzb3VyY2VzID0gcm9vdFtpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5XSA9XG4gICAgICAgICAgeyBob2lzdGFibGVTdHlsZXM6IG5ldyBNYXAoKSwgaG9pc3RhYmxlU2NyaXB0czogbmV3IE1hcCgpIH0pO1xuICAgICAgcmV0dXJuIHJlc291cmNlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya05vZGVBc0hvaXN0YWJsZShub2RlKSB7XG4gICAgICBub2RlW2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSA9ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gICAgICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUgKyBcIkNhcHR1cmVcIiwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLlwiLFxuICAgICAgICAgIHJlZ2lzdHJhdGlvbk5hbWVcbiAgICAgICAgKTtcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBkZXBlbmRlbmNpZXM7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgICBcIm9uRG91YmxlQ2xpY2tcIiA9PT0gcmVnaXN0cmF0aW9uTmFtZSAmJlxuICAgICAgICAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICBmb3IgKFxuICAgICAgICByZWdpc3RyYXRpb25OYW1lID0gMDtcbiAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7XG4gICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUrK1xuICAgICAgKVxuICAgICAgICBhbGxOYXRpdmVFdmVudHMuYWRkKGRlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHxcbiAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMub25JbnB1dCB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIChcInNlbGVjdFwiID09PSB0YWdOYW1lXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGBvbkNoYW5nZWAuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICAgICAgKSk7XG4gICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLmNoZWNrZWQgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwKTtcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgXCIsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZU9uQ3VzdG9tQ29tcG9uZW50KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gICAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgIGlmICghMSA9PT0gZXhwZWN0ZWQpIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXhwZWN0ZWQgPyB2b2lkIDAgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKFwiXCIgPT09IG5vZGUgJiYgITAgPT09IGV4cGVjdGVkKSByZXR1cm4gITA7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oZXhwZWN0ZWQsIG5hbWUpO1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gXCJcIiArIGV4cGVjdGVkID8gZXhwZWN0ZWQgOiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpXG4gICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgIT09IHByZWZpeCAmJiBcImFyaWEtXCIgIT09IHByZWZpeCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKG5vZGUsIG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICByZXR1cm4gY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKSwgdmFsdWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgICAgIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGVsZW0gPSBlbGVtLm5vZGVOYW1lKSAmJlxuICAgICAgICBcImlucHV0XCIgPT09IGVsZW0udG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAoXCJjaGVja2JveFwiID09PSB0eXBlIHx8IFwicmFkaW9cIiA9PT0gdHlwZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICAgICAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/IFwiY2hlY2tlZFwiIDogXCJ2YWx1ZVwiLFxuICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcbiAgICAgICAgICB2YWx1ZUZpZWxkXG4gICAgICAgICk7XG4gICAgICBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24obm9kZVt2YWx1ZUZpZWxkXSk7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gXCJcIiArIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgICBpZiAoXG4gICAgICAgICFub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpICYmXG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkZXNjcmlwdG9yICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlc2NyaXB0b3Iuc2V0XG4gICAgICApIHtcbiAgICAgICAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgIHNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNrKG5vZGUpIHtcbiAgICAgIG5vZGUuX3ZhbHVlVHJhY2tlciB8fCAobm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuICExO1xuICAgICAgdmFyIHRyYWNrZXIgPSBub2RlLl92YWx1ZVRyYWNrZXI7XG4gICAgICBpZiAoIXRyYWNrZXIpIHJldHVybiAhMDtcbiAgICAgIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgbm9kZSAmJlxuICAgICAgICAodmFsdWUgPSBpc0NoZWNrYWJsZShub2RlKVxuICAgICAgICAgID8gbm9kZS5jaGVja2VkXG4gICAgICAgICAgICA/IFwidHJ1ZVwiXG4gICAgICAgICAgICA6IFwiZmFsc2VcIlxuICAgICAgICAgIDogbm9kZS52YWx1ZSk7XG4gICAgICBub2RlID0gdmFsdWU7XG4gICAgICByZXR1cm4gbm9kZSAhPT0gbGFzdFZhbHVlID8gKHRyYWNrZXIuc2V0VmFsdWUobm9kZSksICEwKSA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudCA6IHZvaWQgMCk7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGRvYykgcmV0dXJuIG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb2MuYm9keTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoXG4gICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXNSZWdleCxcbiAgICAgICAgZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgICB2b2lkIDAgPT09IHByb3BzLmNoZWNrZWQgfHxcbiAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuIElucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCBcIkEgY29tcG9uZW50XCIsXG4gICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICB2b2lkIDAgPT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgIHByb3BzLnR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSW5wdXQoXG4gICAgICBlbGVtZW50LFxuICAgICAgdmFsdWUsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICBsYXN0RGVmYXVsdFZhbHVlLFxuICAgICAgY2hlY2tlZCxcbiAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgdHlwZSxcbiAgICAgIG5hbWVcbiAgICApIHtcbiAgICAgIGVsZW1lbnQubmFtZSA9IFwiXCI7XG4gICAgICBudWxsICE9IHR5cGUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGVcbiAgICAgICAgPyAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih0eXBlLCBcInR5cGVcIiksIChlbGVtZW50LnR5cGUgPSB0eXBlKSlcbiAgICAgICAgOiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGUpIHtcbiAgICAgICAgICBpZiAoKDAgPT09IHZhbHVlICYmIFwiXCIgPT09IGVsZW1lbnQudmFsdWUpIHx8IGVsZW1lbnQudmFsdWUgIT0gdmFsdWUpXG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBlbGVtZW50LnZhbHVlICE9PSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIChlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgKFwic3VibWl0XCIgIT09IHR5cGUgJiYgXCJyZXNldFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gICAgICBudWxsICE9IHZhbHVlXG4gICAgICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKVxuICAgICAgICA6IG51bGwgIT0gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgPyBzZXREZWZhdWx0VmFsdWUoZWxlbWVudCwgdHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShkZWZhdWx0VmFsdWUpKVxuICAgICAgICAgIDogbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlICYmIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gICAgICBudWxsID09IGNoZWNrZWQgJiZcbiAgICAgICAgbnVsbCAhPSBkZWZhdWx0Q2hlY2tlZCAmJlxuICAgICAgICAoZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9ICEhZGVmYXVsdENoZWNrZWQpO1xuICAgICAgbnVsbCAhPSBjaGVja2VkICYmXG4gICAgICAgIChlbGVtZW50LmNoZWNrZWQgPVxuICAgICAgICAgIGNoZWNrZWQgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjaGVja2VkICYmXG4gICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoZWNrZWQpO1xuICAgICAgbnVsbCAhPSBuYW1lICYmXG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBuYW1lXG4gICAgICAgID8gKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24obmFtZSwgXCJuYW1lXCIpLFxuICAgICAgICAgIChlbGVtZW50Lm5hbWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShuYW1lKSkpXG4gICAgICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0SW5wdXQoXG4gICAgICBlbGVtZW50LFxuICAgICAgdmFsdWUsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICBjaGVja2VkLFxuICAgICAgZGVmYXVsdENoZWNrZWQsXG4gICAgICB0eXBlLFxuICAgICAgbmFtZSxcbiAgICAgIGlzSHlkcmF0aW5nXG4gICAgKSB7XG4gICAgICBudWxsICE9IHR5cGUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odHlwZSwgXCJ0eXBlXCIpLCAoZWxlbWVudC50eXBlID0gdHlwZSkpO1xuICAgICAgaWYgKG51bGwgIT0gdmFsdWUgfHwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEoXG4gICAgICAgICAgICAoXCJzdWJtaXRcIiAhPT0gdHlwZSAmJiBcInJlc2V0XCIgIT09IHR5cGUpIHx8XG4gICAgICAgICAgICAodm9pZCAwICE9PSB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgbnVsbCAhPSBkZWZhdWx0VmFsdWUgPyBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShkZWZhdWx0VmFsdWUpIDogXCJcIjtcbiAgICAgICAgdmFsdWUgPSBudWxsICE9IHZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICBpc0h5ZHJhdGluZyB8fCB2YWx1ZSA9PT0gZWxlbWVudC52YWx1ZSB8fCAoZWxlbWVudC52YWx1ZSA9IHZhbHVlKTtcbiAgICAgICAgZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNoZWNrZWQgPSBudWxsICE9IGNoZWNrZWQgPyBjaGVja2VkIDogZGVmYXVsdENoZWNrZWQ7XG4gICAgICBjaGVja2VkID1cbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJlxuICAgICAgICAhIWNoZWNrZWQ7XG4gICAgICBlbGVtZW50LmNoZWNrZWQgPSBpc0h5ZHJhdGluZyA/IGVsZW1lbnQuY2hlY2tlZCA6ICEhY2hlY2tlZDtcbiAgICAgIGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSAhIWNoZWNrZWQ7XG4gICAgICBudWxsICE9IG5hbWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24obmFtZSwgXCJuYW1lXCIpLCAoZWxlbWVudC5uYW1lID0gbmFtZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgICAgIChcIm51bWJlclwiID09PSB0eXBlICYmIGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSA9PT0gbm9kZSkgfHxcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPT09IFwiXCIgKyB2YWx1ZSB8fFxuICAgICAgICAobm9kZS5kZWZhdWx0VmFsdWUgPSBcIlwiICsgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvblByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgICBudWxsID09IHByb3BzLnZhbHVlICYmXG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gJiYgbnVsbCAhPT0gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICA/IFJlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICBudWxsID09IGNoaWxkIHx8XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkludmFsaWRDaGlsZCB8fFxuICAgICAgICAgICAgICAgICgoZGlkV2FybkludmFsaWRDaGlsZCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiBQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IG51bGwgPT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgfHxcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkSW5uZXJIVE1MID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICApKSk7XG4gICAgICBudWxsID09IHByb3BzLnNlbGVjdGVkIHx8XG4gICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2Ygc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LlwiXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuICAgICAgcmV0dXJuIG93bmVyTmFtZVxuICAgICAgICA/IFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgb3duZXJOYW1lICsgXCJgLlwiXG4gICAgICAgIDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgIG5vZGUgPSBub2RlLm9wdGlvbnM7XG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgbXVsdGlwbGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgbXVsdGlwbGVbXCIkXCIgKyBwcm9wVmFsdWVbaV1dID0gITA7XG4gICAgICAgIGZvciAocHJvcFZhbHVlID0gMDsgcHJvcFZhbHVlIDwgbm9kZS5sZW5ndGg7IHByb3BWYWx1ZSsrKVxuICAgICAgICAgIChpID0gbXVsdGlwbGUuaGFzT3duUHJvcGVydHkoXCIkXCIgKyBub2RlW3Byb3BWYWx1ZV0udmFsdWUpKSxcbiAgICAgICAgICAgIG5vZGVbcHJvcFZhbHVlXS5zZWxlY3RlZCAhPT0gaSAmJiAobm9kZVtwcm9wVmFsdWVdLnNlbGVjdGVkID0gaSksXG4gICAgICAgICAgICBpICYmIHNldERlZmF1bHRTZWxlY3RlZCAmJiAobm9kZVtwcm9wVmFsdWVdLmRlZmF1bHRTZWxlY3RlZCA9ICEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BWYWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHByb3BWYWx1ZSk7XG4gICAgICAgIG11bHRpcGxlID0gbnVsbDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZVtpXS52YWx1ZSA9PT0gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBub2RlW2ldLnNlbGVjdGVkID0gITA7XG4gICAgICAgICAgICBzZXREZWZhdWx0U2VsZWN0ZWQgJiYgKG5vZGVbaV0uZGVmYXVsdFNlbGVjdGVkID0gITApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBtdWx0aXBsZSB8fCBub2RlW2ldLmRpc2FibGVkIHx8IChtdWx0aXBsZSA9IG5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG51bGwgIT09IG11bHRpcGxlICYmIChtdWx0aXBsZS5zZWxlY3RlZCA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTZWxlY3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAgICAgZm9yIChlbGVtZW50ID0gMDsgZWxlbWVudCA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgZWxlbWVudCsrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2VsZW1lbnRdO1xuICAgICAgICBpZiAobnVsbCAhPSBwcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWVJc0FycmF5ID0gaXNBcnJheUltcGwocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICBwcm9wcy5tdWx0aXBsZSAmJiAhcHJvcE5hbWVJc0FycmF5XG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgYG11bHRpcGxlYCBpcyB0cnVlLiVzXCIsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAhcHJvcHMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgcHJvcE5hbWVJc0FycmF5ICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgdmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lc1wiLFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCJcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlVGV4dGFyZWFQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICB2b2lkIDAgPT09IHByb3BzLmRlZmF1bHRWYWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuIFRleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhIGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCBcIkEgY29tcG9uZW50XCJcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gITApKTtcbiAgICAgIG51bGwgIT0gcHJvcHMuY2hpbGRyZW4gJiZcbiAgICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRhcmVhKGVsZW1lbnQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAoKHZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKSxcbiAgICAgICAgdmFsdWUgIT09IGVsZW1lbnQudmFsdWUgJiYgKGVsZW1lbnQudmFsdWUgPSB2YWx1ZSksXG4gICAgICAgIG51bGwgPT0gZGVmYXVsdFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlICE9PSB2YWx1ZSAmJiAoZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlID1cbiAgICAgICAgbnVsbCAhPSBkZWZhdWx0VmFsdWUgPyBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShkZWZhdWx0VmFsdWUpIDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdFRleHRhcmVhKGVsZW1lbnQsIHZhbHVlLCBkZWZhdWx0VmFsdWUsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCA9PSB2YWx1ZSkge1xuICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbikge1xuICAgICAgICAgIGlmIChudWxsICE9IGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoMSA8IGNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIpO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PSBkZWZhdWx0VmFsdWUgJiYgKGRlZmF1bHRWYWx1ZSA9IFwiXCIpO1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUodmFsdWUpO1xuICAgICAgZWxlbWVudC5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICBjaGlsZHJlbiA9PT0gZGVmYXVsdFZhbHVlICYmXG4gICAgICAgIFwiXCIgIT09IGNoaWxkcmVuICYmXG4gICAgICAgIG51bGwgIT09IGNoaWxkcmVuICYmXG4gICAgICAgIChlbGVtZW50LnZhbHVlID0gY2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzICYmXG4gICAgICAgIDAgPT09IG5vZGUuc2VydmVyVGFpbC5sZW5ndGggJiZcbiAgICAgICAgMSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgMyA8IG5vZGUuZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiAxNSAtIGluZGVudFxuICAgICAgICA/IGZpbmROb3RhYmxlTm9kZShub2RlLmNoaWxkcmVuWzBdLCBpbmRlbnQpXG4gICAgICAgIDogbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZW50YXRpb24oaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIgIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRlZChpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIisgXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCItIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyVHlwZShmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBmaWJlci50eXBlO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBcIkxhenlcIjtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGZpYmVyLnR5cGUpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGw7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnR5cGUucmVuZGVyKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHROb2RlKGNvbnRlbnQsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIG5lZWRzRXNjYXBpbmcudGVzdChjb250ZW50KVxuICAgICAgICA/ICgoY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKSxcbiAgICAgICAgICBjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aCAtIDJcbiAgICAgICAgICAgID8gOCA+IG1heExlbmd0aFxuICAgICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDcpICsgJy4uLlwifSdcbiAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCIpXG4gICAgICAgIDogY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgID8gJ3tcIi4uLlwifSdcbiAgICAgICAgICAgIDogY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKSArIFwiLi4uXCJcbiAgICAgICAgICA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gc2VydmVyUHJvcHMpXG4gICAgICAgIHJldHVybiBhZGRlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgXCJcXG5cIjtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyUHJvcHMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZmlyc3REaWZmID0gMDtcbiAgICAgICAgICBmaXJzdERpZmYgPCBzZXJ2ZXJQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBmaXJzdERpZmYgPCBjbGllbnRUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgIHNlcnZlclByb3BzLmNoYXJDb2RlQXQoZmlyc3REaWZmKSA9PT1cbiAgICAgICAgICAgIGNsaWVudFRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpO1xuICAgICAgICAgIGZpcnN0RGlmZisrXG4gICAgICAgICk7XG4gICAgICAgIGZpcnN0RGlmZiA+IG1heExlbmd0aCAtIDggJiZcbiAgICAgICAgICAxMCA8IGZpcnN0RGlmZiAmJlxuICAgICAgICAgICgoY2xpZW50VGV4dCA9IFwiLi4uXCIgKyBjbGllbnRUZXh0LnNsaWNlKGZpcnN0RGlmZiAtIDgpKSxcbiAgICAgICAgICAoc2VydmVyUHJvcHMgPSBcIi4uLlwiICsgc2VydmVyUHJvcHMuc2xpY2UoZmlyc3REaWZmIC0gOCkpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhZGRlZChpbmRlbnQpICtcbiAgICAgICAgICBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJQcm9wcywgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgXCJcXG5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmplY3QpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgICAgICAgcmV0dXJuIHAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKSksXG4gICAgICAgICAgICB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgICAgICA6IHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDQpICsgJy4uLlwiJ1xuICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh2YWx1ZS50eXBlKSlcbiAgICAgICAgICAgICAgPyBcIjxcIiArIG1heExlbmd0aCArIFwiPlwiXG4gICAgICAgICAgICAgIDogXCI8Li4uPlwiO1xuICAgICAgICAgIHZhciBuYW1lID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKFwiT2JqZWN0XCIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IDI7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uUHJvcE5hbWUgPSBKU09OLnN0cmluZ2lmeShwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAganNvblByb3BOYW1lICE9PSAnXCInICsgcHJvcE5hbWUgKyAnXCInICYmXG4gICAgICAgICAgICAgICAgICAocHJvcE5hbWUgPSBqc29uUHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICAgICAgICB2YWx1ZVtwcm9wTmFtZV0sXG4gICAgICAgICAgICAgICAgICAxNSA+IG1heExlbmd0aCA/IG1heExlbmd0aCA6IDE1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0ganNvblByb3BOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoMCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbmFtZSArPSBcIlwiID09PSBuYW1lID8gXCIuLi5cIiA6IFwiLCAuLi5cIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9XG4gICAgICAgICAgICAgICAgICAoXCJcIiA9PT0gbmFtZSA/IFwiXCIgOiBcIixcIikgKyBwcm9wTmFtZSArIFwiOlwiICsganNvblByb3BOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBuYW1lICsgXCJ9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyBtYXhMZW5ndGhcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlIHx8IG5lZWRzRXNjYXBpbmcudGVzdCh2YWx1ZSlcbiAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCAtIDIpICsgXCJ9XCJcbiAgICAgICAgOiB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICdcIi4uLlwiJ1xuICAgICAgICAgICAgOiAnXCInICsgdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNSkgKyAnLi4uXCInXG4gICAgICAgICAgOiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBwcm9wcywgcm93UHJlZml4KSB7XG4gICAgICB2YXIgcmVtYWluaW5nUm93TGVuZ3RoID0gMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHR5cGUubGVuZ3RoLFxuICAgICAgICBwcm9wZXJ0aWVzID0gW10sXG4gICAgICAgIHByb3BOYW1lO1xuICAgICAgZm9yIChwcm9wTmFtZSBpbiBwcm9wcylcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdLFxuICAgICAgICAgICAgMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHByb3BOYW1lLmxlbmd0aCAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbWFpbmluZ1Jvd0xlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAwID09PSBwcm9wZXJ0aWVzLmxlbmd0aFxuICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiXG4gICAgICAgIDogMCA8IHJlbWFpbmluZ1Jvd0xlbmd0aFxuICAgICAgICAgID8gcm93UHJlZml4ICsgXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBwcm9wZXJ0aWVzLmpvaW4oXCIgXCIpICsgXCI+XFxuXCJcbiAgICAgICAgICA6IHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiICBcIiArXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmpvaW4oXCJcXG5cIiArIHJvd1ByZWZpeCArIFwiICBcIikgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoY2xpZW50T2JqZWN0LCBzZXJ2ZXJPYmplY3QsIGluZGVudCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBcIlwiLFxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzID0gYXNzaWduKHt9LCBzZXJ2ZXJPYmplY3QpLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gY2xpZW50T2JqZWN0KVxuICAgICAgICBpZiAoY2xpZW50T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgIGRlbGV0ZSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGluZGVudCAtIHByb3BOYW1lLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKGNsaWVudE9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCk7XG4gICAgICAgICAgc2VydmVyT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICAgICAgICAgICAgPyAoKG1heExlbmd0aCA9IGRlc2NyaWJlVmFsdWUoc2VydmVyT2JqZWN0W3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIiksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBtYXhMZW5ndGggKyBcIlxcblwiKSlcbiAgICAgICAgICAgIDogKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRQcm9wVmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMpXG4gICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSAmJlxuICAgICAgICAgICgoY2xpZW50T2JqZWN0ID0gZGVzY3JpYmVWYWx1ZShcbiAgICAgICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbX3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIDIgKiBpbmRlbnQgLSBfcHJvcE5hbWUubGVuZ3RoIC0gMlxuICAgICAgICAgICkpLFxuICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICByZW1vdmVkKGluZGVudCkgKyBfcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRPYmplY3QgKyBcIlxcblwiKSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiLFxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKHByb3BOYW1lJGpzY29tcCQwIGluIHNlcnZlclByb3BzKVxuICAgICAgICBzZXJ2ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuc2V0KFxuICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwXG4gICAgICAgICAgKTtcbiAgICAgIGlmICgxID09PSBzZXJ2ZXJQcm9wTmFtZXMuc2l6ZSAmJiBzZXJ2ZXJQcm9wTmFtZXMuaGFzKFwiY2hpbGRyZW5cIikpXG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjbGllbnRQcm9wcyxcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpXG4gICAgICAgICk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lMiBpbiBjbGllbnRQcm9wcylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjbGllbnRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUyKSAmJlxuICAgICAgICAgICAgXCJjaGlsZHJlblwiICE9PSBfcHJvcE5hbWUyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAxMjAgLSAyICogKGluZGVudCArIDEpIC0gX3Byb3BOYW1lMi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BOYW1lcy5nZXQoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHNlcnZlclByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lcy5kZWxldGUoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgdmFyIHByb3BOYW1lJGpzY29tcCQwID0gY2xpZW50UHJvcHNbX3Byb3BOYW1lMl07XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcHNbc2VydmVyUHJvcE5hbWVdO1xuICAgICAgICAgICAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUoc2VydmVyUHJvcE5hbWUpICYmXG4gICAgICAgICAgICAgICgyIDwgT2JqZWN0LmtleXMocHJvcE5hbWUkanNjb21wJDApLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIDIgPCBPYmplY3Qua2V5cyhzZXJ2ZXJQcm9wTmFtZSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLTEgPCBjbGllbnRQcm9wVmFsdWUuaW5kZXhPZihcIi4uLlwiKSB8fFxuICAgICAgICAgICAgICAgIC0xIDwgbWF4TGVuZ3RoJGpzY29tcCQwLmluZGV4T2YoXCIuLi5cIikpXG4gICAgICAgICAgICAgICAgPyAoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj17e1xcblwiICtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKyAyXG4gICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwifX1cXG5cIilcbiAgICAgICAgICAgICAgICA6ICgoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFByb3BWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAgICAgKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZVByb3BWYWx1ZShjbGllbnRQcm9wc1tfcHJvcE5hbWUyXSwgbWF4TGVuZ3RoJGpzY29tcCQwKSArXG4gICAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIHNlcnZlclByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICBwcm9wTmFtZSArXG4gICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoc2VydmVyUHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50ID1cbiAgICAgICAgICBcIlwiID09PSBjb250ZW50XG4gICAgICAgICAgICA/IGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICAgICAgOiBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICB9XG4gICAgICB0eXBlID0gc2VydmVyUHJvcHMuY2hpbGRyZW47XG4gICAgICBjbGllbnRQcm9wcyA9IGNsaWVudFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgKSB7XG4gICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgICAgKVxuICAgICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCIgKyBjbGllbnRQcm9wcztcbiAgICAgICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKHNlcnZlclByb3BOYW1lcywgXCJcIiArIHR5cGUsIGluZGVudCArIDEpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgIClcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgbnVsbCA9PSB0eXBlXG4gICAgICAgICAgICA/IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgbnVsbCwgaW5kZW50ICsgMSlcbiAgICAgICAgICAgIDogY29udGVudCArIGRlc2NyaWJlVGV4dERpZmYoXCJcIiArIGNsaWVudFByb3BzLCB2b2lkIDAsIGluZGVudCArIDEpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IFwiXCI7XG4gICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgZmliZXI7IClcbiAgICAgICAgICAodHlwZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICB2YXIgc2tpcFRvTm9kZSA9IGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpO1xuICAgICAgaWYgKFxuICAgICAgICBza2lwVG9Ob2RlICE9PSBub2RlICYmXG4gICAgICAgICgxICE9PSBub2RlLmNoaWxkcmVuLmxlbmd0aCB8fCBub2RlLmNoaWxkcmVuWzBdICE9PSBza2lwVG9Ob2RlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiICsgZGVzY3JpYmVOb2RlKHNraXBUb05vZGUsIGluZGVudCArIDEpXG4gICAgICAgICk7XG4gICAgICBza2lwVG9Ob2RlID0gXCJcIjtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSBub2RlLmZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVidWdJbmZvW2ldLm5hbWU7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICgoc2tpcFRvTm9kZSArPVxuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyBzZXJ2ZXJDb21wb25lbnROYW1lICsgXCI+XFxuXCIpLFxuICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgICB9XG4gICAgICBkZWJ1Z0luZm8gPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgaWYgKDYgPT09IG5vZGUuZmliZXIudGFnKVxuICAgICAgICAoZGVidWdJbmZvID0gZGVzY3JpYmVUZXh0RGlmZihpLCBub2RlLnNlcnZlclByb3BzLCBpbmRlbnQpKSwgaW5kZW50Kys7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgKChzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVzY3JpYmVGaWJlclR5cGUobm9kZS5maWJlcikpLFxuICAgICAgICBudWxsICE9PSBzZXJ2ZXJDb21wb25lbnROYW1lKVxuICAgICAgKVxuICAgICAgICBpZiAodm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzKSB7XG4gICAgICAgICAgZGVidWdJbmZvID0gaW5kZW50O1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogZGVidWdJbmZvIC0gc2VydmVyQ29tcG9uZW50TmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBpKVxuICAgICAgICAgICAgaWYgKGkuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKGlbcHJvcE5hbWVdLCAxNSk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIC4uLlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgXCIgKyBwcm9wTmFtZSArIFwiPVwiICsgcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnSW5mbyA9XG4gICAgICAgICAgICBpbmRlbnRhdGlvbihkZWJ1Z0luZm8pICtcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgY29udGVudCArXG4gICAgICAgICAgICBcIj5cXG5cIjtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbnVsbCA9PT0gbm9kZS5zZXJ2ZXJQcm9wc1xuICAgICAgICAgICAgPyAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBpbmRlbnQrKylcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTaG91bGQgbm90IGhhdmUgbWF0Y2hlZCBhIG5vbiBIb3N0VGV4dCBmaWJlciB0byBhIFRleHQgbm9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRWxlbWVudERpZmYoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgIG5vZGUuc2VydmVyUHJvcHMsXG4gICAgICAgICAgICAgICAgICBpbmRlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBpbmRlbnQrKyk7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIuY2hpbGQ7XG4gICAgICBmb3IgKFxuICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lID0gMDtcbiAgICAgICAgaSAmJiBzZXJ2ZXJDb21wb25lbnROYW1lIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgIClcbiAgICAgICAgKG1heExlbmd0aCA9IG5vZGUuY2hpbGRyZW5bc2VydmVyQ29tcG9uZW50TmFtZV0pLFxuICAgICAgICAgIG1heExlbmd0aC5maWJlciA9PT0gaVxuICAgICAgICAgICAgPyAoKHByb3BOYW1lICs9IGRlc2NyaWJlTm9kZShtYXhMZW5ndGgsIGluZGVudCkpLFxuICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lKyspXG4gICAgICAgICAgICA6IChwcm9wTmFtZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihpLCBpbmRlbnQpKSxcbiAgICAgICAgICAoaSA9IGkuc2libGluZyk7XG4gICAgICBpICYmXG4gICAgICAgIDAgPCBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAocHJvcE5hbWUgKz0gaW5kZW50YXRpb24oaW5kZW50KSArIFwiLi4uXFxuXCIpO1xuICAgICAgaSA9IG5vZGUuc2VydmVyVGFpbDtcbiAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHMgJiYgaW5kZW50LS07XG4gICAgICBmb3IgKG5vZGUgPSAwOyBub2RlIDwgaS5sZW5ndGg7IG5vZGUrKylcbiAgICAgICAgKHNlcnZlckNvbXBvbmVudE5hbWUgPSBpW25vZGVdKSxcbiAgICAgICAgICAocHJvcE5hbWUgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgPyBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgKHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZVRleHROb2RlKHNlcnZlckNvbXBvbmVudE5hbWUsIDEyMCAtIDIgKiBpbmRlbnQpICtcbiAgICAgICAgICAgICAgICAgIFwiXFxuXCIpXG4gICAgICAgICAgICAgIDogcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS50eXBlLFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHNraXBUb05vZGUgKyBkZWJ1Z0luZm8gKyBwcm9wTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVEaWZmKHJvb3ROb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gXCJcXG5cXG5cIiArIGRlc2NyaWJlTm9kZShyb290Tm9kZSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUFuY2VzdG9ycyhhbmNlc3RvciwgY2hpbGQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBmaWJlciA9IGNoaWxkLCBub2RlID0gbnVsbCwgZGlzdGFuY2VGcm9tTGVhZiA9IDA7IGZpYmVyOyApXG4gICAgICAgIGZpYmVyID09PSBhbmNlc3RvciAmJiAoZGlzdGFuY2VGcm9tTGVhZiA9IDApLFxuICAgICAgICAgIChub2RlID0ge1xuICAgICAgICAgICAgZmliZXI6IGZpYmVyLFxuICAgICAgICAgICAgY2hpbGRyZW46IG51bGwgIT09IG5vZGUgPyBbbm9kZV0gOiBbXSxcbiAgICAgICAgICAgIHNlcnZlclByb3BzOlxuICAgICAgICAgICAgICBmaWJlciA9PT0gY2hpbGQgPyBwcm9wcyA6IGZpYmVyID09PSBhbmNlc3RvciA/IG51bGwgOiB2b2lkIDAsXG4gICAgICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmKyssXG4gICAgICAgICAgKGZpYmVyID0gZmliZXIucmV0dXJuKTtcbiAgICAgIHJldHVybiBudWxsICE9PSBub2RlID8gZGVzY3JpYmVEaWZmKG5vZGUpLnJlcGxhY2VBbGwoL15bKy1dL2dtLCBcIj5cIikgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVkQW5jZXN0b3JJbmZvRGV2KG9sZEluZm8sIHRhZykge1xuICAgICAgb2xkSW5mbyA9IGFzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mb0Rldik7XG4gICAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcgfTtcbiAgICAgIC0xICE9PSBpblNjb3BlVGFncy5pbmRleE9mKHRhZykgJiZcbiAgICAgICAgKChvbGRJbmZvLmFUYWdJblNjb3BlID0gbnVsbCksXG4gICAgICAgIChvbGRJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsKSxcbiAgICAgICAgKG9sZEluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsKSk7XG4gICAgICAtMSAhPT0gYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAmJiAob2xkSW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGwpO1xuICAgICAgLTEgIT09IHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAmJlxuICAgICAgICBcImFkZHJlc3NcIiAhPT0gdGFnICYmXG4gICAgICAgIFwiZGl2XCIgIT09IHRhZyAmJlxuICAgICAgICBcInBcIiAhPT0gdGFnICYmXG4gICAgICAgICgob2xkSW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbCksXG4gICAgICAgIChvbGRJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbCkpO1xuICAgICAgb2xkSW5mby5jdXJyZW50ID0gaW5mbztcbiAgICAgIFwiZm9ybVwiID09PSB0YWcgJiYgKG9sZEluZm8uZm9ybVRhZyA9IGluZm8pO1xuICAgICAgXCJhXCIgPT09IHRhZyAmJiAob2xkSW5mby5hVGFnSW5TY29wZSA9IGluZm8pO1xuICAgICAgXCJidXR0b25cIiA9PT0gdGFnICYmIChvbGRJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvKTtcbiAgICAgIFwibm9iclwiID09PSB0YWcgJiYgKG9sZEluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvKTtcbiAgICAgIFwicFwiID09PSB0YWcgJiYgKG9sZEluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvKTtcbiAgICAgIFwibGlcIiA9PT0gdGFnICYmIChvbGRJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvKTtcbiAgICAgIGlmIChcImRkXCIgPT09IHRhZyB8fCBcImR0XCIgPT09IHRhZykgb2xkSW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgICBcIiNkb2N1bWVudFwiID09PSB0YWcgfHwgXCJodG1sXCIgPT09IHRhZ1xuICAgICAgICA/IChvbGRJbmZvLmNvbnRhaW5lclRhZ0luU2NvcGUgPSBudWxsKVxuICAgICAgICA6IG9sZEluZm8uY29udGFpbmVyVGFnSW5TY29wZSB8fCAob2xkSW5mby5jb250YWluZXJUYWdJblNjb3BlID0gaW5mbyk7XG4gICAgICByZXR1cm4gb2xkSW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJoclwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwib3B0aW9uXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJvcHRncm91cFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwiI3RleHRcIiA9PT0gdGFnXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9wdGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIFwib3B0aW9uXCIgPT09IHRhZyB8fCBcIiN0ZXh0XCIgPT09IHRhZztcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHJldHVybiBcIiN0ZXh0XCIgPT09IHRhZztcbiAgICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwidGhcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRkXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzdHlsZVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic2NyaXB0XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiID09PSB0YWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcInRyXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzdHlsZVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic2NyaXB0XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiID09PSB0YWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgICByZXR1cm4gXCJjb2xcIiA9PT0gdGFnIHx8IFwidGVtcGxhdGVcIiA9PT0gdGFnO1xuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJjYXB0aW9uXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJjb2xncm91cFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGJvZHlcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRmb290XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0aGVhZFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic3R5bGVcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInNjcmlwdFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGVtcGxhdGVcIiA9PT0gdGFnXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJiYXNlXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJiYXNlZm9udFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwiYmdzb3VuZFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwibGlua1wiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwibWV0YVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGl0bGVcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcIm5vc2NyaXB0XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJub2ZyYW1lc1wiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic3R5bGVcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInNjcmlwdFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGVtcGxhdGVcIiA9PT0gdGFnXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICByZXR1cm4gXCJoZWFkXCIgPT09IHRhZyB8fCBcImJvZHlcIiA9PT0gdGFnIHx8IFwiZnJhbWVzZXRcIiA9PT0gdGFnO1xuICAgICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcbiAgICAgICAgICByZXR1cm4gXCJmcmFtZVwiID09PSB0YWc7XG4gICAgICAgIGNhc2UgXCIjZG9jdW1lbnRcIjpcbiAgICAgICAgICByZXR1cm4gXCJodG1sXCIgPT09IHRhZztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJoMVwiOlxuICAgICAgICBjYXNlIFwiaDJcIjpcbiAgICAgICAgY2FzZSBcImgzXCI6XG4gICAgICAgIGNhc2UgXCJoNFwiOlxuICAgICAgICBjYXNlIFwiaDVcIjpcbiAgICAgICAgY2FzZSBcImg2XCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiaDFcIiAhPT0gcGFyZW50VGFnICYmXG4gICAgICAgICAgICBcImgyXCIgIT09IHBhcmVudFRhZyAmJlxuICAgICAgICAgICAgXCJoM1wiICE9PSBwYXJlbnRUYWcgJiZcbiAgICAgICAgICAgIFwiaDRcIiAhPT0gcGFyZW50VGFnICYmXG4gICAgICAgICAgICBcImg1XCIgIT09IHBhcmVudFRhZyAmJlxuICAgICAgICAgICAgXCJoNlwiICE9PSBwYXJlbnRUYWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwicnBcIjpcbiAgICAgICAgY2FzZSBcInJ0XCI6XG4gICAgICAgICAgcmV0dXJuIC0xID09PSBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZyk7XG4gICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgIGNhc2UgXCJmcmFtZXNldFwiOlxuICAgICAgICBjYXNlIFwiZnJhbWVcIjpcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgICAgY2FzZSBcInRoXCI6XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PSBwYXJlbnRUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgIGNhc2UgXCJhcnRpY2xlXCI6XG4gICAgICAgIGNhc2UgXCJhc2lkZVwiOlxuICAgICAgICBjYXNlIFwiYmxvY2txdW90ZVwiOlxuICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJkbFwiOlxuICAgICAgICBjYXNlIFwiZmllbGRzZXRcIjpcbiAgICAgICAgY2FzZSBcImZpZ2NhcHRpb25cIjpcbiAgICAgICAgY2FzZSBcImZpZ3VyZVwiOlxuICAgICAgICBjYXNlIFwiZm9vdGVyXCI6XG4gICAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgICAgY2FzZSBcImhncm91cFwiOlxuICAgICAgICBjYXNlIFwibWFpblwiOlxuICAgICAgICBjYXNlIFwibWVudVwiOlxuICAgICAgICBjYXNlIFwibmF2XCI6XG4gICAgICAgIGNhc2UgXCJvbFwiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwic2VjdGlvblwiOlxuICAgICAgICBjYXNlIFwic3VtbWFyeVwiOlxuICAgICAgICBjYXNlIFwidWxcIjpcbiAgICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJ4bXBcIjpcbiAgICAgICAgY2FzZSBcImgxXCI6XG4gICAgICAgIGNhc2UgXCJoMlwiOlxuICAgICAgICBjYXNlIFwiaDNcIjpcbiAgICAgICAgY2FzZSBcImg0XCI6XG4gICAgICAgIGNhc2UgXCJoNVwiOlxuICAgICAgICBjYXNlIFwiaDZcIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG4gICAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgIGNhc2UgXCJkdFwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcbiAgICAgICAgY2FzZSBcIm5vYnJcIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbmNlc3RvcihwYXJlbnQsIHRhZ05hbWUpIHtcbiAgICAgIGZvciAoOyBwYXJlbnQ7ICkge1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSB0YWdOYW1lKSByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVET01OZXN0aW5nKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mb0RldjtcbiAgICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgICBhbmNlc3RvckluZm8gPSAocGFyZW50SW5mbyA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KFxuICAgICAgICBjaGlsZFRhZyxcbiAgICAgICAgcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZ1xuICAgICAgKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBwYXJlbnRJbmZvKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgICAgYW5jZXN0b3JJbmZvID0gcGFyZW50SW5mbyB8fCBhbmNlc3RvckluZm87XG4gICAgICBpZiAoIWFuY2VzdG9ySW5mbykgcmV0dXJuICEwO1xuICAgICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvLnRhZztcbiAgICAgIHZhciB3YXJuS2V5ID0gU3RyaW5nKCEhcGFyZW50SW5mbykgKyBcInxcIiArIGNoaWxkVGFnICsgXCJ8XCIgKyBhbmNlc3RvckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkgcmV0dXJuICExO1xuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9ICEwO1xuICAgICAgdmFyIGFuY2VzdG9yID0gKHdhcm5LZXkgPSBjdXJyZW50KVxuICAgICAgICA/IGZpbmRBbmNlc3Rvcih3YXJuS2V5LnJldHVybiwgYW5jZXN0b3JJbmZvKVxuICAgICAgICA6IG51bGw7XG4gICAgICB3YXJuS2V5ID1cbiAgICAgICAgbnVsbCAhPT0gd2FybktleSAmJiBudWxsICE9PSBhbmNlc3RvclxuICAgICAgICAgID8gZGVzY3JpYmVBbmNlc3RvcnMoYW5jZXN0b3IsIHdhcm5LZXksIG51bGwpXG4gICAgICAgICAgOiBcIlwiO1xuICAgICAgYW5jZXN0b3IgPSBcIjxcIiArIGNoaWxkVGFnICsgXCI+XCI7XG4gICAgICBwYXJlbnRJbmZvXG4gICAgICAgID8gKChwYXJlbnRJbmZvID0gXCJcIiksXG4gICAgICAgICAgXCJ0YWJsZVwiID09PSBhbmNlc3RvckluZm8gJiZcbiAgICAgICAgICAgIFwidHJcIiA9PT0gY2hpbGRUYWcgJiZcbiAgICAgICAgICAgIChwYXJlbnRJbmZvICs9XG4gICAgICAgICAgICAgIFwiIEFkZCBhIDx0Ym9keT4sIDx0aGVhZD4gb3IgPHRmb290PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlci5cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW4gSFRNTCwgJXMgY2Fubm90IGJlIGEgY2hpbGQgb2YgPCVzPi4lc1xcblRoaXMgd2lsbCBjYXVzZSBhIGh5ZHJhdGlvbiBlcnJvci4lc1wiLFxuICAgICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgICBhbmNlc3RvckluZm8sXG4gICAgICAgICAgICBwYXJlbnRJbmZvLFxuICAgICAgICAgICAgd2FybktleVxuICAgICAgICAgICkpXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW4gSFRNTCwgJXMgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiA8JXM+LlxcblRoaXMgd2lsbCBjYXVzZSBhIGh5ZHJhdGlvbiBlcnJvci4lc1wiLFxuICAgICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgICBhbmNlc3RvckluZm8sXG4gICAgICAgICAgICB3YXJuS2V5XG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVUZXh0TmVzdGluZyhjaGlsZFRleHQsIHBhcmVudFRhZykge1xuICAgICAgaWYgKGlzVGFnVmFsaWRXaXRoUGFyZW50KFwiI3RleHRcIiwgcGFyZW50VGFnKSkgcmV0dXJuICEwO1xuICAgICAgdmFyIHdhcm5LZXkgPSBcIiN0ZXh0fFwiICsgcGFyZW50VGFnO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHJldHVybiAhMTtcbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSAhMDtcbiAgICAgIHZhciBhbmNlc3RvciA9ICh3YXJuS2V5ID0gY3VycmVudClcbiAgICAgICAgPyBmaW5kQW5jZXN0b3Iod2FybktleSwgcGFyZW50VGFnKVxuICAgICAgICA6IG51bGw7XG4gICAgICB3YXJuS2V5ID1cbiAgICAgICAgbnVsbCAhPT0gd2FybktleSAmJiBudWxsICE9PSBhbmNlc3RvclxuICAgICAgICAgID8gZGVzY3JpYmVBbmNlc3RvcnMoXG4gICAgICAgICAgICAgIGFuY2VzdG9yLFxuICAgICAgICAgICAgICB3YXJuS2V5LFxuICAgICAgICAgICAgICA2ICE9PSB3YXJuS2V5LnRhZyA/IHsgY2hpbGRyZW46IG51bGwgfSA6IG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFwiXCI7XG4gICAgICAvXFxTLy50ZXN0KGNoaWxkVGV4dClcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbiBIVE1MLCB0ZXh0IG5vZGVzIGNhbm5vdCBiZSBhIGNoaWxkIG9mIDwlcz4uXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yLiVzXCIsXG4gICAgICAgICAgICBwYXJlbnRUYWcsXG4gICAgICAgICAgICB3YXJuS2V5XG4gICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkluIEhUTUwsIHdoaXRlc3BhY2UgdGV4dCBub2RlcyBjYW5ub3QgYmUgYSBjaGlsZCBvZiA8JXM+LiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIGVhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLlxcblRoaXMgd2lsbCBjYXVzZSBhIGh5ZHJhdGlvbiBlcnJvci4lc1wiLFxuICAgICAgICAgICAgcGFyZW50VGFnLFxuICAgICAgICAgICAgd2FybktleVxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlyc3RDaGlsZCAmJlxuICAgICAgICAgIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmXG4gICAgICAgICAgMyA9PT0gZmlyc3RDaGlsZC5ub2RlVHlwZVxuICAgICAgICApIHtcbiAgICAgICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZShzdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSAwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpO1xuICAgICAgaXNDdXN0b21Qcm9wZXJ0eSB8fFxuICAgICAgICAoLTEgPCBzdHlsZU5hbWUuaW5kZXhPZihcIi1cIilcbiAgICAgICAgICA/ICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tzdHlsZU5hbWVdKSB8fFxuICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW3N0eWxlTmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAgICAgICAgICAgICAgY2FtZWxpemUoc3R5bGVOYW1lLnJlcGxhY2UobXNQYXR0ZXJuLCBcIm1zLVwiKSlcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgOiBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChzdHlsZU5hbWUpXG4gICAgICAgICAgICA/ICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZU5hbWVzW3N0eWxlTmFtZV0pIHx8XG4gICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tzdHlsZU5hbWVdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVOYW1lLFxuICAgICAgICAgICAgICAgIHN0eWxlTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0eWxlTmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAhYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHx8XG4gICAgICAgICAgICAgICgod2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgXCJcIilcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgIChpc05hTih2YWx1ZSlcbiAgICAgICAgICAgID8gd2FybmVkRm9yTmFOVmFsdWUgfHxcbiAgICAgICAgICAgICAgKCh3YXJuZWRGb3JOYU5WYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcImBOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICBzdHlsZU5hbWVcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgfHxcbiAgICAgICAgICAgICAgKCh3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVOYW1lXG4gICAgICAgICAgICAgICkpKSk7XG4gICAgICBudWxsID09IHZhbHVlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJcIiA9PT0gdmFsdWVcbiAgICAgICAgPyBpc0N1c3RvbVByb3BlcnR5XG4gICAgICAgICAgPyBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIFwiXCIpXG4gICAgICAgICAgOiBcImZsb2F0XCIgPT09IHN0eWxlTmFtZVxuICAgICAgICAgICAgPyAoc3R5bGUuY3NzRmxvYXQgPSBcIlwiKVxuICAgICAgICAgICAgOiAoc3R5bGVbc3R5bGVOYW1lXSA9IFwiXCIpXG4gICAgICAgIDogaXNDdXN0b21Qcm9wZXJ0eVxuICAgICAgICAgID8gc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCB2YWx1ZSlcbiAgICAgICAgICA6IFwibnVtYmVyXCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgICAwID09PSB2YWx1ZSB8fFxuICAgICAgICAgICAgICB1bml0bGVzc051bWJlcnMuaGFzKHN0eWxlTmFtZSlcbiAgICAgICAgICAgID8gXCJmbG9hdFwiID09PSBzdHlsZU5hbWVcbiAgICAgICAgICAgICAgPyAoc3R5bGUuY3NzRmxvYXQgPSB2YWx1ZSlcbiAgICAgICAgICAgICAgOiAoY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgIChzdHlsZVtzdHlsZU5hbWVdID0gKFwiXCIgKyB2YWx1ZSkudHJpbSgpKSlcbiAgICAgICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZSArIFwicHhcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgcHJldlN0eWxlcykge1xuICAgICAgaWYgKG51bGwgIT0gc3R5bGVzICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZXMpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiXG4gICAgICAgICk7XG4gICAgICBzdHlsZXMgJiYgT2JqZWN0LmZyZWV6ZShzdHlsZXMpO1xuICAgICAgbm9kZSA9IG5vZGUuc3R5bGU7XG4gICAgICBpZiAobnVsbCAhPSBwcmV2U3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICB2YXIgZXhwYW5kZWRVcGRhdGVzID0ge307XG4gICAgICAgICAgaWYgKHByZXZTdHlsZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJldlN0eWxlcylcbiAgICAgICAgICAgICAgaWYgKHByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhc3R5bGVzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHZhciBsb25naGFuZHMgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleV0gfHwgW2tleV0sIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgaSA8IGxvbmdoYW5kcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBleHBhbmRlZFVwZGF0ZXNbbG9uZ2hhbmRzW2ldXSA9IGtleTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIHN0eWxlcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KF9rZXkpICYmXG4gICAgICAgICAgICAgICghcHJldlN0eWxlcyB8fCBwcmV2U3R5bGVzW19rZXldICE9PSBzdHlsZXNbX2tleV0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAga2V5ID0gc2hvcnRoYW5kVG9Mb25naGFuZFtfa2V5XSB8fCBbX2tleV0sIGxvbmdoYW5kcyA9IDA7XG4gICAgICAgICAgICAgICAgbG9uZ2hhbmRzIDwga2V5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsb25naGFuZHMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZXhwYW5kZWRVcGRhdGVzW2tleVtsb25naGFuZHNdXSA9IF9rZXk7XG4gICAgICAgICAgX2tleSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGtleSRqc2NvbXAkMCBpbiBzdHlsZXMpXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBrZXkgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleSRqc2NvbXAkMF0gfHwgW2tleSRqc2NvbXAkMF0sXG4gICAgICAgICAgICAgICAgbG9uZ2hhbmRzID0gMDtcbiAgICAgICAgICAgICAgbG9uZ2hhbmRzIDwga2V5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgbG9uZ2hhbmRzKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX2tleVtrZXlbbG9uZ2hhbmRzXV0gPSBrZXkkanNjb21wJDA7XG4gICAgICAgICAga2V5JGpzY29tcCQwID0ge307XG4gICAgICAgICAgZm9yICh2YXIgX2tleTIgaW4gZXhwYW5kZWRVcGRhdGVzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGtleSA9IGV4cGFuZGVkVXBkYXRlc1tfa2V5Ml0pLFxuICAgICAgICAgICAgICAobG9uZ2hhbmRzID0gX2tleVtfa2V5Ml0pICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSBsb25naGFuZHMgJiZcbiAgICAgICAgICAgICAgICAoKGkgPSBrZXkgKyBcIixcIiArIGxvbmdoYW5kcyksICFrZXkkanNjb21wJDBbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGtleSRqc2NvbXAkMFtpXSA9ICEwO1xuICAgICAgICAgICAgICBpID0gY29uc29sZTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgICAgICAgIGkuZXJyb3IuY2FsbChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIFwiJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgY29uZmxpY3RpbmcgcHJvcGVydHkgaXMgc2V0ICglcykgY2FuIGxlYWQgdG8gc3R5bGluZyBidWdzLiBUbyBhdm9pZCB0aGlzLCBkb24ndCBtaXggc2hvcnRoYW5kIGFuZCBub24tc2hvcnRoYW5kIHByb3BlcnRpZXMgZm9yIHRoZSBzYW1lIHZhbHVlOyBpbnN0ZWFkLCByZXBsYWNlIHRoZSBzaG9ydGhhbmQgd2l0aCBzZXBhcmF0ZSB2YWx1ZXMuXCIsXG4gICAgICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fCBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlIHx8IFwiXCIgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IFwiUmVtb3ZpbmdcIlxuICAgICAgICAgICAgICAgICAgOiBcIlVwZGF0aW5nXCIsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGxvbmdoYW5kc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBwcmV2U3R5bGVzKVxuICAgICAgICAgICFwcmV2U3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgfHxcbiAgICAgICAgICAgIChudWxsICE9IHN0eWxlcyAmJiBzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkgfHxcbiAgICAgICAgICAgICgwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpXG4gICAgICAgICAgICAgID8gbm9kZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIFwiXCIpXG4gICAgICAgICAgICAgIDogXCJmbG9hdFwiID09PSBzdHlsZU5hbWVcbiAgICAgICAgICAgICAgICA/IChub2RlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgICAgICAgICA6IChub2RlW3N0eWxlTmFtZV0gPSBcIlwiKSk7XG4gICAgICAgIGZvciAodmFyIF9zdHlsZU5hbWUgaW4gc3R5bGVzKVxuICAgICAgICAgIChfa2V5MiA9IHN0eWxlc1tfc3R5bGVOYW1lXSksXG4gICAgICAgICAgICBzdHlsZXMuaGFzT3duUHJvcGVydHkoX3N0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgcHJldlN0eWxlc1tfc3R5bGVOYW1lXSAhPT0gX2tleTIgJiZcbiAgICAgICAgICAgICAgc2V0VmFsdWVGb3JTdHlsZShub2RlLCBfc3R5bGVOYW1lLCBfa2V5Mik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChleHBhbmRlZFVwZGF0ZXMgaW4gc3R5bGVzKVxuICAgICAgICAgIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShleHBhbmRlZFVwZGF0ZXMpICYmXG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKG5vZGUsIGV4cGFuZGVkVXBkYXRlcywgc3R5bGVzW2V4cGFuZGVkVXBkYXRlc10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgaWYgKC0xID09PSB0YWdOYW1lLmluZGV4T2YoXCItXCIpKSByZXR1cm4gITE7XG4gICAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSBcImFubm90YXRpb24teG1sXCI6XG4gICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1zcmNcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6XG4gICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSkge1xuICAgICAgcmV0dXJuIGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkkMSh0YWdOYW1lLCBuYW1lKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJlxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV1cbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBcImFyaWEtXCIgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpIHJldHVybiAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgbmFtZSAhPT0gdGFnTmFtZSAmJlxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcykge1xuICAgICAgdmFyIGludmFsaWRQcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSkgfHwgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gaW52YWxpZFByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSBpbnZhbGlkUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgaW52YWxpZFByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKFwib25mb2N1c2luXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwib25mb2N1c291dFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCBhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICgoXCJmb3JtXCIgPT09IHRhZ05hbWUgJiYgXCJhY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJpbnB1dFwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImJ1dHRvblwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSkge1xuICAgICAgICB0YWdOYW1lID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgICBpZiAoZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgZXZlbnRSZWdpc3RyeSA9IHRhZ05hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgPyB0YWdOYW1lW2xvd2VyQ2FzZWROYW1lXVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50UmVnaXN0cnlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHJBUklBLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbC50ZXN0KG5hbWUpKSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJpbm5lcmh0bWxcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcImFyaWFcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuIFBhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJpc1wiID09PSBsb3dlckNhc2VkTmFtZSAmJlxuICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICB2b2lkIDAgIT09IHZhbHVlICYmXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBpc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGxvd2VyQ2FzZWROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSksXG4gICAgICAgICAgbG93ZXJDYXNlZE5hbWUgIT09IG5hbWUpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSBpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiBJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSBlbGVtZW50LlwiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcImFyaWEtXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG5JZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoXCJmYWxzZVwiID09PSB2YWx1ZSB8fCBcInRydWVcIiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJXMgRGlkIHlvdSBtZWFuICVzPXslc30/XCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBcImZhbHNlXCIgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBcIlRoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLlwiXG4gICAgICAgICAgICAgICAgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgdmFyIHVua25vd25Qcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpIHx8XG4gICAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gdW5rbm93blByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSB1bmtub3duUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IHVua25vd25Qcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAgICAgcmV0dXJuIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QoXCJcIiArIHVybClcbiAgICAgICAgPyBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBoYXMgYmxvY2tlZCBhIGphdmFzY3JpcHQ6IFVSTCBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uJylcIlxuICAgICAgICA6IHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgICAgIG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAgICAgbmF0aXZlRXZlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgJiZcbiAgICAgICAgKG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO1xuICAgICAgcmV0dXJuIDMgPT09IG5hdGl2ZUV2ZW50Lm5vZGVUeXBlID8gbmF0aXZlRXZlbnQucGFyZW50Tm9kZSA6IG5hdGl2ZUV2ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UgJiYgKHRhcmdldCA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0YXJnZXRbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICAgICAgYTogc3dpdGNoIChcbiAgICAgICAgICAoKHRhcmdldCA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgIHVwZGF0ZUlucHV0KFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgIHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICAgIHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgIHByb3BzLm5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlID0gcHJvcHMubmFtZTtcbiAgICAgICAgICAgIGlmIChcInJhZGlvXCIgPT09IHByb3BzLnR5cGUgJiYgbnVsbCAhPSBpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGZvciAocHJvcHMgPSB0YXJnZXQ7IHByb3BzLnBhcmVudE5vZGU7ICkgcHJvcHMgPSBwcm9wcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGludGVybmFsSW5zdGFuY2UsIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgICdpbnB1dFtuYW1lPVwiJyArXG4gICAgICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJuYWxJbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAnXCJdW3R5cGU9XCJyYWRpb1wiXSdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlIDwgcHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UrK1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyTm9kZSAhPT0gdGFyZ2V0ICYmIG90aGVyTm9kZS5mb3JtID09PSB0YXJnZXQuZm9ybSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG90aGVyUHJvcHMgPSBvdGhlck5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJQcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvdGhlclByb3BzLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5uYW1lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UgPCBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSsrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAob3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV0pLFxuICAgICAgICAgICAgICAgICAgb3RoZXJOb2RlLmZvcm0gPT09IHRhcmdldC5mb3JtICYmXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEodGFyZ2V0LCBwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgKGludGVybmFsSW5zdGFuY2UgPSBwcm9wcy52YWx1ZSksXG4gICAgICAgICAgICAgIG51bGwgIT0gaW50ZXJuYWxJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZU9wdGlvbnModGFyZ2V0LCAhIXByb3BzLm11bHRpcGxlLCBpbnRlcm5hbEluc3RhbmNlLCAhMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSwgYikge1xuICAgICAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSByZXR1cm4gZm4oYSwgYik7XG4gICAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGZuKGEpO1xuICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoaXNJbnNpZGVFdmVudEhhbmRsZXIgPSAhMSksXG4gICAgICAgICAgbnVsbCAhPT0gcmVzdG9yZVRhcmdldCB8fCBudWxsICE9PSByZXN0b3JlUXVldWUpXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoZmx1c2hTeW5jV29yayQxKCksXG4gICAgICAgICAgICByZXN0b3JlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICgoYSA9IHJlc3RvcmVUYXJnZXQpLFxuICAgICAgICAgICAgICAoZm4gPSByZXN0b3JlUXVldWUpLFxuICAgICAgICAgICAgICAocmVzdG9yZVF1ZXVlID0gcmVzdG9yZVRhcmdldCA9IG51bGwpLFxuICAgICAgICAgICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChhKSxcbiAgICAgICAgICAgICAgZm4pKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBmbi5sZW5ndGg7IGErKykgcmVzdG9yZVN0YXRlT2ZUYXJnZXQoZm5bYV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gICAgICBpZiAobnVsbCA9PT0gc3RhdGVOb2RlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBwcm9wcyA9IHN0YXRlTm9kZVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xuICAgICAgaWYgKG51bGwgPT09IHByb3BzKSByZXR1cm4gbnVsbDtcbiAgICAgIHN0YXRlTm9kZSA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgYTogc3dpdGNoIChyZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIGNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwib25Eb3VibGVDbGlja1wiOlxuICAgICAgICBjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcIm9uTW91c2VEb3duXCI6XG4gICAgICAgIGNhc2UgXCJvbk1vdXNlRG93bkNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcIm9uTW91c2VNb3ZlXCI6XG4gICAgICAgIGNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcIm9uTW91c2VVcFwiOlxuICAgICAgICBjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwib25Nb3VzZUVudGVyXCI6XG4gICAgICAgICAgKHByb3BzID0gIXByb3BzLmRpc2FibGVkKSB8fFxuICAgICAgICAgICAgKChpbnN0ID0gaW5zdC50eXBlKSxcbiAgICAgICAgICAgIChwcm9wcyA9ICEoXG4gICAgICAgICAgICAgIFwiYnV0dG9uXCIgPT09IGluc3QgfHxcbiAgICAgICAgICAgICAgXCJpbnB1dFwiID09PSBpbnN0IHx8XG4gICAgICAgICAgICAgIFwic2VsZWN0XCIgPT09IGluc3QgfHxcbiAgICAgICAgICAgICAgXCJ0ZXh0YXJlYVwiID09PSBpbnN0XG4gICAgICAgICAgICApKSk7XG4gICAgICAgICAgaW5zdCA9ICFwcm9wcztcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluc3QgPSAhMTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChzdGF0ZU5vZGUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygc3RhdGVOb2RlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGBcIiArXG4gICAgICAgICAgICByZWdpc3RyYXRpb25OYW1lICtcbiAgICAgICAgICAgIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdGVOb2RlICtcbiAgICAgICAgICAgIFwiYCB0eXBlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgICAgaWYgKGZhbGxiYWNrVGV4dCkgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgICAgIHZhciBzdGFydCxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0VGV4dCxcbiAgICAgICAgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aCxcbiAgICAgICAgZW5kLFxuICAgICAgICBlbmRWYWx1ZSA9IFwidmFsdWVcIiBpbiByb290ID8gcm9vdC52YWx1ZSA6IHJvb3QudGV4dENvbnRlbnQsXG4gICAgICAgIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcbiAgICAgIGZvciAoXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgc3RhcnQgPCBzdGFydExlbmd0aCAmJiBzdGFydFZhbHVlW3N0YXJ0XSA9PT0gZW5kVmFsdWVbc3RhcnRdO1xuICAgICAgICBzdGFydCsrXG4gICAgICApO1xuICAgICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKFxuICAgICAgICBlbmQgPSAxO1xuICAgICAgICBlbmQgPD0gbWluRW5kICYmXG4gICAgICAgIHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdID09PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdO1xuICAgICAgICBlbmQrK1xuICAgICAgKTtcbiAgICAgIHJldHVybiAoZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIDEgPCBlbmQgPyAxIC0gZW5kIDogdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcbiAgICAgIFwiY2hhckNvZGVcIiBpbiBuYXRpdmVFdmVudFxuICAgICAgICA/ICgobmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC5jaGFyQ29kZSksXG4gICAgICAgICAgMCA9PT0gbmF0aXZlRXZlbnQgJiYgMTMgPT09IGtleUNvZGUgJiYgKG5hdGl2ZUV2ZW50ID0gMTMpKVxuICAgICAgICA6IChuYXRpdmVFdmVudCA9IGtleUNvZGUpO1xuICAgICAgMTAgPT09IG5hdGl2ZUV2ZW50ICYmIChuYXRpdmVFdmVudCA9IDEzKTtcbiAgICAgIHJldHVybiAzMiA8PSBuYXRpdmVFdmVudCB8fCAxMyA9PT0gbmF0aXZlRXZlbnQgPyBuYXRpdmVFdmVudCA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEludGVyZmFjZSkge1xuICAgICAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KFxuICAgICAgICByZWFjdE5hbWUsXG4gICAgICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgICAgICB0YXJnZXRJbnN0LFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9yZWFjdE5hbWUgPSByZWFjdE5hbWU7XG4gICAgICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpXG4gICAgICAgICAgSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgKChyZWFjdE5hbWUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdKSxcbiAgICAgICAgICAgICh0aGlzW3Byb3BOYW1lXSA9IHJlYWN0TmFtZVxuICAgICAgICAgICAgICA/IHJlYWN0TmFtZShuYXRpdmVFdmVudClcbiAgICAgICAgICAgICAgOiBuYXRpdmVFdmVudFtwcm9wTmFtZV0pKTtcbiAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoXG4gICAgICAgICAgbnVsbCAhPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICAgICAgICA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICAgICAgICAgIDogITEgPT09IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlXG4gICAgICAgIClcbiAgICAgICAgICA/IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gICAgICAgICAgOiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgICAgICAgIGV2ZW50ICYmXG4gICAgICAgICAgICAoZXZlbnQucHJldmVudERlZmF1bHRcbiAgICAgICAgICAgICAgPyBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIDogXCJ1bmtub3duXCIgIT09IHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgICAgICAgIChldmVudC5yZXR1cm5WYWx1ZSA9ICExKSxcbiAgICAgICAgICAgICh0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgICAgICAgZXZlbnQgJiZcbiAgICAgICAgICAgIChldmVudC5zdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgPyBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICA6IFwidW5rbm93blwiICE9PSB0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICYmXG4gICAgICAgICAgICAgICAgKGV2ZW50LmNhbmNlbEJ1YmJsZSA9ICEwKSxcbiAgICAgICAgICAgICh0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyc2lzdDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgICAgIHZhciBuYXRpdmVFdmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZVxuICAgICAgICA/IG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKVxuICAgICAgICA6IChrZXlBcmcgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddKVxuICAgICAgICAgID8gISFuYXRpdmVFdmVudFtrZXlBcmddXG4gICAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKCkge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICByZXR1cm4gLTEgIT09IEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpO1xuICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gICAgICBuYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgICAgIHJldHVybiBcIm9iamVjdFwiID09PSB0eXBlb2YgbmF0aXZlRXZlbnQgJiYgXCJkYXRhXCIgaW4gbmF0aXZlRXZlbnRcbiAgICAgICAgPyBuYXRpdmVFdmVudC5kYXRhXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgICAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9ICEwO1xuICAgICAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuICAgICAgICBjYXNlIFwidGV4dElucHV0XCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChkb21FdmVudE5hbWUgPSBuYXRpdmVFdmVudC5kYXRhKSxcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IGRvbUV2ZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpXG4gICAgICAgIHJldHVybiBcImNvbXBvc2l0aW9uZW5kXCIgPT09IGRvbUV2ZW50TmFtZSB8fFxuICAgICAgICAgICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJlxuICAgICAgICAgICAgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgICAgID8gKChkb21FdmVudE5hbWUgPSBnZXREYXRhKCkpLFxuICAgICAgICAgICAgKGZhbGxiYWNrVGV4dCA9IHN0YXJ0VGV4dCA9IHJvb3QgPSBudWxsKSxcbiAgICAgICAgICAgIChpc0NvbXBvc2luZyA9ICExKSxcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwicGFzdGVcIjpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudC5hbHRLZXkgfHxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnQubWV0YUtleVxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgMSA8IG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaClcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmIFwia29cIiAhPT0gbmF0aXZlRXZlbnQubG9jYWxlXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gXCJpbnB1dFwiID09PSBub2RlTmFtZVxuICAgICAgICA/ICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdXG4gICAgICAgIDogXCJ0ZXh0YXJlYVwiID09PSBub2RlTmFtZVxuICAgICAgICAgID8gITBcbiAgICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICAgICAgaWYgKCFjYW5Vc2VET00pIHJldHVybiAhMTtcbiAgICAgIGV2ZW50TmFtZVN1ZmZpeCA9IFwib25cIiArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgICAgIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZVN1ZmZpeCBpbiBkb2N1bWVudDtcbiAgICAgIGlzU3VwcG9ydGVkIHx8XG4gICAgICAgICgoaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcbiAgICAgICAgaXNTdXBwb3J0ZWQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZVN1ZmZpeCwgXCJyZXR1cm47XCIpLFxuICAgICAgICAoaXNTdXBwb3J0ZWQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpc1N1cHBvcnRlZFtldmVudE5hbWVTdWZmaXhdKSk7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICBpbnN0LFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICB0YXJnZXRcbiAgICApIHtcbiAgICAgIHJlc3RvcmVUYXJnZXRcbiAgICAgICAgPyByZXN0b3JlUXVldWVcbiAgICAgICAgICA/IHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldClcbiAgICAgICAgICA6IChyZXN0b3JlUXVldWUgPSBbdGFyZ2V0XSlcbiAgICAgICAgOiAocmVzdG9yZVRhcmdldCA9IHRhcmdldCk7XG4gICAgICBpbnN0ID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGluc3QsIFwib25DaGFuZ2VcIik7XG4gICAgICAwIDwgaW5zdC5sZW5ndGggJiZcbiAgICAgICAgKChuYXRpdmVFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChcbiAgICAgICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICApKSxcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGluc3QgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSkge1xuICAgICAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk7XG4gICAgICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHJldHVybiB0YXJnZXRJbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gICAgICBpZiAoXCJjaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lKSByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gICAgICBhY3RpdmVFbGVtZW50JDEgJiZcbiAgICAgICAgKGFjdGl2ZUVsZW1lbnQkMS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIiwgaGFuZGxlUHJvcGVydHlDaGFuZ2UpLFxuICAgICAgICAoYWN0aXZlRWxlbWVudEluc3QkMSA9IGFjdGl2ZUVsZW1lbnQkMSA9IG51bGwpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJ2YWx1ZVwiID09PSBuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgJiZcbiAgICAgICAgZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgICAgICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSxcbiAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudClcbiAgICAgICAgKTtcbiAgICAgICAgYmF0Y2hlZFVwZGF0ZXMkMShydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0YXJnZXRJbnN0XG4gICAgKSB7XG4gICAgICBcImZvY3VzaW5cIiA9PT0gZG9tRXZlbnROYW1lXG4gICAgICAgID8gKHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCksXG4gICAgICAgICAgKGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldCksXG4gICAgICAgICAgKGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSB0YXJnZXRJbnN0KSxcbiAgICAgICAgICBhY3RpdmVFbGVtZW50JDEuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKSlcbiAgICAgICAgOiBcImZvY3Vzb3V0XCIgPT09IGRvbUV2ZW50TmFtZSAmJiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBcInNlbGVjdGlvbmNoYW5nZVwiID09PSBkb21FdmVudE5hbWUgfHxcbiAgICAgICAgXCJrZXl1cFwiID09PSBkb21FdmVudE5hbWUgfHxcbiAgICAgICAgXCJrZXlkb3duXCIgPT09IGRvbUV2ZW50TmFtZVxuICAgICAgKVxuICAgICAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgICAgIGlmIChcImNsaWNrXCIgPT09IGRvbUV2ZW50TmFtZSkgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgICAgIGlmIChcImlucHV0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcImNoYW5nZVwiID09PSBkb21FdmVudE5hbWUpXG4gICAgICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgICAgICBudWxsID09PSBvYmpBIHx8XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgICAgIG51bGwgPT09IG9iakJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAgICAgIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2tleXNCXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAgICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgICAgIGZvciAoOyBub2RlICYmIG5vZGUuZmlyc3RDaGlsZDsgKSBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICAgICAgcm9vdCA9IDA7XG4gICAgICBmb3IgKHZhciBub2RlRW5kOyBub2RlOyApIHtcbiAgICAgICAgaWYgKDMgPT09IG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICBub2RlRW5kID0gcm9vdCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGlmIChyb290IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IC0gcm9vdCB9O1xuICAgICAgICAgIHJvb3QgPSBub2RlRW5kO1xuICAgICAgICB9XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBmb3IgKDsgbm9kZTsgKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGdldExlYWZOb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiBvdXRlck5vZGUgJiYgaW5uZXJOb2RlXG4gICAgICAgID8gb3V0ZXJOb2RlID09PSBpbm5lck5vZGVcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiBvdXRlck5vZGUgJiYgMyA9PT0gb3V0ZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgICAgICA/ICExXG4gICAgICAgICAgICA6IGlubmVyTm9kZSAmJiAzID09PSBpbm5lck5vZGUubm9kZVR5cGVcbiAgICAgICAgICAgICAgPyBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgOiBcImNvbnRhaW5zXCIgaW4gb3V0ZXJOb2RlXG4gICAgICAgICAgICAgICAgPyBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKVxuICAgICAgICAgICAgICAgIDogb3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICA/ICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpXG4gICAgICAgICAgICAgICAgICA6ICExXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKGNvbnRhaW5lckluZm8pIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPVxuICAgICAgICBudWxsICE9IGNvbnRhaW5lckluZm8gJiZcbiAgICAgICAgbnVsbCAhPSBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXdcbiAgICAgICAgICA/IGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICAgICAgIDogd2luZG93O1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGNvbnRhaW5lckluZm8uZG9jdW1lbnQpO1xuICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgY29udGFpbmVySW5mby5IVE1MSUZyYW1lRWxlbWVudDtcblxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICB9XG4gICAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIGNvbnRhaW5lckluZm8gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGNvbnRhaW5lckluZm8uZG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbm9kZU5hbWUgJiZcbiAgICAgICAgKChcImlucHV0XCIgPT09IG5vZGVOYW1lICYmXG4gICAgICAgICAgKFwidGV4dFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgICAgIFwic2VhcmNoXCIgPT09IGVsZW0udHlwZSB8fFxuICAgICAgICAgICAgXCJ0ZWxcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgICAgICBcInVybFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgICAgIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlKSkgfHxcbiAgICAgICAgICBcInRleHRhcmVhXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgXCJ0cnVlXCIgPT09IGVsZW0uY29udGVudEVkaXRhYmxlKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLCBjb250YWluZXJJbmZvKSB7XG4gICAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcChjb250YWluZXJJbmZvKTtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJGb2N1c2VkRWxlbSAhPT0gY29udGFpbmVySW5mbyAmJlxuICAgICAgICBjb250YWluZXJJbmZvICYmXG4gICAgICAgIGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudCAmJlxuICAgICAgICBjb250YWluc05vZGUoY29udGFpbmVySW5mby5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY29udGFpbmVySW5mbylcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcHJpb3JTZWxlY3Rpb25SYW5nZSAmJlxuICAgICAgICAgIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhjb250YWluZXJJbmZvKVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID0gcHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCksXG4gICAgICAgICAgICAoY3VyRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvblJhbmdlLmVuZCksXG4gICAgICAgICAgICB2b2lkIDAgPT09IGN1ckZvY3VzZWRFbGVtICYmXG4gICAgICAgICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pLFxuICAgICAgICAgICAgXCJzZWxlY3Rpb25TdGFydFwiIGluIGNvbnRhaW5lckluZm8pXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKGNvbnRhaW5lckluZm8uc2VsZWN0aW9uU3RhcnQgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSxcbiAgICAgICAgICAgICAgKGNvbnRhaW5lckluZm8uc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgY3VyRm9jdXNlZEVsZW0sXG4gICAgICAgICAgICAgICAgY29udGFpbmVySW5mby52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAoKGN1ckZvY3VzZWRFbGVtID1cbiAgICAgICAgICAgICAgKChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID1cbiAgICAgICAgICAgICAgICBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICYmXG4gICAgICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICAgICAgd2luZG93KSxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmdldFNlbGVjdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtID0gY3VyRm9jdXNlZEVsZW0uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29udGFpbmVySW5mby50ZXh0Q29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4ocHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2UgPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHByaW9yU2VsZWN0aW9uUmFuZ2UuZW5kXG4gICAgICAgICAgICAgICAgPyBzdGFydFxuICAgICAgICAgICAgICAgIDogTWF0aC5taW4ocHJpb3JTZWxlY3Rpb25SYW5nZS5lbmQsIGxlbmd0aCk7XG4gICAgICAgICAgICAhY3VyRm9jdXNlZEVsZW0uZXh0ZW5kICYmXG4gICAgICAgICAgICAgIHN0YXJ0ID4gcHJpb3JTZWxlY3Rpb25SYW5nZSAmJlxuICAgICAgICAgICAgICAoKGxlbmd0aCA9IHByaW9yU2VsZWN0aW9uUmFuZ2UpLFxuICAgICAgICAgICAgICAocHJpb3JTZWxlY3Rpb25SYW5nZSA9IHN0YXJ0KSxcbiAgICAgICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoKSk7XG4gICAgICAgICAgICBsZW5ndGggPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KGNvbnRhaW5lckluZm8sIHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KFxuICAgICAgICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICAgICAgICBwcmlvclNlbGVjdGlvblJhbmdlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVuZ3RoICYmXG4gICAgICAgICAgICAgIGVuZE1hcmtlciAmJlxuICAgICAgICAgICAgICAoMSAhPT0gY3VyRm9jdXNlZEVsZW0ucmFuZ2VDb3VudCB8fFxuICAgICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFuY2hvck5vZGUgIT09IGxlbmd0aC5ub2RlIHx8XG4gICAgICAgICAgICAgICAgY3VyRm9jdXNlZEVsZW0uYW5jaG9yT2Zmc2V0ICE9PSBsZW5ndGgub2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgY3VyRm9jdXNlZEVsZW0uZm9jdXNOb2RlICE9PSBlbmRNYXJrZXIubm9kZSB8fFxuICAgICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmZvY3VzT2Zmc2V0ICE9PSBlbmRNYXJrZXIub2Zmc2V0KSAmJlxuICAgICAgICAgICAgICAoKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24gPVxuICAgICAgICAgICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uY3JlYXRlUmFuZ2UoKSksXG4gICAgICAgICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2V0U3RhcnQobGVuZ3RoLm5vZGUsIGxlbmd0aC5vZmZzZXQpLFxuICAgICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5yZW1vdmVBbGxSYW5nZXMoKSxcbiAgICAgICAgICAgICAgc3RhcnQgPiBwcmlvclNlbGVjdGlvblJhbmdlXG4gICAgICAgICAgICAgICAgPyAoY3VyRm9jdXNlZEVsZW0uYWRkUmFuZ2UocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpKVxuICAgICAgICAgICAgICAgIDogKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2V0RW5kKFxuICAgICAgICAgICAgICAgICAgICBlbmRNYXJrZXIubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kTWFya2VyLm9mZnNldFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFkZFJhbmdlKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pKSk7XG4gICAgICAgICAgfVxuICAgICAgICBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID0gW107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgY3VyRm9jdXNlZEVsZW0gPSBjb250YWluZXJJbmZvO1xuICAgICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IGN1ckZvY3VzZWRFbGVtLnBhcmVudE5vZGUpO1xuXG4gICAgICAgIClcbiAgICAgICAgICAxID09PSBjdXJGb2N1c2VkRWxlbS5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogY3VyRm9jdXNlZEVsZW0sXG4gICAgICAgICAgICAgIGxlZnQ6IGN1ckZvY3VzZWRFbGVtLnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgIHRvcDogY3VyRm9jdXNlZEVsZW0uc2Nyb2xsVG9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGFpbmVySW5mby5mb2N1cyAmJiBjb250YWluZXJJbmZvLmZvY3VzKCk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgY29udGFpbmVySW5mbyA9IDA7XG4gICAgICAgICAgY29udGFpbmVySW5mbyA8IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24ubGVuZ3RoO1xuICAgICAgICAgIGNvbnRhaW5lckluZm8rK1xuICAgICAgICApXG4gICAgICAgICAgKGN1ckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbltjb250YWluZXJJbmZvXSksXG4gICAgICAgICAgICAoY3VyRm9jdXNlZEVsZW0uZWxlbWVudC5zY3JvbGxMZWZ0ID0gY3VyRm9jdXNlZEVsZW0ubGVmdCksXG4gICAgICAgICAgICAoY3VyRm9jdXNlZEVsZW0uZWxlbWVudC5zY3JvbGxUb3AgPSBjdXJGb2N1c2VkRWxlbS50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChcbiAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgKSB7XG4gICAgICB2YXIgZG9jID1cbiAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnRcbiAgICAgICAgICA6IDkgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlXG4gICAgICAgICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBtb3VzZURvd24gfHxcbiAgICAgICAgbnVsbCA9PSBhY3RpdmVFbGVtZW50IHx8XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB8fFxuICAgICAgICAoKGRvYyA9IGFjdGl2ZUVsZW1lbnQpLFxuICAgICAgICBcInNlbGVjdGlvblN0YXJ0XCIgaW4gZG9jICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhkb2MpXG4gICAgICAgICAgPyAoZG9jID0geyBzdGFydDogZG9jLnNlbGVjdGlvblN0YXJ0LCBlbmQ6IGRvYy5zZWxlY3Rpb25FbmQgfSlcbiAgICAgICAgICA6ICgoZG9jID0gKFxuICAgICAgICAgICAgICAoZG9jLm93bmVyRG9jdW1lbnQgJiYgZG9jLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgKS5nZXRTZWxlY3Rpb24oKSksXG4gICAgICAgICAgICAoZG9jID0ge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlOiBkb2MuYW5jaG9yTm9kZSxcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0OiBkb2MuYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgICBmb2N1c05vZGU6IGRvYy5mb2N1c05vZGUsXG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0OiBkb2MuZm9jdXNPZmZzZXRcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgKGxhc3RTZWxlY3Rpb24gJiYgc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGRvYykpIHx8XG4gICAgICAgICAgKChsYXN0U2VsZWN0aW9uID0gZG9jKSxcbiAgICAgICAgICAoZG9jID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGFjdGl2ZUVsZW1lbnRJbnN0LCBcIm9uU2VsZWN0XCIpKSxcbiAgICAgICAgICAwIDwgZG9jLmxlbmd0aCAmJlxuICAgICAgICAgICAgKChuYXRpdmVFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChcbiAgICAgICAgICAgICAgXCJvblNlbGVjdFwiLFxuICAgICAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGRvYyB9KSxcbiAgICAgICAgICAgIChuYXRpdmVFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50KSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICAgICAgdmFyIHByZWZpeGVzID0ge307XG4gICAgICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHByZWZpeGVzW1wiV2Via2l0XCIgKyBzdHlsZVByb3BdID0gXCJ3ZWJraXRcIiArIGV2ZW50TmFtZTtcbiAgICAgIHByZWZpeGVzW1wiTW96XCIgKyBzdHlsZVByb3BdID0gXCJtb3pcIiArIGV2ZW50TmFtZTtcbiAgICAgIHJldHVybiBwcmVmaXhlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICAgIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdLFxuICAgICAgICBzdHlsZVByb3A7XG4gICAgICBmb3IgKHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApXG4gICAgICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpXG4gICAgICAgICAgcmV0dXJuIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdKTtcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLCByZWFjdE5hbWUpIHtcbiAgICAgIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLnNldChkb21FdmVudE5hbWUsIHJlYWN0TmFtZSk7XG4gICAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVhY3ROYW1lLCBbZG9tRXZlbnROYW1lXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICAgICAgaSA9IChjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwKTtcbiAgICAgICAgaSA8IGVuZEluZGV4O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIDAgIT09IGxhbmUgJiYgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSBsYW5lKTtcbiAgICAgIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAoYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAgICAgKChzb3VyY2VGaWJlciA9IHBhcmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5WaXNpYmxlIHx8XG4gICAgICAgICAgICAgIChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnJldHVybik7XG4gICAgICBpc0hpZGRlbiAmJlxuICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgMyA9PT0gc291cmNlRmliZXIudGFnICYmXG4gICAgICAgICgocGFyZW50ID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgKGlzSGlkZGVuID0gMzEgLSBjbHozMihsYW5lKSksXG4gICAgICAgIChwYXJlbnQgPSBwYXJlbnQuaGlkZGVuVXBkYXRlcyksXG4gICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudFtpc0hpZGRlbl0pLFxuICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgID8gKHBhcmVudFtpc0hpZGRlbl0gPSBbdXBkYXRlXSlcbiAgICAgICAgICA6IHNvdXJjZUZpYmVyLnB1c2godXBkYXRlKSxcbiAgICAgICAgKHVwZGF0ZS5sYW5lID0gbGFuZSB8IDUzNjg3MDkxMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gICAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSBuZXN0ZWRVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cIlxuICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgJiZcbiAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uIGV2ZXJ5IHJlbmRlci5cIlxuICAgICAgICApKTtcbiAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAwICE9PSAoc291cmNlRmliZXIuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBzb3VyY2VGaWJlciwgcGFyZW50ID0gbm9kZS5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBudWxsID09PSBub2RlLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKSxcbiAgICAgICAgICAobm9kZSA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IG5vZGUucmV0dXJuKTtcbiAgICAgIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5vZGUuc3RhdGVOb2RlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5ID8gdHlwZSA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuIHR5cGU7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGZhbWlseVxuICAgICAgICA/IG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IHR5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnJlbmRlciAmJlxuICAgICAgICAgICgoZmFtaWx5ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKSksXG4gICAgICAgICAgdHlwZS5yZW5kZXIgIT09IGZhbWlseSlcbiAgICAgICAgICA/ICgoZmFtaWx5ID0geyAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSwgcmVuZGVyOiBmYW1pbHkgfSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgKGZhbWlseS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWUpLFxuICAgICAgICAgICAgZmFtaWx5KVxuICAgICAgICAgIDogdHlwZVxuICAgICAgICA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gITE7XG4gICAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMSxcbiAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiYgbnVsbCAhPT0gZWxlbWVudFxuICAgICAgICAgICAgPyBlbGVtZW50LiQkdHlwZW9mXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudCAmJiAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50XG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWVkc0NvbXBhcmVGYW1pbGllcyAmJlxuICAgICAgICAoKGZpYmVyID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGZpYmVyICYmIGZpYmVyID09PSByZXNvbHZlRmFtaWx5KGVsZW1lbnQpKVxuICAgICAgICA/ICEwXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSByZXNvbHZlRmFtaWx5ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgJiZcbiAgICAgICAgKG51bGwgPT09IGZhaWxlZEJvdW5kYXJpZXMgJiYgKGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpKSxcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgIGZpYmVyLFxuICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgc3RhbGVGYW1pbGllc1xuICAgICkge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpXG4gICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuXCIpO1xuICAgICAgdmFyIG5lZWRzUmVuZGVyID0gITE7XG4gICAgICB0eXBlID0gITE7XG4gICAgICBudWxsICE9PSBjYW5kaWRhdGVUeXBlICYmXG4gICAgICAgICgoY2FuZGlkYXRlVHlwZSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgICAoc3RhbGVGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgICAgID8gKHR5cGUgPSAhMClcbiAgICAgICAgICAgIDogdXBkYXRlZEZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKSAmJlxuICAgICAgICAgICAgICAoMSA9PT0gdGFnID8gKHR5cGUgPSAhMCkgOiAobmVlZHNSZW5kZXIgPSAhMCkpKSk7XG4gICAgICBudWxsICE9PSBmYWlsZWRCb3VuZGFyaWVzICYmXG4gICAgICAgIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpKSAmJlxuICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgIHR5cGUgJiYgKGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICEwKTtcbiAgICAgIGlmICh0eXBlIHx8IG5lZWRzUmVuZGVyKVxuICAgICAgICAoYWx0ZXJuYXRlID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhbHRlcm5hdGUsIGZpYmVyLCAyKTtcbiAgICAgIG51bGwgPT09IGNoaWxkIHx8XG4gICAgICAgIHR5cGUgfHxcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgbnVsbCAhPT0gc2libGluZyAmJlxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICByZXR1cm4gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgcmV0dXJuIGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAwID4gZmliZXIuYWN0dWFsU3RhcnRUaW1lICYmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBwcm9maWxlclN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb3JkRWZmZWN0RHVyYXRpb24oKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEVmZmVjdFRpbWVyKCkge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgY2hpbGQ7IClcbiAgICAgICAgKGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gQ2FwdHVyZWRTdGFja3MuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgICAgfTtcbiAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gICAgICB0cmVlRm9ya1Byb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBiYXNlTGVuZ3RoID0gMzIgLSBjbHozMihiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIHZhciBsZW5ndGggPSAzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDtcbiAgICAgIGlmICgzMCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gKGJhc2VMZW5ndGggJSA1KTtcbiAgICAgICAgbGVuZ3RoID0gKFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICAgICAoKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMSlcbiAgICAgICAgKS50b1N0cmluZygzMik7XG4gICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgYmFzZUxlbmd0aCAtPSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgdHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgIChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8XG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQ7XG4gICAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBsZW5ndGggKyB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH0gZWxzZVxuICAgICAgICAodHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0KSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4gJiZcbiAgICAgICAgKHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgMSksIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIDEsIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUZvcmtQcm92aWRlciA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuICAgICAgaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAoKGZpYmVyID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCkpLFxuICAgICAgICAoZmliZXIuc2VydmVyUHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gcmVqZWN0ZWRDYW5kaWRhdGUgJiZcbiAgICAgICAgICAoKHJlamVjdGVkQ2FuZGlkYXRlID1cbiAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpKSxcbiAgICAgICAgICBmaWJlci5zZXJ2ZXJUYWlsLnB1c2gocmVqZWN0ZWRDYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICAgICAgdmFyIGRpZmYgPSBcIlwiLFxuICAgICAgICBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLCAoZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpKTtcbiAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG5odHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiICtcbiAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICksXG4gICAgICAgICAgZmliZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgICB2YXIgZGlkSHlkcmF0ZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgZGlkSHlkcmF0ZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpYmVyO1xuICAgICAgZGlkSHlkcmF0ZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0eXBlLCBwcm9wcyk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjYW5jZWxcIiwgZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNsb3NlXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbdHlwZV0sIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkaWRIeWRyYXRlKTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkaWRIeWRyYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFpbHNcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wcyhkaWRIeWRyYXRlLCBwcm9wcyk7XG4gICAgICAgICAgaW5pdElucHV0KFxuICAgICAgICAgICAgZGlkSHlkcmF0ZSxcbiAgICAgICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCxcbiAgICAgICAgICAgIHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgcHJvcHMudHlwZSxcbiAgICAgICAgICAgIHByb3BzLm5hbWUsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgICAgdHJhY2soZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICB2YWxpZGF0ZU9wdGlvblByb3BzKGRpZEh5ZHJhdGUsIHByb3BzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIHZhbGlkYXRlU2VsZWN0UHJvcHMoZGlkSHlkcmF0ZSwgcHJvcHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwidGV4dGFyZWFcIiwgcHJvcHMpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZGlkSHlkcmF0ZSksXG4gICAgICAgICAgICB2YWxpZGF0ZVRleHRhcmVhUHJvcHMoZGlkSHlkcmF0ZSwgcHJvcHMpLFxuICAgICAgICAgICAgaW5pdFRleHRhcmVhKFxuICAgICAgICAgICAgICBkaWRIeWRyYXRlLFxuICAgICAgICAgICAgICBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRyYWNrKGRpZEh5ZHJhdGUpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIFwiYmlnaW50XCIgIT09IHR5cGVvZiB0eXBlKSB8fFxuICAgICAgZGlkSHlkcmF0ZS50ZXh0Q29udGVudCA9PT0gXCJcIiArIHR5cGUgfHxcbiAgICAgICEwID09PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgfHxcbiAgICAgIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChkaWRIeWRyYXRlLnRleHRDb250ZW50LCB0eXBlKVxuICAgICAgICA/IChudWxsICE9IHByb3BzLnBvcG92ZXIgJiZcbiAgICAgICAgICAgIChsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiYmVmb3JldG9nZ2xlXCIsIGRpZEh5ZHJhdGUpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkaWRIeWRyYXRlKSksXG4gICAgICAgICAgbnVsbCAhPSBwcm9wcy5vblNjcm9sbCAmJlxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkaWRIeWRyYXRlKSxcbiAgICAgICAgICBudWxsICE9IHByb3BzLm9uU2Nyb2xsRW5kICYmXG4gICAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRpZEh5ZHJhdGUpLFxuICAgICAgICAgIG51bGwgIT0gcHJvcHMub25DbGljayAmJiAoZGlkSHlkcmF0ZS5vbmNsaWNrID0gbm9vcCQxKSxcbiAgICAgICAgICAoZGlkSHlkcmF0ZSA9ICEwKSlcbiAgICAgICAgOiAoZGlkSHlkcmF0ZSA9ICExKTtcbiAgICAgIGRpZEh5ZHJhdGUgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgICAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICAgICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICAgIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHJldHVybiAhMTtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSwgKGlzSHlkcmF0aW5nID0gITApLCAhMTtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9ICExLFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICBpZiAoKEpTQ29tcGlsZXJfdGVtcCA9IDMgIT09IGZpYmVyLnRhZyAmJiAyNyAhPT0gZmliZXIudGFnKSkge1xuICAgICAgICBpZiAoKEpTQ29tcGlsZXJfdGVtcCA9IDUgPT09IGZpYmVyLnRhZykpXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGZpYmVyLnR5cGUpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICEoXCJmb3JtXCIgIT09IEpTQ29tcGlsZXJfdGVtcCAmJiBcImJ1dHRvblwiICE9PSBKU0NvbXBpbGVyX3RlbXApIHx8XG4gICAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wID0gIUpTQ29tcGlsZXJfdGVtcDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfdGVtcCAmJiAoc2hvdWxkQ2xlYXIgPSAhMCk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHNob3VsZENsZWFyID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTsgc2hvdWxkQ2xlYXI7ICkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHNob3VsZENsZWFyKTtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBzaG91bGRDbGVhciA9XG4gICAgICAgICAgICBcIlN1c3BlbnNlXCIgPT09IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHNob3VsZENsZWFyKVxuICAgICAgICAgICAgICA6IGdldE5leHRIeWRyYXRhYmxlKHNob3VsZENsZWFyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICAgICAgfVxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGZpYmVyID0gbnVsbCAhPT0gZmliZXIgPyBmaWJlci5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgaWYgKCFmaWJlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyXG4gICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gaXNIeWRyYXRpbmcgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICAgICAgbnVsbCA9PT0gaHlkcmF0aW9uRXJyb3JzXG4gICAgICAgID8gKGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCkge1xuICAgICAgdmFyIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBudWxsICE9PSBkaWZmUm9vdCAmJlxuICAgICAgICAoKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgIChkaWZmUm9vdCA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYmUgcGF0Y2hlZCB1cC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cXG4tIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcbi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcbi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuXFxuSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuXFxuJXMlc1wiLFxuICAgICAgICAgIFwiaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2hcIixcbiAgICAgICAgICBkaWZmUm9vdFxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IGRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZTogITEsIHRoZW5hYmxlczogW10gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSB7XG4gICAgICB0aGVuYWJsZSA9IHRoZW5hYmxlLnN0YXR1cztcbiAgICAgIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZSB8fCBcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDMoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UgPSAhMCk7XG4gICAgICB2YXIgdHJhY2tlZFRoZW5hYmxlcyA9IHRoZW5hYmxlU3RhdGUudGhlbmFibGVzO1xuICAgICAgaW5kZXggPSB0cmFja2VkVGhlbmFibGVzW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0cmFja2VkVGhlbmFibGVzLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIHx8XG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCB3YXMgc3VzcGVuZGVkIGJ5IGFuIHVuY2FjaGVkIHByb21pc2UuIENyZWF0aW5nIHByb21pc2VzIGluc2lkZSBhIENsaWVudCBDb21wb25lbnQgb3IgaG9vayBpcyBub3QgeWV0IHN1cHBvcnRlZCwgZXhjZXB0IHZpYSBhIFN1c3BlbnNlLWNvbXBhdGlibGUgbGlicmFyeSBvciBmcmFtZXdvcmsuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQzLCBub29wJDMpLFxuICAgICAgICAgICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMywgbm9vcCQzKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGU7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMDtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITE7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkUmVhc29uKSB7XG4gICAgICBpZiAocmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkhvb2tzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBhbiBhc3luYyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEZWJ1Z0luZm8oZGVidWdJbmZvKSB7XG4gICAgICB2YXIgcHJldmlvdXNEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8gJiZcbiAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPVxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzRGVidWdJbmZvXG4gICAgICAgICAgICA/IGRlYnVnSW5mb1xuICAgICAgICAgICAgOiBwcmV2aW91c0RlYnVnSW5mby5jb25jYXQoZGVidWdJbmZvKSk7XG4gICAgICByZXR1cm4gcHJldmlvdXNEZWJ1Z0luZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBmaWJlciwgcmV0dXJuRmliZXIpIHtcbiAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LnByb3BzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBrZXkgJiYgXCJrZXlcIiAhPT0ga2V5KSB7XG4gICAgICAgICAgbnVsbCA9PT0gZmliZXIgJiZcbiAgICAgICAgICAgICgoZmliZXIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIDApKSxcbiAgICAgICAgICAgIChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAoZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yZWRLZXkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JlZEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyJDE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlJDEgJiYgKHRoZW5hYmxlU3RhdGUkMSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSk7XG4gICAgICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSQxLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VSZWYod29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnByb3BzLnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IHZvaWQgMCAhPT0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbi0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbi0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJ1xuICAgICAgICApO1xuICAgICAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgIDogcmV0dXJuRmliZXIpICtcbiAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9XG4gICAgICAgICAgaW52YWxpZENoaWxkLmRpc3BsYXlOYW1lIHx8IGludmFsaWRDaGlsZC5uYW1lIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAzID09PSByZXR1cm5GaWJlci50YWdcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgPCVzPnslc308LyVzPlwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9IFN0cmluZyhpbnZhbGlkQ2hpbGQpKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIDwlcz4lczwvJXM+XCIsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgICAgbnVsbCA9PT0gZGVsZXRpb25zXG4gICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICAgIDogZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZm9yICh2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZC5rZXlcbiAgICAgICAgICAgID8gZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQua2V5LCBjdXJyZW50Rmlyc3RDaGlsZClcbiAgICAgICAgICAgIDogZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQuaW5kZXgsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgICAgZmliZXIgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICAgICAgZmliZXIuaW5kZXggPSAwO1xuICAgICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgICAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpXG4gICAgICAgICAgcmV0dXJuIChuZXdGaWJlci5mbGFncyB8PSAxMDQ4NTc2KSwgbGFzdFBsYWNlZEluZGV4O1xuICAgICAgICBuZXdJbmRleCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5ld0luZGV4KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3SW5kZXggPSBuZXdJbmRleC5pbmRleCksXG4gICAgICAgICAgICBuZXdJbmRleCA8IGxhc3RQbGFjZWRJbmRleFxuICAgICAgICAgICAgICA/ICgobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpLCBsYXN0UGxhY2VkSW5kZXgpXG4gICAgICAgICAgICAgIDogbmV3SW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICBuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCk7XG4gICAgICAgIHJldHVybiBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNiAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGN1cnJlbnQsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fFxuICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpIHx8XG4gICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcykpLFxuICAgICAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgNCAhPT0gY3VycmVudC50YWcgfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDcgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdJZHggPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG5ld0lkeCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQgfHwgbnVsbCA9PT0gY2hpbGQpIHJldHVybiBrbm93bktleXM7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGtub3duS2V5cykge1xuICAgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSBkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIFxcdTIwMTQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCBjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAoY2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihjaGlsZCkpLFxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIik7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICAgICAga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdDaGlsZCAmJlxuICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgICAgICAodmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gcHJldkRlYnVnSW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0gbmV3Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICA0ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY2hpbGRyZW4gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgIT09IHJldHVybkZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBuZXdDaGlsZC5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkICYmIDYgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHByZXZEZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKSxcbiAgICAgICAgICAgIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBwcmV2RGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICAgICAgdmFyIGZpcnN0Q2hpbGRGaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24pIHRocm93IHg7XG4gICAgICAgICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoMjksIHgsIG51bGwsIHJldHVybkZpYmVyLm1vZGUpO1xuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgdmFyIGRlYnVnSW5mbyA9IChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyk7XG4gICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRlYnVnSW5mb1tpXS5zdGFjaykge1xuICAgICAgICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGVudGFuZ2xlZFJlbmRlckxhbmVzO1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyB8IGNvbnRleHQuYmFzZUxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlciwgaGFuZGxlcik7XG4gICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5ICYmXG4gICAgICAgIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgICAgIDogbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmIChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBpZiAoMjIgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBmaWJlciksXG4gICAgICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKSxcbiAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5KVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChzaGVsbEJvdW5kYXJ5ID0gZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICBpZiAoMTMgPT09IG5vZGUudGFnKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IHN0YXRlICYmXG4gICAgICAgICAgICAoKHN0YXRlID0gc3RhdGUuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICBudWxsID09PSBzdGF0ZSB8fFxuICAgICAgICAgICAgICBzdGF0ZS5kYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgICAgc3RhdGUuZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAxOSA9PT0gbm9kZS50YWcgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlclxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoMCAhPT0gKG5vZGUuZmxhZ3MgJiAxMjgpKSByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSByb3cpIGJyZWFrO1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHJvdykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgICAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgICAgIHJlZkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBjYWNoZS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnJlZkNvdW50LS07XG4gICAgICAwID4gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQyKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICAgICAoMCwgbGlzdGVuZXJzW2Vycm9yXSkodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVla0NhY2hlRnJvbVBvb2woKSB7XG4gICAgICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgID8gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJhbnNpdGlvbihvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCkge1xuICAgICAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgICAgICA/IHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgICAgIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjYWNoZUZyb21Qb29sXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHsgcGFyZW50OiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcG9vbDogY2FjaGVGcm9tUG9vbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgbnVsbCA9PT0gaG9va1R5cGVzRGV2XG4gICAgICAgID8gKGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV0pXG4gICAgICAgIDogaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2ICYmXG4gICAgICAgIChob29rVHlwZXNVcGRhdGVJbmRleERldisrLFxuICAgICAgICBob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYpXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAodmFyIHRhYmxlID0gXCJcIiwgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldLFxuICAgICAgICAgICAgICBuZXdIb29rTmFtZSA9XG4gICAgICAgICAgICAgICAgaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBob29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgICAzMCA+IG9sZEhvb2tOYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSArPSBcIiBcIjtcbiAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IG5ld0hvb2tOYW1lICsgXCJcXG5cIjtcbiAgICAgICAgICAgIHRhYmxlICs9IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4lcyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcblwiLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gICAgICB2b2lkIDAgPT09IGRlcHMgfHxcbiAgICAgICAgbnVsbCA9PT0gZGVwcyB8fFxuICAgICAgICBpc0FycmF5SW1wbChkZXBzKSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS5cIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICB0eXBlb2YgZGVwc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICAgIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgKGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdERPTS51c2VGb3JtU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWFjdC51c2VBY3Rpb25TdGF0ZS4gUGxlYXNlIHVwZGF0ZSAlcyB0byB1c2UgUmVhY3QudXNlQWN0aW9uU3RhdGUuXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gICAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHJldHVybiAhMTtcbiAgICAgIGlmIChudWxsID09PSBwcmV2RGVwcylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cIixcbiAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgbmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgXCJbXCIgKyBwcmV2RGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICBcIltcIiArIG5leHREZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHNlY29uZEFyZyxcbiAgICAgIG5leHRSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBob29rVHlwZXNEZXYgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAoXG4gICAgICAgIFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpIHx8XG4gICAgICAgIFwiW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpXG4gICAgICApXG4gICAgICAgIChuZXh0UmVuZGVyTGFuZXMgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDFcbiAgICAgICAgKSksXG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKG5leHRSZW5kZXJMYW5lcykgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5hZGQobmV4dFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgOiBudWxsICE9PSBob29rVHlwZXNEZXZcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IG5leHRSZW5kZXJMYW5lcyA9XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkgIT09IE5vTW9kZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJlxuICAgICAgICAoY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgc2Vjb25kQXJnXG4gICAgICAgICkpO1xuICAgICAgaWYgKG5leHRSZW5kZXJMYW5lcykge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzXG4gICAgICAgID8gbnVsbCAhPT0gdGhlbmFibGVTdGF0ZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICAgIGZpcnN0Q29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMuX2RlYnVnVGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlU3RhdGUpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmIG51bGwgIT09IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIGN1cnJlbnRIb29rID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIChjdXJyZW50LmZsYWdzICYgMzE0NTcyODApICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMTQ1NzI4MCkgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlIG5vdGlmeSB0aGUgUmVhY3QgdGVhbS5cIlxuICAgICAgICApO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgZWFybHkgcmV0dXJuIHN0YXRlbWVudC5cIlxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSAmJlxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITApKTtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWXG4gICAgICAgID8gKChuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExKSwgKGN1cnJlbnQgPSAhMCkpXG4gICAgICAgIDogKGN1cnJlbnQgPSAhMSk7XG4gICAgICBjdXJyZW50ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guYWRkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJgdXNlYCB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgdHJ5L2NhdGNoIGJsb2NrLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGFuZCBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLiBUbyBoYW5kbGUgZXJyb3JzIHRyaWdnZXJlZCBieSBgdXNlYCwgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhIGVycm9yIGJvdW5kYXJ5LlwiXG4gICAgICAgICAgKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiYgKHRoZW5hYmxlU3RhdGUgPSBudWxsKTtcbiAgICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMTtcbiAgICAgICAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCJcbiAgICAgICAgICApO1xuICAgICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9ICExO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjdXJyZW50SG9vayA9IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgY2hpbGRyZW4ubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgY2hpbGRyZW4uZXZlbnRzID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5zdG9yZXMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT0gY2hpbGRyZW4ubWVtb0NhY2hlICYmIChjaGlsZHJlbi5tZW1vQ2FjaGUuaW5kZXggPSAwKTtcbiAgICAgICAgfVxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCxcbiAgICAgICAgbWF5YmVUaGVuYWJsZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgICAgIG1heWJlVGhlbmFibGUgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZVRoZW5hYmxlLnRoZW5cbiAgICAgICAgICA/IHVzZVRoZW5hYmxlKG1heWJlVGhlbmFibGUpXG4gICAgICAgICAgOiBtYXliZVRoZW5hYmxlO1xuICAgICAgZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgICAgIChudWxsICE9PSBjdXJyZW50SG9vayA/IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsKSAhPT1cbiAgICAgICAgZGlzcGF0Y2hlciAmJiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSAxMDI0KTtcbiAgICAgIHJldHVybiBtYXliZVRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgICAgIHZhciBkaWRSZW5kZXJJZEhvb2sgPSAwICE9PSBsb2NhbElkQ291bnRlcjtcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZVxuICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAtMjAxMzI4NjQ1XG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDUzO1xuICAgICAgY3VycmVudC5sYW5lcyAmPSB+bGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SG9va3NPblVud2luZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MucXVldWU7XG4gICAgICAgICAgbnVsbCAhPT0gcXVldWUgJiYgKHF1ZXVlLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgfVxuICAgICAgcmVuZGVyTGFuZXMgPSAwO1xuICAgICAgaG9va1R5cGVzRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICB2YXIgaG9vayA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IGhvb2spXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vayk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudEhvb2spIHtcbiAgICAgICAgdmFyIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgICAgIG51bGwgIT09IG5leHRDdXJyZW50SG9vayA/IG5leHRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIH0gZWxzZSBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgICBpZiAobnVsbCAhPT0gbmV4dFdvcmtJblByb2dyZXNzSG9vaylcbiAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spLFxuICAgICAgICAgIChjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vayk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT09IG5leHRDdXJyZW50SG9vaykge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlVwZGF0ZSBob29rIGNhbGxlZCBvbiBpbml0aWFsIHJlbmRlci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IEVycm9yKFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICAgICAgbmV4dEN1cnJlbnRIb29rID0ge1xuICAgICAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgICAgICAgbmV4dEN1cnJlbnRIb29rKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHRoZW5hYmxlID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICAgIGluZGV4ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgICAgIG51bGwgPT09XG4gICAgICAgIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSAmJlxuICAgICAgICAoKGluZGV4ID0gaW5kZXguYWx0ZXJuYXRlKSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgICAgIG51bGwgIT09IGluZGV4ICYmIG51bGwgIT09IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYpKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbikgcmV0dXJuIHVzZVRoZW5hYmxlKHVzYWJsZSk7XG4gICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW9DYWNoZShzaXplKSB7XG4gICAgICB2YXIgbWVtb0NhY2hlID0gbnVsbCxcbiAgICAgICAgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCAhPT0gdXBkYXRlUXVldWUgJiYgKG1lbW9DYWNoZSA9IHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSk7XG4gICAgICBpZiAobnVsbCA9PSBtZW1vQ2FjaGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb0NhY2hlKSxcbiAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAobWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGN1cnJlbnQuZGF0YS5tYXAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgbnVsbCA9PSBtZW1vQ2FjaGUgJiYgKG1lbW9DYWNoZSA9IHsgZGF0YTogW10sIGluZGV4OiAwIH0pO1xuICAgICAgbnVsbCA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgKCh1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUpKTtcbiAgICAgIHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSA9IG1lbW9DYWNoZTtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHVwZGF0ZVF1ZXVlIHx8IGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IEFycmF5KHNpemUpLFxuICAgICAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICAgICAgY3VycmVudCA8IHNpemU7XG4gICAgICAgICAgY3VycmVudCsrXG4gICAgICAgIClcbiAgICAgICAgICB1cGRhdGVRdWV1ZVtjdXJyZW50XSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICBlbHNlXG4gICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCAhPT0gc2l6ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgY29uc3RhbnQgc2l6ZSBhcmd1bWVudCBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mIHVzZU1lbW9DYWNoZS4gVGhlIHByZXZpb3VzIGNhY2hlIHdhcyBhbGxvY2F0ZWQgd2l0aCBzaXplICVzIGJ1dCBzaXplICVzIHdhcyByZXF1ZXN0ZWQuXCIsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICBzaXplXG4gICAgICAgICAgKTtcbiAgICAgIG1lbW9DYWNoZS5pbmRleCsrO1xuICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGluaXQpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHJlZHVjZXIgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSByZWR1Y2VyO1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgKTtcbiAgICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSBxdWV1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBZb3UgYXJlIGxpa2VseSBjYWxsaW5nIEhvb2tzIGNvbmRpdGlvbmFsbHksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbClcIlxuICAgICAgICApO1xuICAgICAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICB2YXIgYmFzZVF1ZXVlID0gaG9vay5iYXNlUXVldWUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LmJhc2VRdWV1ZSAhPT0gYmFzZVF1ZXVlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdRdWV1ZSA9IGhvb2suYmFzZVN0YXRlO1xuICAgICAgaWYgKG51bGwgPT09IGJhc2VRdWV1ZSkgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gKGJhc2VGaXJzdCA9IG51bGwpLFxuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsLFxuICAgICAgICAgIHVwZGF0ZSA9IGN1cnJlbnQsXG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZSAmIC01MzY4NzA5MTM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJ0TGFuZSA9IHVwZGF0ZS5yZXZlcnRMYW5lO1xuICAgICAgICAgICAgaWYgKDAgPT09IHJldmVydExhbmUpXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld0Jhc2VRdWV1ZUxhc3QgJiZcbiAgICAgICAgICAgICAgICAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICBlbHNlIGlmICgocmVuZGVyTGFuZXMgJiByZXZlcnRMYW5lKSA9PT0gcmV2ZXJ0TGFuZSkge1xuICAgICAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHVwZGF0ZUxhbmUgPSB7XG4gICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gcmV2ZXJ0TGFuZSk7XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWICYmXG4gICAgICAgICAgICAgIHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHVwZGF0ZS5oYXNFYWdlclN0YXRlXG4gICAgICAgICAgICAgID8gdXBkYXRlLmVhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgOiByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAocmV2ZXJ0TGFuZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVwZGF0ZSAmJiB1cGRhdGUgIT09IGN1cnJlbnQpO1xuICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgPyAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhwZW5kaW5nUXVldWUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiAmJlxuICAgICAgICAgICAgKChyZWR1Y2VyID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSwgbnVsbCAhPT0gcmVkdWNlcikpXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyByZWR1Y2VyO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIGhvb2suYmFzZVN0YXRlID0gYmFzZUZpcnN0O1xuICAgICAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgfVxuICAgICAgbnVsbCA9PT0gYmFzZVF1ZXVlICYmIChxdWV1ZS5sYW5lcyA9IDApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSBxdWV1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBZb3UgYXJlIGxpa2VseSBjYWxsaW5nIEhvb2tzIGNvbmRpdGlvbmFsbHksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbClcIlxuICAgICAgICApO1xuICAgICAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCxcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZyxcbiAgICAgICAgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgdXBkYXRlID0gKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0KTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCB1cGRhdGUuYWN0aW9uKSksICh1cGRhdGUgPSB1cGRhdGUubmV4dCk7XG4gICAgICAgIHdoaWxlICh1cGRhdGUgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgIG9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgbnVsbCA9PT0gaG9vay5iYXNlUXVldWUgJiYgKGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGUpO1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgbmV4dFNuYXBzaG90ID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCB8fFxuICAgICAgICAgICgoZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpKSxcbiAgICAgICAgICBvYmplY3RJcyhuZXh0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSkpO1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGdldFNlcnZlclNuYXBzaG90ID0geyB2YWx1ZTogbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfTtcbiAgICAgIGhvb2sucXVldWUgPSBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgIG1vdW50RWZmZWN0KFxuICAgICAgICBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGdldFNlcnZlclNuYXBzaG90LCBzdWJzY3JpYmUpLFxuICAgICAgICBbc3Vic2NyaWJlXVxuICAgICAgKTtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICBwdXNoRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICBuZXh0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgKSxcbiAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXh0U25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCA9IGlzSHlkcmF0aW5nO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nJGpzY29tcCQwKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksICFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdClcbiAgICAgICkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBvYmplY3RJcyhnZXRTZXJ2ZXJTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChjYWNoZWRTbmFwc2hvdCA9ICFvYmplY3RJcyhcbiAgICAgICAgICAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApKVxuICAgICAgKVxuICAgICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gZ2V0U2VydmVyU25hcHNob3QpLCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgIGhvb2sgPSBob29rLnF1ZXVlO1xuICAgICAgdmFyIGNyZWF0ZSA9IHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaG9vaywgc3Vic2NyaWJlKTtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBbc3Vic2NyaWJlXSk7XG4gICAgICBpZiAoXG4gICAgICAgIGhvb2suZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8XG4gICAgICAgIGNhY2hlZFNuYXBzaG90IHx8XG4gICAgICAgIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2sgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiBIYXNFZmZlY3QpXG4gICAgICApIHtcbiAgICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgICAgKSxcbiAgICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgfHxcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMTYzODQ7XG4gICAgICBmaWJlciA9IHsgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LCB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdCB9O1xuICAgICAgZ2V0U25hcHNob3QgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCA9PT0gZ2V0U25hcHNob3RcbiAgICAgICAgPyAoKGdldFNuYXBzaG90ID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGdldFNuYXBzaG90KSxcbiAgICAgICAgICAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSkpXG4gICAgICAgIDogKChyZW5kZXJlZFNuYXBzaG90ID0gZ2V0U25hcHNob3Quc3RvcmVzKSxcbiAgICAgICAgICBudWxsID09PSByZW5kZXJlZFNuYXBzaG90XG4gICAgICAgICAgICA/IChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKVxuICAgICAgICAgICAgOiByZW5kZXJlZFNuYXBzaG90LnB1c2goZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICAgICAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcbiAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgICAgIGluc3QgPSBpbnN0LnZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgICAgIHJldHVybiAhb2JqZWN0SXMoaW5zdCwgbmV4dFZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBob29rLnF1ZXVlID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICAgICAgdmFyIHF1ZXVlID0gaW5pdGlhbFN0YXRlLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICAgcXVldWVcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZS5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHZhciBxdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgICAgIGhvb2sgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAhMCxcbiAgICAgICAgcXVldWVcbiAgICAgICk7XG4gICAgICBxdWV1ZS5kaXNwYXRjaCA9IGhvb2s7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50LCBwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgaG9vayxcbiAgICAgICAgY3VycmVudEhvb2ssXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZHVjZXIgPyByZWR1Y2VyIDogYmFzaWNTdGF0ZVJlZHVjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50SG9vaylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgaG9vay5xdWV1ZS5kaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uU3RhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgc2V0UGVuZGluZ1N0YXRlLFxuICAgICAgc2V0U3RhdGUsXG4gICAgICBwYXlsb2FkXG4gICAgKSB7XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpXG4gICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBmb3JtIHN0YXRlIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICBmaWJlciA9IGFjdGlvblF1ZXVlLmFjdGlvbjtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgICAgICB2YXIgYWN0aW9uTm9kZSA9IHtcbiAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgIGFjdGlvbjogZmliZXIsXG4gICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICBpc1RyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBhY3Rpb25Ob2RlLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlRcbiAgICAgICAgICA/IHNldFBlbmRpbmdTdGF0ZSghMClcbiAgICAgICAgICA6IChhY3Rpb25Ob2RlLmlzVHJhbnNpdGlvbiA9ICExKTtcbiAgICAgICAgc2V0U3RhdGUoYWN0aW9uTm9kZSk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICAgIG51bGwgPT09IHNldFBlbmRpbmdTdGF0ZVxuICAgICAgICAgID8gKChhY3Rpb25Ob2RlLm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uTm9kZSksXG4gICAgICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSkpXG4gICAgICAgICAgOiAoKGFjdGlvbk5vZGUubmV4dCA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gc2V0UGVuZGluZ1N0YXRlLm5leHQgPSBhY3Rpb25Ob2RlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBub2RlKSB7XG4gICAgICB2YXIgYWN0aW9uID0gbm9kZS5hY3Rpb24sXG4gICAgICAgIHBheWxvYWQgPSBub2RlLnBheWxvYWQsXG4gICAgICAgIHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlO1xuICAgICAgaWYgKG5vZGUuaXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5ULl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpLFxuICAgICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAgICAgKChhY3Rpb25RdWV1ZSA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgICAxMCA8IGFjdGlvblF1ZXVlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAoY3VycmVudFRyYW5zaXRpb24gPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSksXG4gICAgICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgY3VycmVudFRyYW5zaXRpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvciQzKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IkMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKSB7XG4gICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgID8gKHJldHVyblZhbHVlLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGUuaXNUcmFuc2l0aW9uIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkFuIGFzeW5jIGZ1bmN0aW9uIHdhcyBwYXNzZWQgdG8gdXNlQWN0aW9uU3RhdGUsIGJ1dCBpdCB3YXMgZGlzcGF0Y2hlZCBvdXRzaWRlIG9mIGFuIGFjdGlvbiBjb250ZXh0LiBUaGlzIGlzIGxpa2VseSBub3Qgd2hhdCB5b3UgaW50ZW5kZWQuIEVpdGhlciBwYXNzIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB0byBhbiBgYWN0aW9uYCBwcm9wLCBvciBkaXNwYXRjaCBtYW51YWxseSBpbnNpZGUgYHN0YXJ0VHJhbnNpdGlvbmBcIlxuICAgICAgICAgICAgKSlcbiAgICAgICAgOiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBuZXh0U3RhdGUpIHtcbiAgICAgIGFjdGlvbk5vZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIGFjdGlvbk5vZGUudmFsdWUgPSBuZXh0U3RhdGU7XG4gICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSk7XG4gICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCAhPT0gYWN0aW9uTm9kZSAmJlxuICAgICAgICAoKG5leHRTdGF0ZSA9IGFjdGlvbk5vZGUubmV4dCksXG4gICAgICAgIG5leHRTdGF0ZSA9PT0gYWN0aW9uTm9kZVxuICAgICAgICAgID8gKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsKVxuICAgICAgICAgIDogKChuZXh0U3RhdGUgPSBuZXh0U3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZS5uZXh0ID0gbmV4dFN0YXRlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBuZXh0U3RhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIGVycm9yKSB7XG4gICAgICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0KSB7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgICAgIGRvXG4gICAgICAgICAgKGFjdGlvbk5vZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLnJlYXNvbiA9IGVycm9yKSxcbiAgICAgICAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKGFjdGlvbk5vZGUgIT09IGxhc3QpO1xuICAgICAgfVxuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLmxpc3RlbmVycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uTm9kZS5sZW5ndGg7IGkrKykgKDAsIGFjdGlvbk5vZGVbaV0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlUmVkdWNlcihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3ApIHtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgc3NyRm9ybVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290LmZvcm1TdGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHNzckZvcm1TdGF0ZSkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoaW5nID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5Sb290T3JTaW5nbGV0b24gPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICAgICAgICA4ICE9PSBtYXJrZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpblJvb3RPclNpbmdsZXRvbiA9IG1hcmtlckluc3RhbmNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIGluUm9vdE9yU2luZ2xldG9uID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HIHx8XG4gICAgICAgICAgICAgICAgICAgIGluUm9vdE9yU2luZ2xldG9uID09PSBGT1JNX1NUQVRFX0lTX05PVF9NQVRDSElOR1xuICAgICAgICAgICAgICAgICAgICAgID8gbWFya2VySW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlzTWF0Y2hpbmcgPSBtYXJrZXJJbnN0YW5jZS5kYXRhID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGlzTWF0Y2hpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNYXRjaGluZyA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hdGNoaW5nICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHNzckZvcm1TdGF0ZS5tZW1vaXplZFN0YXRlID0gc3NyRm9ybVN0YXRlLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG4gICAgICBpc01hdGNoaW5nID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgICAgIH07XG4gICAgICBzc3JGb3JtU3RhdGUucXVldWUgPSBpc01hdGNoaW5nO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBpc01hdGNoaW5nXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZy5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICBpblJvb3RPclNpbmdsZXRvbiA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICExLFxuICAgICAgICBpc01hdGNoaW5nLnF1ZXVlXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZyA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBtYXJrZXJJbnN0YW5jZSA9IHtcbiAgICAgICAgc3RhdGU6IGluaXRpYWxTdGF0ZVByb3AsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgcGVuZGluZzogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzTWF0Y2hpbmcucXVldWUgPSBtYXJrZXJJbnN0YW5jZTtcbiAgICAgIHNzckZvcm1TdGF0ZSA9IGRpc3BhdGNoQWN0aW9uU3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgbWFya2VySW5zdGFuY2UsXG4gICAgICAgIGluUm9vdE9yU2luZ2xldG9uLFxuICAgICAgICBzc3JGb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBtYXJrZXJJbnN0YW5jZS5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRIb29rLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgc3RhdGVIb29rLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgICAgICBhY3Rpb25TdGF0ZVJlZHVjZXJcbiAgICAgIClbMF07XG4gICAgICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPVxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgICA6IGN1cnJlbnRTdGF0ZUhvb2s7XG4gICAgICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICAgICAgYWN0aW9uICE9PSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKTtcbiAgICAgIHJldHVybiBbY3VycmVudFN0YXRlSG9vaywgZGlzcGF0Y2gsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUuZGlzcGF0Y2g7XG4gICAgICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICAgICAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGluc3Q6IGluc3QsIGRlcHM6IGRlcHMsIG5leHQ6IG51bGwgfTtcbiAgICAgIGNyZWF0ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAgICAgKChjcmVhdGUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNyZWF0ZSkpO1xuICAgICAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICAgICAgbnVsbCA9PT0gaW5zdFxuICAgICAgICA/IChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZy5uZXh0ID0gdGFnKVxuICAgICAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAgICAgKGluc3QubmV4dCA9IHRhZyksXG4gICAgICAgICAgKHRhZy5uZXh0ID0gZGVwcyksXG4gICAgICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmXG4gICAgICBudWxsICE9PSBkZXBzICYmXG4gICAgICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgICA/IChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBkZXBzKSlcbiAgICAgICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoXG4gICAgICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgICAgICBjcmVhdGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSkgPT09IE5vTW9kZVxuICAgICAgICA/IG1vdW50RWZmZWN0SW1wbCgxNDI2MDgzODQsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcylcbiAgICAgICAgOiBtb3VudEVmZmVjdEltcGwoODM5MDY1NiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cCA/IHJlZkNsZWFudXAoKSA6IHJlZihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSByZWYgJiYgdm9pZCAwICE9PSByZWYpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgcmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICAgIFwiYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhyZWYpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjcmVhdGUgPSBjcmVhdGUoKSksXG4gICAgICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdmFyIGZpYmVyRmxhZ3MgPSA0MTk0MzA4O1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgIG1vdW50RWZmZWN0SW1wbChcbiAgICAgICAgZmliZXJGbGFncyxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgICAgIDQsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50SG9va1xuICAgICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgICAgIG9iamVjdElzKGhvb2ssIHByZXZWYWx1ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgaG9va1xuICAgICAgICApO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIDQyKSlcbiAgICAgICAgcmV0dXJuIChkaWRSZWNlaXZlVXBkYXRlID0gITApLCAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9XG4gICAgICAgIDAgIT09IHByZXZpb3VzUHJpb3JpdHkgJiYgcHJldmlvdXNQcmlvcml0eSA8IENvbnRpbnVvdXNFdmVudFByaW9yaXR5XG4gICAgICAgICAgPyBwcmV2aW91c1ByaW9yaXR5XG4gICAgICAgICAgOiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgITEsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUoXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgeyB0aGVuOiBmdW5jdGlvbiAoKSB7fSwgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogZXJyb3IgfSxcbiAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgMTAgPCBmaWJlciAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRIb3N0VHJhbnNpdGlvbihmb3JtRmliZXIsIHBlbmRpbmdTdGF0ZSwgYWN0aW9uLCBmb3JtRGF0YSkge1xuICAgICAgaWYgKDUgIT09IGZvcm1GaWJlci50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGZvcm0gaW5zdGFuY2UgdG8gYmUgYSBIb3N0Q29tcG9uZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgcXVldWUgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpLnF1ZXVlO1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgICBmb3JtRmliZXIsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICAgIE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBudWxsID09PSBhY3Rpb25cbiAgICAgICAgICA/IG5vb3AkMlxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUZpYmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihmb3JtRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpIHtcbiAgICAgIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGV4aXN0aW5nU3RhdGVIb29rKSByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBleGlzdGluZ1N0YXRlSG9vayA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIGJhc2VTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvblxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgdmFyIGluaXRpYWxSZXNldFN0YXRlID0ge307XG4gICAgICBleGlzdGluZ1N0YXRlSG9vay5uZXh0ID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICAgICAgYmFzZVN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rO1xuICAgICAgZm9ybUZpYmVyID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGZvcm1GaWJlciAmJiAoZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vayk7XG4gICAgICByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RGb3JtUmVzZXQkMShmb3JtRmliZXIpIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInJlcXVlc3RGb3JtUmVzZXQgd2FzIGNhbGxlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciBhY3Rpb24uIFRvIGZpeCwgbW92ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciByZXNldFN0YXRlUXVldWUgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpLm5leHQucXVldWU7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgcmVzZXRTdGF0ZVF1ZXVlLFxuICAgICAgICB7fSxcbiAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZm9ybUZpYmVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBzdGF0ZUhvb2sucXVldWUsXG4gICAgICAgICEwLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICAgIHJldHVybiBbITEsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChIb3N0VHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudElkKCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHRyZWVJZCA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAoXG4gICAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICAgKS50b1N0cmluZygzMikgKyB0cmVlSWQ7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIlJcIiArIHRyZWVJZDtcbiAgICAgICAgdHJlZUlkID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgMCA8IHRyZWVJZCAmJiAoaWRlbnRpZmllclByZWZpeCArPSBcIkhcIiArIHRyZWVJZC50b1N0cmluZygzMikpO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ICs9IFwiOlwiO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlSWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKyksXG4gICAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICAgICAgXCI6XCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJyXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpICsgXCI6XCIpO1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICAgICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSkge1xuICAgICAgZm9yICh2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47IG51bGwgIT09IHByb3ZpZGVyOyApIHtcbiAgICAgICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWJlci5wYXlsb2FkID0geyBjYWNoZTogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgICAgICA/IGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgYWN0aW9uKVxuICAgICAgICA6ICgoYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IGFjdGlvbiAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICkpKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb24sXG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICApIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICAgICk7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAgICAgKChhbHRlcm5hdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyKSwgbnVsbCAhPT0gYWx0ZXJuYXRlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlID0gYWx0ZXJuYXRlKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICB0aHJvd0lmRHVyaW5nUmVuZGVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgMCA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IDIsXG4gICAgICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAgICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAyXG4gICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih0aHJvd0lmRHVyaW5nUmVuZGVyLCBmaWJlciwgMik7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHxcbiAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIHF1ZXVlLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5leHRQcm9wc1xuICAgICkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICAoKGN0b3IgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY3RvcikgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjdG9yKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICApKSk7XG4gICAgICBwcmV2U3RhdGUgPVxuICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICA/IHByZXZTdGF0ZVxuICAgICAgICAgIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICApO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZvaWQgMCA9PT0gb2xkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBvbGRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkpLFxuICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICAgICAgaWYgKFwicmVmXCIgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIG5ld1Byb3BzID09PSBiYXNlUHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcykpO1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gQ29tcG9uZW50KVxuICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBDb21wb25lbnRbX3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRPblVuY2F1Z2h0RXJyb3IoZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgZXJyb3IgPSBjb21wb25lbnROYW1lXG4gICAgICAgID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgOiBcIkFuIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCI7XG4gICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBcIkNvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcblZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRPbkNhdWdodEVycm9yKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICAgIDogXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIixcbiAgICAgICAgcmVjcmVhdGVNZXNzYWdlID1cbiAgICAgICAgICBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIHVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICtcbiAgICAgICAgICAoKGVycm9yQm91bmRhcnlOYW1lIHx8IFwiQW5vbnltb3VzXCIpICsgXCIuXCIpLFxuICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCAhPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiBcIlwiO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICA/IGJpbmRUb0NvbnNvbGUoXG4gICAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmVjcmVhdGVNZXNzYWdlXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgICAgICAgKSgpXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlXG4gICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlKVxuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG9uVW5jYXVnaHRFcnJvciA9IHJvb3Qub25VbmNhdWdodEVycm9yO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlJDQpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZSQ0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgICAgICBvbkNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUkNSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlJDU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdCwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gICAgICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgbGFuZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAgICAgbGFuZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gICAgICBsYW5lLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihlcnJvckluZm8uc291cmNlLCBsb2dVbmNhdWdodEVycm9yLCByb290LCBlcnJvckluZm8pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKSB7XG4gICAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBlcnJvckluZm8uc291cmNlLFxuICAgICAgICAgICAgbG9nQ2F1Z2h0RXJyb3IsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBlcnJvckluZm9cbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICBudWxsICE9PSBpbnN0ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgKHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBlcnJvckluZm8uc291cmNlLFxuICAgICAgICAgICAgbG9nQ2F1Z2h0RXJyb3IsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBlcnJvckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkXG4gICAgICAgICAgICAgID8gKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbdGhpc10pKVxuICAgICAgICAgICAgICA6IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZCh0aGlzKSk7XG4gICAgICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYodGhpcywgZXJyb3JJbmZvKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICgwID09PSAoZmliZXIubGFuZXMgJiAyKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihcbiAgICAgIHJvb3QsXG4gICAgICByZXR1cm5GaWJlcixcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgdmFsdWUsXG4gICAgICByb290UmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IDMyNzY4O1xuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudGhlblxuICAgICAgKSB7XG4gICAgICAgIHJldHVybkZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITApO1xuICAgICAgICBzb3VyY2VGaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzb3VyY2VGaWJlcikge1xuICAgICAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgID8gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgIDogcmV0dXJuRmliZXIuYWRkKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZTogbmV3IFNldChbdmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXIucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlci5yZXRyeVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2VGaWJlci5hZGQodmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgK1xuICAgICAgICAgICAgICBcIikuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITApLFxuICAgICAgICAgIChyZXR1cm5GaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/ICgwID09PSAocmV0dXJuRmliZXIuZmxhZ3MgJiA2NTUzNikgJiYgKHJldHVybkZpYmVyLmZsYWdzIHw9IDI1NiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyBmcm9tIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgKHJvb3QuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocm9vdC5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAodmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpKSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICByb290LnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShyb290LCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCkpLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICB2YXIgZXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgRXJyb3IoXG4gICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgc3luY2hyb25vdXNseSByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgKSxcbiAgICAgICAgc291cmNlRmliZXJcbiAgICAgICk7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdKVxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpO1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSByZXR1cm4gITA7XG4gICAgICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyO1xuICAgICAgZG8ge1xuICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdFJlbmRlckxhbmVzICYgLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgc291cmNlRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdCksXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnR5cGUpLFxuICAgICAgICAgICAgICAoZXJyb3IgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAwID09PSAoc291cmNlRmliZXIuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAgICAgKG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVycm9yLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoZXJyb3IpKSkpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShyb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHNvdXJjZUZpYmVyKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPVxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5yZW5kZXI7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKFwicmVmXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5leHRQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV0pO1xuICAgICAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IG5leHRQcm9wcztcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcHJvcHNXaXRob3V0UmVmLFxuICAgICAgICByZWYsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAga2V5ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIGtleSAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAhc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgIG51bGwgPT09IENvbXBvbmVudC5jb21wYXJlXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMTUpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQpLFxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKSxcbiAgICAgICAgICAgIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIENvbXBvbmVudC50eXBlLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IHR5cGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgICAgIENvbXBvbmVudCA9IG51bGwgIT09IENvbXBvbmVudCA/IENvbXBvbmVudCA6IHNoYWxsb3dFcXVhbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIENvbXBvbmVudChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgICAgICBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICBjdXJyZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3ModHlwZSwgbmV4dFByb3BzKTtcbiAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSBjdXJyZW50LnR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBuZXh0UHJvcHMgPSBwcmV2UHJvcHMpLFxuICAgICAgICAgICAgY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSAmJiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAwICE9PVxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpLFxuICAgICAgICBwcmV2U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKFwiaGlkZGVuXCIgPT09IG5leHRQcm9wcy5tb2RlIHx8IG5leHRJc0RldGFjaGVkKSB7XG4gICAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKSB7XG4gICAgICAgICAgbmV4dFByb3BzID1cbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKG5leHRJc0RldGFjaGVkID0gMDsgbnVsbCAhPT0gbmV4dENoaWxkcmVuOyApXG4gICAgICAgICAgICAgIChuZXh0SXNEZXRhY2hlZCA9XG4gICAgICAgICAgICAgICAgbmV4dElzRGV0YWNoZWQgfCBuZXh0Q2hpbGRyZW4ubGFuZXMgfCBuZXh0Q2hpbGRyZW4uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5zaWJsaW5nKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBuZXh0SXNEZXRhY2hlZCAmIH5uZXh0UHJvcHM7XG4gICAgICAgICAgfSBlbHNlICh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpO1xuICAgICAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSlcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHsgYmFzZUxhbmVzOiAwLCBjYWNoZVBvb2w6IG51bGwgfSksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHB1c2hUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKVxuICAgICAgICAgICAgICA6IHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgICBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICAgID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgID8gKHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUuY2FjaGVQb29sKSxcbiAgICAgICAgICAgIHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCkpXG4gICAgICAgICAgOiAobnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCksXG4gICAgICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRCYXNlTGFuZXMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgcG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgfTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAhMCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGlmIChudWxsID09PSByZWYpXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50LnJlZiAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVmICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIHVuZGVmaW5lZC9udWxsLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZilcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmXG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgIENvbXBvbmVudC5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAoKGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICkpKSk7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBDb21wb25lbnQgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIG5leHRQcm9wcyA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBuZXh0UHJvcHMgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHNlY29uZEFyZyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHNlY29uZEFyZ1xuICAgICAgKTtcbiAgICAgIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBDb21wb25lbnQgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHNob3VsZEVycm9ySW1wbCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLFxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgd29ya0luUHJvZ3Jlc3MudHlwZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbnRleHRcbiAgICAgICAgICAgICkuc3RhdGU7XG4gICAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKF9pbnN0YW5jZSwgc3RhdGUsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICEwOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NTUzNjtcbiAgICAgICAgICBfaW5zdGFuY2UgPSBFcnJvcihcIlNpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29sc1wiKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IGxhbmU7XG4gICAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHN0YXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxhbmUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBsYW5lKTtcbiAgICAgIH1cbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIENvbXBvbmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZSAmJlxuICAgICAgICAgICh2b2lkIDAgPT09IF9pbnN0YW5jZSB8fCBfaW5zdGFuY2UuJCR0eXBlb2YgIT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IF9pbnN0YW5jZVxuICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuIFRoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvIHRyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS5cIlxuICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhIFwiICsgdHlwZW9mIF9pbnN0YW5jZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgOiBfaW5zdGFuY2UuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICA6IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnN0YW5jZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ9LlwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuIGNvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICkpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX2luc3RhbmNlICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoX2luc3RhbmNlKSk7XG4gICAgICAgIF9pbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobmV4dFByb3BzLCBzdGF0ZSk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJiB2b2lkIDAgIT09IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2Uuc3RhdGVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgX2luc3RhbmNlLl9yZWFjdEludGVybmFscyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gc3RhdGUgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKHN0YXRlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gX2luc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IChsYW5lID0gc3RhdGUgPSBudWxsKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoc3RhdGUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAoc3RhdGUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGxhbmUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGxhbmUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUgfHwgbnVsbCAhPT0gbGFuZSB8fCBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lKSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgdmFyIG5ld0FwaU5hbWUgPVxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2luc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2luc3RhbmNlKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbiVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5odHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHN0YXRlID8gXCJcXG4gIFwiICsgc3RhdGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGxhbmUgPyBcIlxcbiAgXCIgKyBsYW5lIDogXCJcIixcbiAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6IFwiXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICBfaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgKENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgIV9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICBfaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgX2luc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAhX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImdldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/IFRoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX2luc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBsYW5lID0gX2luc3RhbmNlLnByb3BzICE9PSBuZXh0UHJvcHM7XG4gICAgICAgIHZvaWQgMCAhPT0gX2luc3RhbmNlLnByb3BzICYmXG4gICAgICAgICAgbGFuZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKENvbXBvbmVudCkgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudClcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIChsYW5lID0gX2luc3RhbmNlLnN0YXRlKSAmJlxuICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2YgbGFuZSB8fCBpc0FycmF5SW1wbChsYW5lKSkgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIHN0YXRlKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5yZWZzID0ge307XG4gICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBfaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHN0YXRlICYmIG51bGwgIT09IHN0YXRlXG4gICAgICAgICAgICA/IHJlYWRDb250ZXh0KHN0YXRlKVxuICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9PT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgKChzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSBiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJlxuICAgICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzdGF0ZSAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgKChzdGF0ZSA9IF9pbnN0YW5jZS5zdGF0ZSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIHN0YXRlICE9PSBfaW5zdGFuY2Uuc3RhdGUgJiZcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSxcbiAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCk7XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgICBfaW5zdGFuY2UgPSAhMDtcbiAgICAgIH0gZWxzZSBpZiAobnVsbCA9PT0gY3VycmVudCRqc2NvbXAkMCkge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBsYW5lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBsYW5lO1xuICAgICAgICB2YXIgb2xkQ29udGV4dCA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoZm91bmRXaWxsVXBkYXRlTmFtZSkpO1xuICAgICAgICBuZXdBcGlOYW1lID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBzdGF0ZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICBvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZFN0YXRlICE9PSBvbGRDb250ZXh0IHx8IGhhc0ZvcmNlVXBkYXRlXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGxhbmUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGV4dCxcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCkpXG4gICAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb2xkQ29udGV4dCkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gb2xkQ29udGV4dCksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBzdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gbGFuZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQkanNjb21wJDAsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBzdGF0ZSk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGZvdW5kV2lsbFVwZGF0ZU5hbWU7XG4gICAgICAgIG5ld0FwaU5hbWUgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIG9sZFN0YXRlID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIG9sZENvbnRleHQgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIGxhbmUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgbnVsbCAhPT0gb2xkQ29udGV4dCAmJlxuICAgICAgICAgIChsYW5lID0gcmVhZENvbnRleHQob2xkQ29udGV4dCkpO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAob2xkQ29udGV4dCA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgoc3RhdGUgIT09IG5ld0FwaU5hbWUgfHwgb2xkU3RhdGUgIT09IGxhbmUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBuZXdTdGF0ZSB8fFxuICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAobnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzKSlcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzKSkpXG4gICAgICAgICAgICAgID8gKG9sZENvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXdTdGF0ZSwgbGFuZSksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGUpKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IGxhbmUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGZvdW5kV2lsbFVwZGF0ZU5hbWUpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH1cbiAgICAgIGxhbmUgPSBfaW5zdGFuY2U7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQkanNjb21wJDAsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN0YXRlID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIGlmIChsYW5lIHx8IHN0YXRlKSB7XG4gICAgICAgIGxhbmUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICBpZiAoc3RhdGUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcilcbiAgICAgICAgICAoQ29tcG9uZW50ID0gbnVsbCksIChwcm9maWxlclN0YXJ0VGltZSA9IC0xKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIENvbXBvbmVudCA9IGNhbGxSZW5kZXJJbkRFVihsYW5lKTtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNhbGxSZW5kZXJJbkRFVihsYW5lKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmIHN0YXRlXG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLmNoaWxkLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbGFuZS5zdGF0ZTtcbiAgICAgICAgY3VycmVudCRqc2NvbXAkMCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGN1cnJlbnQkanNjb21wJDAgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgX2luc3RhbmNlICYmXG4gICAgICAgIHJlbmRlckxhbmVzLnByb3BzICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiYSBjb21wb25lbnRcIlxuICAgICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITApKTtcbiAgICAgIHJldHVybiBjdXJyZW50JGpzY29tcCQwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNTY7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gICAgICBDb21wb25lbnQgJiZcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4gICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uXCIsXG4gICAgICAgICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFt3b3JrSW5Qcm9ncmVzc10gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlwiLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSA9XG4gICAgICAgICAgICAhMCkpKTtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gQ29tcG9uZW50LmNvbnRleHRUeXBlICYmXG4gICAgICAgICgoQ29tcG9uZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbQ29tcG9uZW50XSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS5cIixcbiAgICAgICAgICAgIENvbXBvbmVudFxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdID0gITApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIHsgYmFzZUxhbmVzOiByZW5kZXJMYW5lcywgY2FjaGVQb29sOiBnZXRTdXNwZW5kZWRDYWNoZSgpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHByaW1hcnlUcmVlRGlkRGVmZXIsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LmNoaWxkTGFuZXMgJiB+cmVuZGVyTGFuZXMgOiAwO1xuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlciAmJiAoY3VycmVudCB8PSB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3O1xuICAgICAgdmFyIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgc2hvdWxkU3VzcGVuZEltcGwod29ya0luUHJvZ3Jlc3MpICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgdmFyIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID0gITE7XG4gICAgICB2YXIgZGlkU3VzcGVuZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ID0gZGlkU3VzcGVuZCkgfHxcbiAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjMxNyA9XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gITFcbiAgICAgICAgICAgIDogMCAhPT0gKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ICYmXG4gICAgICAgICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkgPSAhMCksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTI5KSk7XG4gICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzIzMTcgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMik7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOVxuICAgICAgICAgICAgPyBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICA6IHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgaWYgKCEoSlNDb21waWxlcl90ZW1wID0gIUpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYpKSB7XG4gICAgICAgICAgICAgIGM6IHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2O1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICAgICAgOCAhPT0gaW5zdGFuY2Uubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmICghSlNDb21waWxlcl90ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBjO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWh5ZHJhdGVkOiBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgICAgICAgIHRyZWVDb250ZXh0OlxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHRyZWVDb250ZXh0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogdHJlZUNvbnRleHRJZCwgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3cgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXRyeUxhbmU6IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjcmVhdGVGaWJlcigxOCwgbnVsbCwgbnVsbCwgTm9Nb2RlKSksXG4gICAgICAgICAgICAgICAgICAoaW5zdGFuY2Uuc3RhdGVOb2RlID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgICAgICAgIChpbnN0YW5jZS5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9ICEwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAgPSAhMSk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9ICFKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgKHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTZcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYgJiZcbiAgICAgICAgICAgICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYuZGF0YSA9PT1cbiAgICAgICAgICAgICAgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQVxuICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTguY2hpbGRyZW47XG4gICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID1cbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOC5mYWxsYmFjaztcbiAgICAgICAgaWYgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9XG4gICAgICAgICAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTZcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2LnNpYmxpbmcgPVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2KSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSA9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOS5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkuY2hpbGRMYW5lcyA9XG4gICAgICAgICAgICAgIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4XG4gICAgICAgICAgKTtcbiAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlICYmXG4gICAgICAgICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkKSxcbiAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNilcbiAgICAgICkge1xuICAgICAgICBpZiAoZGlkU3VzcGVuZClcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICAgICAgPyAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICAgIDogKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LmZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9XG4gICAgICAgICAgICAgICAgICBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTguY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNlxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID1cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOS5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTgucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOS5yZXR1cm4gPVxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOC5zaWJsaW5nID1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCksXG4gICAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTgubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTguY2hpbGRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkpKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNi5kYXRhID09PVxuICAgICAgICAgICAgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYubmV4dFNpYmxpbmcuZGF0YXNldDtcbiAgICAgICAgICBpZiAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3KSB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzIzMTcuZGdzdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3Lm1zZztcbiAgICAgICAgICAgIGluc3RhbmNlID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LnN0Y2s7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzIzMTcuY3N0Y2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYgPSBtZXNzYWdlO1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjMxNyA9IEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IGluc3RhbmNlO1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID1cbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5ID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTZcbiAgICAgICAgICAgICAgPyBFcnJvcihKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2KVxuICAgICAgICAgICAgICA6IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5IGR1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkuc3RhY2sgPVxuICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTggfHwgXCJcIjtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOS5kaWdlc3QgPVxuICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3O1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjMxNyA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IEpTQ29tcGlsZXJfdGVtcCA/IG51bGwgOiBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTggPSB7XG4gICAgICAgICAgICB2YWx1ZTogSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTksXG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBzdGFjazogSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ICYmXG4gICAgICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4KTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ID1cbiAgICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQuY2hpbGRMYW5lcykpLFxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHwgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3KVxuICAgICAgICApIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzIzMTcgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgIT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjMxNykge1xuICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTggPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgICAgICAgIGlmICgwICE9PSAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTggJiA0MikpXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3dpdGNoIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID0gMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgICAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICAgICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICAgICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICAgICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICAgICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IDY0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IDEzNDIxNzcyODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID1cbiAgICAgICAgICAgICAgMCAhPT1cbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ICZcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LnN1c3BlbmRlZExhbmVzIHxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAwICE9PSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCAmJlxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCAhPT0gcHJldlN0YXRlLnJldHJ5TGFuZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKChwcmV2U3RhdGUucmV0cnlMYW5lID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTgpLFxuICAgICAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYuZGF0YSA9PT1cbiAgICAgICAgICAgIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSB8fCByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNi5kYXRhID09PVxuICAgICAgICAgIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQVxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNi5fcmVhY3RSZXRyeSA9XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgIDogKChjdXJyZW50ID0gcHJldlN0YXRlLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2Lm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gY3VycmVudC5vdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcykpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LmNoaWxkcmVuXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkgPVxuICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTguZmFsbGJhY2spLFxuICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2ID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgIChpbnN0YW5jZSA9IEpTQ29tcGlsZXJfdGVtcC5zaWJsaW5nKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTggPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LmNoaWxkcmVuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LnN1YnRyZWVGbGFncyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlXG4gICAgICAgICAgICA/IChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSA9XG4gICAgICAgICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5XG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogKChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSA9XG4gICAgICAgICAgICAgICAgY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjMxOSxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5LmZsYWdzIHw9IDIpKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkucmV0dXJuID1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzIzMTgucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOC5zaWJsaW5nID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5KSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOCksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4ID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yMzE5KSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTZcbiAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzIzMTYgPVxuICAgICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA6ICgoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2LmNhY2hlUG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChpbnN0YW5jZSA9IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAucGFyZW50ICE9PSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgID8geyBwYXJlbnQ6IGluc3RhbmNlLCBwb29sOiBpbnN0YW5jZSB9XG4gICAgICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXApKVxuICAgICAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCA9IGdldFN1c3BlbmRlZENhY2hlKCkpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjMxNiA9IHtcbiAgICAgICAgICAgICAgICBiYXNlTGFuZXM6XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2LmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yMzE2KSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzIzMTkuY2hpbGRMYW5lcyA9XG4gICAgICAgICAgICBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjMxOFxuICAgICAgICApO1xuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlbmRlckxhbmVzID0gY3VycmVudC5jaGlsZDtcbiAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcy5zaWJsaW5nO1xuICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyZW5kZXJMYW5lcywge1xuICAgICAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICAgICAgY2hpbGRyZW46IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yMzE4LmNoaWxkcmVuXG4gICAgICB9KTtcbiAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3ID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zKSxcbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3XG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgIDogSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yMzE3LnB1c2goY3VycmVudCkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlbmRlckxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pIHtcbiAgICAgIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlbiB9LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlXG4gICAgICApO1xuICAgICAgcHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnQuZmxhZ3MgfD0gMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5SW1wbChjaGlsZFNsb3QpO1xuICAgICAgY2hpbGRTbG90ID0gIWlzQW5BcnJheSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCk7XG4gICAgICByZXR1cm4gaXNBbkFycmF5IHx8IGNoaWxkU2xvdFxuICAgICAgICA/ICgoaXNBbkFycmF5ID0gaXNBbkFycmF5ID8gXCJhcnJheVwiIDogXCJpdGVyYWJsZVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiBhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uIDwvU3VzcGVuc2VMaXN0PlwiLFxuICAgICAgICAgICAgaXNBbkFycmF5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpc0FuQXJyYXlcbiAgICAgICAgICApLFxuICAgICAgICAgICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGlzQmFja3dhcmRzLFxuICAgICAgdGFpbCxcbiAgICAgIGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbE1vZGVcbiAgICApIHtcbiAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZVxuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAoKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHMpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcixcbiAgICAgICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgdm9pZCAwICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidG9nZXRoZXJcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXVxuICAgICAgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSAhMCksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJldmVhbE9yZGVyKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFVzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFJlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICB2b2lkIDAgPT09IHRhaWxNb2RlIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSB8fFxuICAgICAgICAoXCJjb2xsYXBzZWRcIiAhPT0gdGFpbE1vZGUgJiYgXCJoaWRkZW5cIiAhPT0gdGFpbE1vZGVcbiAgICAgICAgICA/ICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICA6IFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuIERpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgYTogaWYgKFxuICAgICAgICAoXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fCBcImJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlcikgJiZcbiAgICAgICAgdm9pZCAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICExICE9PSBuZXh0UHJvcHNcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5leHRQcm9wcykpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChuZXh0UHJvcHNbaV0sIGkpKSBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihuZXh0UHJvcHMpKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpIHtcbiAgICAgICAgICBpZiAoKGkgPSBpLmNhbGwobmV4dFByb3BzKSkpXG4gICAgICAgICAgICBmb3IgKHZhciBzdGVwID0gaS5uZXh0KCksIF9pID0gMDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGkubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuIERpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpXG4gICAgICAgIChuZXh0UHJvcHMgPVxuICAgICAgICAgIChuZXh0UHJvcHMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGlmICgxOSA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLnJldHVybiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudC5yZXR1cm4gfHwgY3VycmVudC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuc2libGluZy5yZXR1cm4gPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICBuZXh0UHJvcHMgJj0gU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG4gICAgICB9XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAocmV2ZWFsT3JkZXIgPSBudWxsOyBudWxsICE9PSByZW5kZXJMYW5lczsgKVxuICAgICAgICAgICAgKGN1cnJlbnQgPSByZW5kZXJMYW5lcy5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMuc2libGluZyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbCkpO1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsO1xuICAgICAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7IG51bGwgIT09IHJldmVhbE9yZGVyOyApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuc2libGluZztcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICByZXZlYWxPcmRlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITAsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcztcbiAgICAgIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgIHRocm93IEVycm9yKFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nID1cbiAgICAgICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpKSByZXR1cm4gITA7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4O1xuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkTGFuZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICAgICAgc3RhdGVOb2RlIHx8XG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpKTtcbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRCZWZvcmUgJiZcbiAgICAgICAgICAgICgoZGlkU3VzcGVuZEJlZm9yZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLmxhc3RFZmZlY3QgPSBudWxsKSk7XG4gICAgICAgICAgcHVzaChcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN0YXRlTm9kZSkgYnJlYWs7XG4gICAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMCksXG4gICAgICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDYWNoZUNvbnRleHQsXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Mua2V5LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHRocm93IEVycm9yKFwiQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuXCIpO1xuICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHJlbmRlckxhbmVzLmluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIHJlbmRlckxhbmVzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgcmVuZGVyTGFuZXMuX2RlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpXG4gICAgICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLlwiKTtcbiAgICAgICAgICBmb3IgKDsgcHJldlNpYmxpbmcuc2libGluZyAhPT0gd29ya0luUHJvZ3Jlc3M7IClcbiAgICAgICAgICAgIGlmICgoKHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZyksIG51bGwgPT09IHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLlwiKTtcbiAgICAgICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZW5kZXJMYW5lcy5mbGFncyB8PSAyO1xuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgICAgICBpZiAoKHJldHVybkZpYmVyID0gaXNIeWRyYXRpbmcpKVxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikpO1xuICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5pbmRleCksXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgcmV0dXJuRmliZXIpKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QoY3VycmVudClcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IGN1cnJlbnQuJCR0eXBlb2YpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U2libGluZyA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgXCIgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT9cIik7XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN1cnJlbnQpIHx8IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICtcbiAgICAgICAgICAgICAgICBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgK1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICBwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHByZXZTaWJsaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgbmV4dFByb3BzICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocHJldlNpYmxpbmcuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGlzRGVoeWRyYXRlZDogITEsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlIGh5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8uZmlyc3RDaGlsZFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgPSAhMCxcbiAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSxcbiAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITAsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoY3VycmVudC5mbGFncyA9IChjdXJyZW50LmZsYWdzICYgLTMpIHwgNDA5NiksXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0UHJvcHMgPT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgOiBpc0h5ZHJhdGluZyB8fFxuICAgICAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9XG4gICAgICAgICAgICAgICAgICAgIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICApLmNyZWF0ZUVsZW1lbnQoY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyW2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyW2ludGVybmFsUHJvcHNLZXldID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUocmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcikpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApLFxuICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgKSkpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgobmV4dFByb3BzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHZhbGlkYXRlRE9NTmVzdGluZyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcy5hbmNlc3RvckluZm9cbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIXByZXZTaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICgobmV4dFN0YXRlID0gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuZmlyc3RDaGlsZFxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChuZXh0UHJvcHMgPSAhMSksXG4gICAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9ICFuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICAgbmV4dFN0YXRlICYmXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgKG5leHRTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFByb3BzKVxuICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlciA9IG51bGwpXG4gICAgICAgICAgICAgIDogbnVsbCAhPT0gbmV4dFN0YXRlICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQocHJldlNpYmxpbmcsIG5leHRTdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMzIpLFxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKS5hbmNlc3RvckluZm8uY3VycmVudCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID1cbiAgICAgICAgICAgICAgICBudWxsICE9IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICA/IHZhbGlkYXRlVGV4dE5lc3RpbmcoY3VycmVudCwgcmVuZGVyTGFuZXMudGFnKVxuICAgICAgICAgICAgICAgICAgOiAhMCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChyZXR1cm5GaWJlciA9ICExKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gcHJldlNpYmxpbmcudmFsdWUpLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIHByZXZTaWJsaW5nIHx8XG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIHx8XG4gICAgICAgICAgICAgICgoaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/XCJcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZWFkQ29udGV4dChwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY2FsbENvbXBvbmVudEluREVWKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3NSb290KSxcbiAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgICAgIChjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZy5wYXJlbnQgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdGhyb3cgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICAgICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlcik7XG4gICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICApO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgICAgIHZhciBjdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50O1xuICAgICAgcG9wKHJlbmRlcmVyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRSZW5kZXJlcjtcbiAgICAgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICBwYXJlbnQsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIHByb3BhZ2F0aW9uUm9vdFxuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgPyAoKHBhcmVudC5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpKVxuICAgICAgICAgIDogbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBwcm9wYWdhdGlvblJvb3QpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50ICE9PSBwcm9wYWdhdGlvblJvb3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY29udGV4dHMsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZm9yICg7IG51bGwgIT09IGZpYmVyOyApIHtcbiAgICAgICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGlmIChudWxsICE9PSBsaXN0KSB7XG4gICAgICAgICAgdmFyIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIGxpc3QgPSBsaXN0LmZpcnN0Q29udGV4dDtcbiAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gbGlzdDsgKSB7XG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3Q7XG4gICAgICAgICAgICBsaXN0ID0gZmliZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0c1tpXSkge1xuICAgICAgICAgICAgICAgIGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGxpc3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAgIG51bGwgIT09IGRlcGVuZGVuY3kgJiYgKGRlcGVuZGVuY3kubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICAgICAgICBsaXN0LnJldHVybixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZSB8fCAobmV4dEZpYmVyID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdCA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoMTggPT09IGZpYmVyLnRhZykge1xuICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgbGlzdCA9IG5leHRGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gbGlzdCAmJiAobGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgIG5leHRGaWJlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHRGaWJlcikgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChuZXh0RmliZXIgPSBmaWJlcjsgbnVsbCAhPT0gbmV4dEZpYmVyOyApIHtcbiAgICAgICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmliZXIgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgICAgICAgICAgICBmaWJlci5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgZmliZXIgPSBuZXh0RmliZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHBhcmVudCA9IHdvcmtJblByb2dyZXNzLCBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICExO1xuICAgICAgICBudWxsICE9PSBwYXJlbnQ7XG5cbiAgICAgICkge1xuICAgICAgICBpZiAoIWlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0KVxuICAgICAgICAgIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgNTI0Mjg4KSkgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMDtcbiAgICAgICAgICBlbHNlIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgMjYyMTQ0KSkgYnJlYWs7XG4gICAgICAgIGlmICgxMCA9PT0gcGFyZW50LnRhZykge1xuICAgICAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgb2JqZWN0SXMocGFyZW50LnBlbmRpbmdQcm9wcy52YWx1ZSwgY3VycmVudFBhcmVudC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbY29udGV4dF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50ID09PSBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAhPT1cbiAgICAgICAgICAgIHBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKEhvc3RUcmFuc2l0aW9uQ29udGV4dClcbiAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtIb3N0VHJhbnNpdGlvbkNvbnRleHRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI2MjE0NDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnREZXBlbmRlbmNpZXMpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudERlcGVuZGVuY2llcztcblxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMoXG4gICAgICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAod29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0ID0gbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24oY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICYmIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgICAgIGlmIChudWxsID09PSBsYXN0Q29udGV4dERlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdW1lci5mbGFncyB8PSA1MjQyODg7XG4gICAgICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gdXBkYXRlUXVldWUpIHJldHVybiBudWxsO1xuICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGVcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsIHdpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhIGNhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChjb21wb25lbnROYW1lID0gdXBkYXRlUXVldWUucGVuZGluZyksXG4gICAgICAgICAgbnVsbCA9PT0gY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBjb21wb25lbnROYW1lLm5leHQpLFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZS5uZXh0ID0gdXBkYXRlKSksXG4gICAgICAgICAgKHVwZGF0ZVF1ZXVlLnBlbmRpbmcgPSB1cGRhdGUpLFxuICAgICAgICAgICh1cGRhdGUgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKSksXG4gICAgICAgICAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIG51bGwsIGxhbmUpLFxuICAgICAgICAgIHVwZGF0ZVxuICAgICAgICApO1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCB1cGRhdGVRdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiAoKGZpYmVyID0gZmliZXIuc2hhcmVkKSwgMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlTGFuZXMgPSBmaWJlci5sYW5lcztcbiAgICAgICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmU7XG4gICAgICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSxcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSwgcXVldWUgPT09IGN1cnJlbnQpXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbCxcbiAgICAgICAgICBuZXdMYXN0ID0gbnVsbDtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogcXVldWUubGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBxdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZSlcbiAgICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChudWxsICE9PSBxdWV1ZSk7XG4gICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIHF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgICAgIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgaWYgKG51bGwgIT09IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlJGpzY29tcCQwLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgICAgICBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgICAgICA/IChmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgOiAobGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUpLFxuICAgICAgICAgIHBlbmRpbmdRdWV1ZSAhPT0gbGFzdEJhc2VVcGRhdGUgJiZcbiAgICAgICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgICAgIDogKHBlbmRpbmdRdWV1ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKSxcbiAgICAgICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gZmlyc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSAwO1xuICAgICAgICBjdXJyZW50ID0gZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5sYW5lICYgLTUzNjg3MDkxMyxcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UkanNjb21wJDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFydGlhbFN0YXRlLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgdXBkYXRlTGFuZS5mbGFncyA9ICh1cGRhdGVMYW5lLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGFzc2lnbih7fSwgbmV3U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmNhbGxiYWNrO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBxdWV1ZS5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICAgID8gKHF1ZXVlLmNhbGxiYWNrcyA9IFt1cGRhdGVMYW5lXSlcbiAgICAgICAgICAgICAgICA6IGlzSGlkZGVuVXBkYXRlLnB1c2godXBkYXRlTGFuZSkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogcGVuZGluZ1F1ZXVlLmNhbGxiYWNrLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgICAgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpKVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gaXNIaWRkZW5VcGRhdGUubmV4dCksXG4gICAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlLm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgICAgICBudWxsID09PSBmaXJzdEJhc2VVcGRhdGUgJiYgKHF1ZXVlLnNoYXJlZC5sYW5lcyA9IDApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiBcIiArXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApO1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBoaWRkZW5DYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRQcm9maWxlKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiAoY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBob29rRmxhZ3NcbiAgICApIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY2FsbENyZWF0ZUluREVWLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXVlXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBsYXN0RWZmZWN0ICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGxhc3RFZmZlY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICBob29rTmFtZSA9XG4gICAgICAgICAgICAgICAgMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIExheW91dClcbiAgICAgICAgICAgICAgICAgID8gXCJ1c2VMYXlvdXRFZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgOiAwICE9PSAodXBkYXRlUXVldWUudGFnICYgSW5zZXJ0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZUVmZmVjdFwiO1xuICAgICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgICBudWxsID09PSBsYXN0RWZmZWN0XG4gICAgICAgICAgICAgICAgICA/IFwiIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuIHVwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS5cIlxuICAgICAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsYXN0RWZmZWN0LnRoZW5cbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuIEluc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIigoKSA9PiB7XFxuICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE15QVBJLmdldERhdGEoc29tZUlkKTtcXG4gICAgLy8gLi4uXFxuICB9XFxuICBmZXRjaERhdGEoKTtcXG59LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2Vzbid0IG5lZWQgcHJvcHMgb3Igc3RhdGVcXG5cXG5MZWFybiBtb3JlIGFib3V0IGRhdGEgZmV0Y2hpbmcgd2l0aCBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ob29rcy1kYXRhLWZldGNoaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiBZb3UgcmV0dXJuZWQ6IFwiICsgbGFzdEVmZmVjdDtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChuLCBhKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIiVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob29rTmFtZSxcbiAgICAgICAgICAgICAgICBhZGRlbmR1bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICBmbGFncyxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGluc3QgPSB1cGRhdGVRdWV1ZS5pbnN0LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gZGVzdHJveSAmJlxuICAgICAgICAgICAgICAgICgoaW5zdC5kZXN0cm95ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY2FsbERlc3Ryb3lJbkRFVixcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IHVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzKGluc3RhbmNlLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2xhc3NTbmFwc2hvdChmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAoY3VycmVudC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApLFxuICAgICAgICBjdXJyZW50LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc29sdmVkUHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZXNvbHZlZFByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgcHJldlByb3BzID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHZvaWQgMCAhPT0gc25hcHNob3QgfHxcbiAgICAgICAgICBwcmV2UHJvcHMuaGFzKGZpbmlzaGVkV29yay50eXBlKSB8fFxuICAgICAgICAgIChwcmV2UHJvcHMuYWRkKGZpbmlzaGVkV29yay50eXBlKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjdXJyZW50Ll9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gc25hcHNob3Q7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgY3VycmVudC50eXBlLFxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHNob3VsZFByb2ZpbGUoY3VycmVudClcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICAgIGlmIChudWxsICE9PSByZWYpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZilcbiAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCAoZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVmXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXCJTdHJpbmcgcmVmcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cIilcbiAgICAgICAgICAgIDogcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocmVmLmN1cnJlbnQgPSBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCBjb21taXRBdHRhY2hSZWYsIGN1cnJlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmLFxuICAgICAgICByZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgaWYgKG51bGwgIT09IHJlZilcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpLFxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IkNikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkNik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXIoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgZWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uQ29tbWl0O1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUmVuZGVyO1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZShcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb25Db21taXQgJiZcbiAgICAgICAgb25Db21taXQoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBlZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbChcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkO1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Qb3N0Q29tbWl0O1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplMiAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdE1vdW50LFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFVwZGF0ZShmaW5pc2hlZFdvcmssIG5ld1Byb3BzLCBvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdFVwZGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgNSA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIDMgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAyNiA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIDI3ID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgNCA9PT0gZmliZXIudGFnXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gZmliZXIuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybiB8fCBpc0hvc3RQYXJlbnQoZmliZXIucmV0dXJuKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmliZXIuc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgICAgICAgIDUgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDI3ICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAxOCAhPT0gZmliZXIudGFnO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChmaWJlci5mbGFncyAmIDIpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLmNoaWxkIHx8IDQgPT09IGZpYmVyLnRhZykgY29udGludWUgYTtcbiAgICAgICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmaWJlci5mbGFncyAmIDIpKSByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IDggPT09IHBhcmVudC5ub2RlVHlwZVxuICAgICAgICAgICAgICA/IHBhcmVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICAgIDogcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICA6ICg4ID09PSBwYXJlbnQubm9kZVR5cGVcbiAgICAgICAgICAgICAgICA/ICgoYmVmb3JlID0gcGFyZW50LnBhcmVudE5vZGUpLFxuICAgICAgICAgICAgICAgICAgYmVmb3JlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQpKVxuICAgICAgICAgICAgICAgIDogKChiZWZvcmUgPSBwYXJlbnQpLCBiZWZvcmUuYXBwZW5kQ2hpbGQobm9kZSkpLFxuICAgICAgICAgICAgICAocGFyZW50ID0gcGFyZW50Ll9yZWFjdFJvb3RDb250YWluZXIpLFxuICAgICAgICAgICAgICAobnVsbCAhPT0gcGFyZW50ICYmIHZvaWQgMCAhPT0gcGFyZW50KSB8fFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGJlZm9yZS5vbmNsaWNrIHx8XG4gICAgICAgICAgICAgICAgKGJlZm9yZS5vbmNsaWNrID0gbm9vcCQxKSk7XG4gICAgICBlbHNlIGlmICg0ICE9PSB0YWcgJiYgMjcgIT09IHRhZyAmJiAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSkpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmUgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGJlZm9yZSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBlbHNlIGlmICg0ICE9PSB0YWcgJiYgMjcgIT09IHRhZyAmJiAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSkpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgICAgaWYgKDI3ICE9PSBmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBmb3IgKHZhciBwYXJlbnQgPSBmaW5pc2hlZFdvcmsucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIHBhcmVudEZpYmVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcGFyZW50RmliZXIuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAocmVzZXRUZXh0Q29udGVudChwYXJlbnQpLCAocGFyZW50RmliZXIuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gICAgICByb290ID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgZXZlbnRzRW5hYmxlZCA9IF9lbmFibGVkO1xuICAgICAgcm9vdCA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKHJvb3QpO1xuICAgICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhyb290KSkge1xuICAgICAgICBpZiAoXCJzZWxlY3Rpb25TdGFydFwiIGluIHJvb3QpXG4gICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcCA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiByb290LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgZW5kOiByb290LnNlbGVjdGlvbkVuZFxuICAgICAgICAgIH07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCA9IHJvb3Qub3duZXJEb2N1bWVudCkgJiZcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgICAgIHdpbmRvdztcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZ2V0U2VsZWN0aW9uICYmIEpTQ29tcGlsZXJfdGVtcC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgMCAhPT0gc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICAgICAgICAgIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAubm9kZVR5cGUsIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSQyKSB7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBsZW5ndGggPSAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gLTEsXG4gICAgICAgICAgICAgICAgZW5kID0gLTEsXG4gICAgICAgICAgICAgICAgaW5kZXhXaXRoaW5BbmNob3IgPSAwLFxuICAgICAgICAgICAgICAgIGluZGV4V2l0aGluRm9jdXMgPSAwLFxuICAgICAgICAgICAgICAgIG5vZGUgPSByb290LFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICBiOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dDsgOyApIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUgIT09IEpTQ29tcGlsZXJfdGVtcCB8fFxuICAgICAgICAgICAgICAgICAgICAoMCAhPT0gYW5jaG9yT2Zmc2V0ICYmIDMgIT09IG5vZGUubm9kZVR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICBub2RlICE9PSBmb2N1c05vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgKDAgIT09IHNlbGVjdGlvbiAmJiAzICE9PSBub2RlLm5vZGVUeXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZW5kID0gbGVuZ3RoICsgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIDMgPT09IG5vZGUubm9kZVR5cGUgJiYgKGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gcm9vdCkgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICAgICAgICArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICArK2luZGV4V2l0aGluRm9jdXMgPT09IHNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAoZW5kID0gbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSAobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAtMSA9PT0gc3RhcnQgfHwgLTEgPT09IGVuZCA/IG51bGwgOiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl90ZW1wID0gSlNDb21waWxlcl90ZW1wIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICAgICAgfSBlbHNlIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IHtcbiAgICAgICAgZm9jdXNlZEVsZW06IHJvb3QsXG4gICAgICAgIHNlbGVjdGlvblJhbmdlOiBKU0NvbXBpbGVyX3RlbXBcbiAgICAgIH07XG4gICAgICBfZW5hYmxlZCA9ICExO1xuICAgICAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChmaXJzdENoaWxkID0gbmV4dEVmZmVjdCksXG4gICAgICAgICAgKHJvb3QgPSBmaXJzdENoaWxkLmNoaWxkKSxcbiAgICAgICAgICAwICE9PSAoZmlyc3RDaGlsZC5zdWJ0cmVlRmxhZ3MgJiAxMDI4KSAmJiBudWxsICE9PSByb290KVxuICAgICAgICApXG4gICAgICAgICAgKHJvb3QucmV0dXJuID0gZmlyc3RDaGlsZCksIChuZXh0RWZmZWN0ID0gcm9vdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICByb290ID0gZmlyc3RDaGlsZCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSByb290LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IHJvb3QuZmxhZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKHJvb3QudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIDAgIT09IChhbmNob3JPZmZzZXQgJiAxMDI0KSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgICAgICBjb21taXRDbGFzc1NuYXBzaG90KHJvb3QsIEpTQ29tcGlsZXJfdGVtcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gKGFuY2hvck9mZnNldCAmIDEwMjQpKVxuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoKHJvb3QgPSByb290LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IHJvb3Qubm9kZVR5cGUpLFxuICAgICAgICAgICAgICAgICAgICA5ID09PSBKU0NvbXBpbGVyX3RlbXApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyU3BhcmluZ2x5KHJvb3QpO1xuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoMSA9PT0gSlNDb21waWxlcl90ZW1wKVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJvb3Qubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJPRFlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyU3BhcmluZ2x5KHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IChhbmNob3JPZmZzZXQgJiAxMDI0KSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdCA9IGZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSByb290KSB7XG4gICAgICAgICAgICAgIHJvb3QucmV0dXJuID0gZmlyc3RDaGlsZC5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSByb290O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICBmaXJzdENoaWxkID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITE7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgICAgIGlmICgoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLCBudWxsID09PSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY3VycmVudCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJldlByb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmsuY2hpbGQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhjdXJyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiBmbGFncyAmIDQgJiYgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhmbGFncyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXIsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldlByb3BzID1cbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2UHJvcHM7XG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGN1cnJlbnQpICYmXG4gICAgICAgICAgICAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKFwibWFudWFsXCIgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm1vZGVcbiAgICAgICAgICAgICAgPyBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKVxuICAgICAgICAgICAgICA6IHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICgoZmliZXIuYWx0ZXJuYXRlID0gbnVsbCksIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICgoYWx0ZXJuYXRlID0gZmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIGRldGFjaERlbGV0ZWRJbnN0YW5jZShhbHRlcm5hdGUpKTtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICAgICAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBwYXJlbnRcbiAgICApIHtcbiAgICAgIGZvciAocGFyZW50ID0gcGFyZW50LmNoaWxkOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBwYXJlbnRcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGRlbGV0ZWRGaWJlclxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50XG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZS5jb3VudC0tXG4gICAgICAgICAgICA6IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgKChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVsZXRlZEZpYmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlbGV0ZWRGaWJlciA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgZm9yIChmaW5pc2hlZFJvb3QgPSBkZWxldGVkRmliZXIuYXR0cmlidXRlczsgZmluaXNoZWRSb290Lmxlbmd0aDsgKVxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnJlbW92ZUF0dHJpYnV0ZU5vZGUoZmluaXNoZWRSb290WzBdKTtcbiAgICAgICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIGlmIChudWxsICE9PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkLFxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQgJiZcbiAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICAgICAgPyAoKGZpbmlzaGVkUm9vdCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAgIChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICA4ID09PSBmaW5pc2hlZFJvb3Qubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgID8gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGZpbmlzaGVkUm9vdC5wYXJlbnROb2RlLCBkZWxldGVkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IDEgPT09IGZpbmlzaGVkUm9vdC5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoZmluaXNoZWRSb290LCBkZWxldGVkRmliZXIpLFxuICAgICAgICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24oZmluaXNoZWRSb290KSlcbiAgICAgICAgICAgICAgOiBjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgKHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpLFxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHx8XG4gICAgICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdC5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gZmluaXNoZWRSb290KSkpXG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKTtcbiAgICAgICAgICByZXR1cm4gcmV0cnlDYWNoZTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5fcmV0cnlDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSksXG4gICAgICAgICAgICByZXRyeUNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHdha2VhYmxlcykge1xuICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yayk7XG4gICAgICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcbiAgICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGluUHJvZ3Jlc3NMYW5lcyAmJiBudWxsICE9PSBpblByb2dyZXNzUm9vdClcbiAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCk7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCRqc2NvbXAkMCwgcGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBkZWxldGVkRmliZXIgPSBkZWxldGlvbnNbaV0sXG4gICAgICAgICAgICBwYXJlbnQgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgcm9vdCA9IGRlbGV0ZWRGaWJlcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJvb3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmIChyZXR1cm5GaWJlci5yZXR1cm4gPSBudWxsKTtcbiAgICAgICAgICByb290LnJldHVybiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIocGFyZW50RmliZXIsIHJvb3QkanNjb21wJDApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24gfCBIYXNFZmZlY3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIExheW91dCB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJvb3QgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbCksXG4gICAgICAgICAgICAgIChmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGZsYWdzKVxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgICAgICAgICAgICBiOiBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhaG9pc3RhYmxlUm9vdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuaGFzQXR0cmlidXRlKFwiaXRlbXByb3BcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvaXN0YWJsZVJvb3QgPSByb290LmNyZWF0ZUVsZW1lbnQoZmxhZ3MpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucXVlcnlTZWxlY3RvcihcImhlYWQgPiB0aXRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZU5vZGVzID0gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJocmVmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICkuZ2V0KGZsYWdzICsgKGN1cnJlbnQuaHJlZiB8fCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVOb2RlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaG9pc3RhYmxlUm9vdCA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmhyZWYgPyBudWxsIDogY3VycmVudC5ocmVmKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnJlbCA/IG51bGwgOiBjdXJyZW50LnJlbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC50aXRsZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5jcm9zc09yaWdpbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IHJvb3QuY3JlYXRlRWxlbWVudChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmhlYWQuYXBwZW5kQ2hpbGQoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAobWF5YmVOb2RlcyA9IGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICkuZ2V0KGZsYWdzICsgKGN1cnJlbnQuY29udGVudCB8fCBcIlwiKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaG9pc3RhYmxlUm9vdCA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiICsgY3VycmVudC5jb250ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5uYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcInByb3BlcnR5XCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQucHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LnByb3BlcnR5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcImh0dHAtZXF1aXZcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5odHRwRXF1aXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50Lmh0dHBFcXVpdikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJjaGFyc2V0XCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQuY2hhclNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQuY2hhclNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IHJvb3QuY3JlYXRlRWxlbWVudChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmhlYWQuYXBwZW5kQ2hpbGQoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdnZXROb2Rlc0ZvclR5cGUgZW5jb3VudGVyZWQgYSB0eXBlIGl0IGRpZCBub3QgZXhwZWN0OiBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBmbGFncyA9IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gZmxhZ3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICByb290ICE9PSBmbGFnc1xuICAgICAgICAgICAgICAgID8gKG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBjdXJyZW50LnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCkpXG4gICAgICAgICAgICAgICAgICAgIDogcm9vdC5jb3VudC0tLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgPyBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0ICYmIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgbWF5YmVOb2RlcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChpID0gaG9pc3RhYmxlUm9vdC5maXJzdENoaWxkOyBpOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBpLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBpLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgICAgICAgICAgICBcIkhFQURcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIFwiQk9EWVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgXCJTQ1JJUFRcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIFwiU1RZTEVcIiA9PT0gbm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIChcIkxJTktcIiA9PT0gbm9kZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHlsZXNoZWV0XCIgPT09IGkucmVsLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LnJlbW92ZUNoaWxkKGkpO1xuICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgIG1heWJlTm9kZXMsXG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCByZXNldFRleHRDb250ZW50LCByb290KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIG51bGwgIT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgKChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcm9vdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITApLFxuICAgICAgICAgICAgXCJmb3JtXCIgIT09IGZpbmlzaGVkV29yay50eXBlICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBmbGFncztcbiAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUsXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBob2lzdGFibGVSb290ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHRhZ0NhY2hlcyA9IG51bGw7XG4gICAgICAgICAgbWF5YmVOb2RlcyA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG1heWJlTm9kZXM7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHJvb3QuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNGb3JtUmVzZXQgJiZcbiAgICAgICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMSksIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhob2lzdGFibGVSb290KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGZsYWdzID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBmbGFncztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGkgPSBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG5vZGVOYW1lID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbm9kZU5hbWUgfHwgaTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgbmV4dE5vZGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBub2RlTmFtZTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICByb290Ll9jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgIHJvb3QuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlbkRldGFjaGVkO1xuICAgICAgICAgIHJvb3QuX3Zpc2liaWxpdHkgfD0gcm9vdC5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDgxOTIgJiZcbiAgICAgICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IGlcbiAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgfk9mZnNjcmVlblZpc2libGVcbiAgICAgICAgICAgICAgOiByb290Ll92aXNpYmlsaXR5IHwgT2Zmc2NyZWVuVmlzaWJsZSksXG4gICAgICAgICAgICBpICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIG5leHROb2RlIHx8XG4gICAgICAgICAgICAgICAgcm9vdCB8fFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykpLFxuICAgICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgXCJtYW51YWxcIiAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSBudWxsLCByb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgICAgICBpZiAoNSA9PT0gcm9vdC50YWcgfHwgMjYgPT09IHJvb3QudGFnIHx8IDI3ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKGhvaXN0YWJsZVJvb3QgPSBuZXh0Tm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgIGlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dE5vZGUsIG5leHROb2RlLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICg2ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAobWF5YmVOb2RlcyA9IG5leHROb2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0Tm9kZSwgbmV4dE5vZGUucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3QubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gZmluaXNoZWRXb3JrKSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5jaGlsZC5yZXR1cm4gPSByb290O1xuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGZvciAoOyBudWxsID09PSByb290LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSByb290LnJldHVybiB8fCByb290LnJldHVybiA9PT0gZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgcm9vdC5zaWJsaW5nLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmbGFncy5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICgoZmxhZ3MucmV0cnlRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBjdXJyZW50KSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBmbGFncykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgY29tbWl0UGxhY2VtZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSAtMztcbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNDA5NiAmJiAoZmluaXNoZWRXb3JrLmZsYWdzICY9IC00MDk3KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlSZXNldEZvcm1zKHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIGZpYmVyID0gcGFyZW50RmliZXI7XG4gICAgICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcbiAgICAgICAgICA1ID09PSBmaWJlci50YWcgJiYgZmliZXIuZmxhZ3MgJiAxMDI0ICYmIGZpYmVyLnN0YXRlTm9kZS5yZXNldCgpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIHBhcmVudEZpYmVyLmFsdGVybmF0ZSwgcGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgICAgICAobnVsbCAhPSBjdXJyZW50ICYmIHJldGFpbkNhY2hlKGN1cnJlbnQpLFxuICAgICAgICBudWxsICE9IHByZXZpb3VzQ2FjaGUgJiYgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICBmaW5pc2hlZFdvcmsgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksIG51bGwgIT0gY3VycmVudCAmJiByZWxlYXNlQ2FjaGUoY3VycmVudCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICgoY29tbWl0dGVkTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgKGNvbW1pdHRlZExhbmVzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBudWxsICE9IGNvbW1pdHRlZExhbmVzICYmIHJlbGVhc2VDYWNoZShjb21taXR0ZWRMYW5lcykpKTtcbiAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6ICgocHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5IHw9XG4gICAgICAgICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KTtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gX2luc3RhbmNlMi5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAoKF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBwYXJlbnRGaWJlclxuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICBzdXNwZW5kUmVzb3VyY2UoXG4gICAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LFxuICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICgocHJldmlvdXNIb2lzdGFibGVSb290ID0gZmliZXIuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNIb2lzdGFibGVSb290Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IHN1c3BlbnNleUNvbW1pdEZsYWcpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gMTY3NzcyMTYpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlciksXG4gICAgICAgICAgICAgICAgKHN1c3BlbnNleUNvbW1pdEZsYWcgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3QpKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNGaWJlciAmJlxuICAgICAgICAoKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlci5jaGlsZCksIG51bGwgIT09IHBhcmVudEZpYmVyKVxuICAgICAgKSB7XG4gICAgICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgICBkb1xuICAgICAgICAgIChwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyksXG4gICAgICAgICAgICAocGFyZW50RmliZXIuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlcik7XG4gICAgICAgIHdoaWxlIChudWxsICE9PSBwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBQYXNzaXZlIHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCAmJlxuICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgICAgID8gKChwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJj1cbiAgICAgICAgICAgICAgICB+T2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkICYmXG4gICAgICAgICAgICAoKGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgIGRlbGV0ZWRTdWJ0cmVlUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdCxcbiAgICAgICAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgUGFzc2l2ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiByZXRhaW5DYWNoZShjdXJyZW50KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmVsZWFzZUNhY2hlKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkgKGN1cnJlbnQucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGN1cnJlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYTogZm9yIChmaWJlciA9IGRlbGV0ZWRTdWJ0cmVlUm9vdDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nID0gY3VycmVudC5zaWJsaW5nLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykge1xuICAgICAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy5zaWJsaW5nID1cbiAgICAgICAgdGhpcy5jaGlsZCA9XG4gICAgICAgIHRoaXMucmV0dXJuID1cbiAgICAgICAgdGhpcy5zdGF0ZU5vZGUgPVxuICAgICAgICB0aGlzLnR5cGUgPVxuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB0aGlzLnJlZkNsZWFudXAgPSB0aGlzLnJlZiA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgdGhpcy51cGRhdGVRdWV1ZSA9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQcm9wcyA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLnN1YnRyZWVGbGFncyA9IHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgdGhpcy5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jaGlsZExhbmVzID0gdGhpcy5sYW5lcyA9IDA7XG4gICAgICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xLjE7XG4gICAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuX2RlYnVnT3duZXIgPSB0aGlzLl9kZWJ1Z0luZm8gPSBudWxsO1xuICAgICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSAhMTtcbiAgICAgIHRoaXMuX2RlYnVnSG9va1R5cGVzID0gbnVsbDtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyB8fFxuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISghQ29tcG9uZW50IHx8ICFDb21wb25lbnQuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihcbiAgICAgICAgICAgIGN1cnJlbnQudGFnLFxuICAgICAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgY3VycmVudC5rZXksXG4gICAgICAgICAgICBjdXJyZW50Lm1vZGVcbiAgICAgICAgICApKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAoY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTEuMSkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgMzE0NTcyODA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgPT09IHBlbmRpbmdQcm9wc1xuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBsYW5lczogcGVuZGluZ1Byb3BzLmxhbmVzLFxuICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHBlbmRpbmdQcm9wcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHBlbmRpbmdQcm9wcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IGN1cnJlbnQuX2RlYnVnSW5mbztcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IDMxNDU3MjgyO1xuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMCkpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGxhbmVzOiByZW5kZXJMYW5lcy5sYW5lcyxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcmVuZGVyTGFuZXMuZmlyc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcmVuZGVyTGFuZXMuX2RlYnVnVGhlbmFibGVTdGF0ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgb3duZXIsXG4gICAgICBtb2RlLFxuICAgICAgbGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBmaWJlclRhZyA9IDAsXG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHR5cGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIChmaWJlclRhZyA9IDEpLFxuICAgICAgICAgIChyZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKSk7XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgKGZpYmVyVGFnID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgOiBcImh0bWxcIiA9PT0gdHlwZSB8fCBcImhlYWRcIiA9PT0gdHlwZSB8fCBcImJvZHlcIiA9PT0gdHlwZVxuICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgIDogNSk7XG4gICAgICBlbHNlXG4gICAgICAgIGE6IHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcbiAgICAgICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZSA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChvd25lciA9IG1vZGUpLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZS5pZCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZS5pZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMiwgdHlwZSwga2V5LCBvd25lciB8IFByb2ZpbGVNb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAgKGtleS5zdGF0ZU5vZGUgPSB7IGVmZmVjdER1cmF0aW9uOiAwLCBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDAgfSksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTMsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDE5LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNjtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlICs9XG4gICAgICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICAgICAgbnVsbCA9PT0gdHlwZVxuICAgICAgICAgICAgICA/IChwZW5kaW5nUHJvcHMgPSBcIm51bGxcIilcbiAgICAgICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gKChwZW5kaW5nUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc29sdmVkVHlwZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikpXG4gICAgICAgICAgICAgICAgICA6IChwZW5kaW5nUHJvcHMgPSB0eXBlb2YgdHlwZSk7XG4gICAgICAgICAgICAoZmliZXJUYWcgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tT3duZXIob3duZXIpIDogbnVsbCkgJiZcbiAgICAgICAgICAgICAgKHJlc29sdmVkVHlwZSArPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgZmliZXJUYWcgKyBcImAuXCIpO1xuICAgICAgICAgICAgZmliZXJUYWcgPSAyOTtcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyA9IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgK1xuICAgICAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgKyBcIi5cIiArIHJlc29sdmVkVHlwZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICBrZXkgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAga2V5LmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgIGtleS50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICAgICAga2V5LmxhbmVzID0gbGFuZXM7XG4gICAgICBrZXkuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIG1vZGUgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAgZWxlbWVudC5rZXksXG4gICAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICAgIGVsZW1lbnQuX293bmVyLFxuICAgICAgICBtb2RlLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIG1vZGUuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICAgICAgZWxlbWVudHMgPSBjcmVhdGVGaWJlcig3LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgICAgIGVsZW1lbnRzLmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGNyZWF0ZUZpYmVyKDIyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgICBwZW5kaW5nUHJvcHMuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgICAgIHBlbmRpbmdQcm9wcy5sYW5lcyA9IGxhbmVzO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgICAgICBfdmlzaWJpbGl0eTogT2Zmc2NyZWVuVmlzaWJsZSxcbiAgICAgICAgX3BlbmRpbmdWaXNpYmlsaXR5OiBPZmZzY3JlZW5WaXNpYmxlLFxuICAgICAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgICAgICBfdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgIF9jdXJyZW50OiBudWxsLFxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwID09PSAoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IE9mZnNjcmVlbkRldGFjaGVkKSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwICE9PSAoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5EZXRhY2hlZCksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBlbmRpbmdQcm9wcy5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgICAgIHJldHVybiBwZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVGaWJlcig2LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgICAgIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICA0LFxuICAgICAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICAgICAgcG9ydGFsLmtleSxcbiAgICAgICAgbW9kZVxuICAgICAgKTtcbiAgICAgIG1vZGUubGFuZXMgPSBsYW5lcztcbiAgICAgIG1vZGUuc3RhdGVOb2RlID0ge1xuICAgICAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHlsZXNoZWV0XCIgIT09IHJlc291cmNlLnR5cGUgfHxcbiAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiBJbnNlcnRlZCkgIT09IE5vdExvYWRlZFxuICAgICAgKVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNjc3NzIxNiksICFwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpKVxuICAgICAgKSB7XG4gICAgICAgIHJlc291cmNlID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IHJlc291cmNlICYmXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpID09PVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICA/IG51bGwgIT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSAhPT1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpIHx8XG4gICAgICAgICAgICAgIHJlc291cmNlICE9PSBzaGVsbEJvdW5kYXJ5KVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKChzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSksXG4gICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0cnlRdWV1ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICgocmV0cnlRdWV1ZSA9XG4gICAgICAgICAgMjIgIT09IHdvcmtJblByb2dyZXNzLnRhZyA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogNTM2ODcwOTEyKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIHw9IHJldHJ5UXVldWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgICAgZm9yICh2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrLnNpYmxpbmcpO1xuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICA6IChsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbGFzdFRhaWxOb2RlLmFsdGVybmF0ZSAmJiAoX2xhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZSksXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZS5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IF9sYXN0VGFpbE5vZGVcbiAgICAgICAgICAgICAgPyBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgfHwgbnVsbCA9PT0gcmVuZGVyU3RhdGUudGFpbFxuICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgICAgIDogKF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICAgICAgdmFyIGRpZEJhaWxvdXQgPVxuICAgICAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQsXG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSAwLFxuICAgICAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgaWYgKGRpZEJhaWxvdXQpXG4gICAgICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF9jaGlsZDI7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBfY2hpbGQyLmxhbmVzIHwgX2NoaWxkMi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgKF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmcpO1xuICAgICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGVsc2UgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG4gICAgICAgIGZvciAodmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBjaGlsZC5sYW5lcyB8IGNoaWxkLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZC5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZC5mbGFncyksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLFxuICAgICAgICAgICAgKF9jaGlsZDIgKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgICAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfY2hpbGQyO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgIG51bGwgIT09IF90cmVlQmFzZUR1cmF0aW9uO1xuXG4gICAgICAgIClcbiAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24ubGFuZXMgfCBfdHJlZUJhc2VEdXJhdGlvbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb24uc2libGluZyk7XG4gICAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gICAgICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICAgICAgcmV0dXJuIGRpZEJhaWxvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgbmV3UHJvcHMucGVuZGluZ0NvbnRleHQgJiZcbiAgICAgICAgICAgICgobmV3UHJvcHMuY29udGV4dCA9IG5ld1Byb3BzLnBlbmRpbmdDb250ZXh0KSxcbiAgICAgICAgICAgIChuZXdQcm9wcy5wZW5kaW5nQ29udGV4dCA9IG51bGwpKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsID09PSBjdXJyZW50LmNoaWxkKVxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgID8gKGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSwgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgICAgIDogbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIChjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpKSB8fFxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaHlkcmF0aW9uRXJyb3JzICYmXG4gICAgICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgPyAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKSlcbiAgICAgICAgICAgICAgOiByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgID8gcmVuZGVyTGFuZXMgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3KSlcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3KSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgdmFyIF90eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgX3R5cGUsXG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90eXBlID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIF90eXBlKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgICAgICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcocmVuZGVyTGFuZXMsIF90eXBlLmFuY2VzdG9ySW5mbyk7XG4gICAgICAgICAgICAgIF90eXBlID0gX3R5cGUuY29udGV4dDtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbnRleHROYW1lc3BhY2VTdmc6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29udGV4dE5hbWVzcGFjZU1hdGg6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgIE1BVEhfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlbmRlckxhbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgICAgICBTVkdfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BVEhfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmlubmVySFRNTCA9IFwiPHNjcmlwdD5cXHgzYy9zY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld1Byb3BzLmlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgaXM6IG5ld1Byb3BzLmlzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLm11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChjdXJyZW50Lm11bHRpcGxlID0gITApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ld1Byb3BzLnNpemUgJiYgKGN1cnJlbnQuc2l6ZSA9IG5ld1Byb3BzLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuY3JlYXRlRWxlbWVudChyZW5kZXJMYW5lcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IG5ld1Byb3BzLmlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNyZWF0ZUVsZW1lbnQocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0xID09PSByZW5kZXJMYW5lcy5pbmRleE9mKFwiLVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgIT09IHJlbmRlckxhbmVzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF1cIiAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY3VycmVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmVkVW5rbm93blRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHdhcm5lZFVua25vd25UYWdzW3JlbmRlckxhbmVzXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBjdXJyZW50W2ludGVybmFsUHJvcHNLZXldID0gbmV3UHJvcHM7XG4gICAgICAgICAgICAgIGE6IGZvciAoX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gX3R5cGU7ICkge1xuICAgICAgICAgICAgICAgIGlmICg1ID09PSBfdHlwZS50YWcgfHwgNiA9PT0gX3R5cGUudGFnKVxuICAgICAgICAgICAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChfdHlwZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgNCAhPT0gX3R5cGUudGFnICYmXG4gICAgICAgICAgICAgICAgICAyNyAhPT0gX3R5cGUudGFnICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBfdHlwZS5jaGlsZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgX3R5cGUuY2hpbGQucmV0dXJuID0gX3R5cGU7XG4gICAgICAgICAgICAgICAgICBfdHlwZSA9IF90eXBlLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IF90eXBlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IF90eXBlLnJldHVybiB8fCBfdHlwZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgX3R5cGUgPSBfdHlwZS5yZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90eXBlLnNpYmxpbmcucmV0dXJuID0gX3R5cGUucmV0dXJuO1xuICAgICAgICAgICAgICAgIF90eXBlID0gX3R5cGUuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICBhOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAgIChzZXRJbml0aWFsUHJvcGVydGllcyhjdXJyZW50LCByZW5kZXJMYW5lcywgbmV3UHJvcHMpLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICEhbmV3UHJvcHMuYXV0b0ZvY3VzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gITE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudCAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfdHlwZSA9ICFkaWRTdXNwZW5kT3JFcnJvckRFVjtcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF90eXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKChfdHlwZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gX3R5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgX3R5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX3R5cGUgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBfdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkuc2VydmVyUHJvcHMgPSBfdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5vZGVWYWx1ZSA9PT0gbmV3UHJvcHMgfHxcbiAgICAgICAgICAgICAgICAobnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICEwID09PSByZW5kZXJMYW5lcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHx8XG4gICAgICAgICAgICAgICAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGN1cnJlbnQubm9kZVZhbHVlLCBuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgID8gITBcbiAgICAgICAgICAgICAgICAgIDogITE7XG4gICAgICAgICAgICAgIGN1cnJlbnQgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5hbmNlc3RvckluZm8uY3VycmVudCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGVUZXh0TmVzdGluZyhuZXdQcm9wcywgcmVuZGVyTGFuZXMudGFnKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoY3VycmVudCkuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgX3R5cGUgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gbmV3UHJvcHMgJiYgbnVsbCAhPT0gbmV3UHJvcHMuZGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghX3R5cGUpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgIF90eXBlID0gbnVsbCAhPT0gX3R5cGUgPyBfdHlwZS5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIV90eXBlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIF90eXBlW2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICgoX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBfdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgIF90eXBlLnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpLFxuICAgICAgICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICgoX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IF90eXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90eXBlLnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgX3R5cGUgPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSksXG4gICAgICAgICAgICAgICAgKF90eXBlID0gITApO1xuICAgICAgICAgICAgaWYgKCFfdHlwZSkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBuZXdQcm9wcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChfdHlwZSA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoX3R5cGUgPSByZW5kZXJMYW5lcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVuZGVyTGFuZXMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gX3R5cGUgJiYgKHJlbmRlckxhbmVzLmZsYWdzIHw9IDIwNDgpKTtcbiAgICAgICAgICBuZXdQcm9wcyAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZC5mbGFncyB8PSA4MTkyKTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBfdHlwZSkgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgIG5ld1Byb3BzID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IF90eXBlLnJlbmRlcmluZztcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpXG4gICAgICAgICAgICBpZiAobmV3UHJvcHMpIGN1dE9mZlRhaWxJZk5lZWRlZChfdHlwZSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKF90eXBlLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXR1cm5GaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IG5ld1Byb3BzOyApXG4gICAgICAgICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhuZXdQcm9wcywgY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSBuZXdQcm9wcy5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICAgICAgICAgICAgICAgIChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJlxuICAgICAgICAgICAgICAgICAgICAgICAgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbnVsbCAhPT0gX3R5cGUudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQoX3R5cGUsICExKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmluZEZpcnN0U3VzcGVuZGVkKHJldHVybkZpYmVyKSksIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKF90eXBlLCAhMCksXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBfdHlwZS50YWlsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZGVuXCIgPT09IF90eXBlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZXR1cm5GaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSHlkcmF0aW5nKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgMiAqIG5vdyQxKCkgLSBfdHlwZS5yZW5kZXJpbmdTdGFydFRpbWUgPlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICAgICAgNTM2ODcwOTEyICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKF90eXBlLCAhMSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICBfdHlwZS5pc0JhY2t3YXJkc1xuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gX3R5cGUubGFzdCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgICAgPyAoY3VycmVudC5zaWJsaW5nID0gcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAoX3R5cGUubGFzdCA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9PSBfdHlwZS50YWlsKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBfdHlwZS50YWlsKSxcbiAgICAgICAgICAgICAgKF90eXBlLnJlbmRlcmluZyA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAoX3R5cGUudGFpbCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAgIChfdHlwZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBuZXdQcm9wc1xuICAgICAgICAgICAgICAgID8gKHJlbmRlckxhbmVzICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spIHxcbiAgICAgICAgICAgICAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuICAgICAgICAgICAgICAgIDogcmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayksXG4gICAgICAgICAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5ld1Byb3BzID0gbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpXG4gICAgICAgICAgICAgIDogbmV3UHJvcHMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgPyAwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgIChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiA2ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MikpXG4gICAgICAgICAgICAgIDogYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcy5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV3UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgIT09IG5ld1Byb3BzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAobmV3UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudCAmIDY1NTM2KSAmJiAwID09PSAoY3VycmVudCAmIDEyOClcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50LmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhyZXcgaW4gbmV3bHkgbW91bnRlZCBkZWh5ZHJhdGVkIGNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcbiAgICAgICAgICByZXR1cm4gY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspIHtcbiAgICAgIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHBvcFByb3ZpZGVyKGludGVycnVwdGVkV29yay50eXBlLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gICAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSB7XG4gICAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAgICAgICAgID8gSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgOiB2b2lkIDA7XG4gICAgICBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgfHxcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBhY3QoLi4uKVwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAgICAgaWYgKFxuICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiZcbiAgICAgICAgMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgLXdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgcmV0dXJuIG51bGwgIT09IHRyYW5zaXRpb25cbiAgICAgICAgPyAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyB8fCAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKSksXG4gICAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpLFxuICAgICAgICAgIChmaWJlciA9IGN1cnJlbnRFbnRhbmdsZWRMYW5lKSxcbiAgICAgICAgICAwICE9PSBmaWJlciA/IGZpYmVyIDogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCkpXG4gICAgICAgIDogcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3REZWZlcnJlZExhbmUoKSB7XG4gICAgICAwID09PSB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgICAgID8gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKVxuICAgICAgICAgICAgOiA1MzY4NzA5MTIpO1xuICAgICAgdmFyIHN1c3BlbnNlSGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXIgJiYgKHN1c3BlbnNlSGFuZGxlci5mbGFncyB8PSAzMik7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy5cIik7XG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgJiYgKGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMCk7XG4gICAgICBpZiAoXG4gICAgICAgIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCksXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIGxhbmUpO1xuICAgICAgaWYgKFxuICAgICAgICAwICE9PSAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICYmXG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdFxuICAgICAgKSB7XG4gICAgICAgIGlmIChpc1JlbmRlcmluZylcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHJvb3QgPVxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyAmJiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICAgICAgICBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50Lmhhcyhyb290KSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKHJvb3QpLFxuICAgICAgICAgICAgICAgIChmaWJlciA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSBkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCBmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0LmRldi9saW5rL3NldHN0YXRlLWluLXJlbmRlclwiLFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpLFxuICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgZm9yY2VTeW5jKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBzaG91bGRUaW1lU2xpY2UgPVxuICAgICAgICAgICghZm9yY2VTeW5jICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiA2MCkgJiZcbiAgICAgICAgICAgIDAgPT09IChsYW5lcyAmIHJvb3QuZXhwaXJlZExhbmVzKSkgfHxcbiAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKSxcbiAgICAgICAgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZVxuICAgICAgICAgID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpXG4gICAgICAgICAgOiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITApLFxuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gc2hvdWxkVGltZVNsaWNlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyAmJlxuICAgICAgICAgICAgIXNob3VsZFRpbWVTbGljZSAmJlxuICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIDAsICExKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvcmNlU3luYyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCAmJlxuICAgICAgICAgICAgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3Jlcyhmb3JjZVN5bmMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICExKTtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IDA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC01MzY4NzA5MTMpLFxuICAgICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgMCAhPT0gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgIDogZXJyb3JSZXRyeUxhbmVzICYgNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICAgICAgPyA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgaWYgKDAgIT09IGVycm9yUmV0cnlMYW5lcykge1xuICAgICAgICAgICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByb290O1xuICAgICAgICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycztcbiAgICAgICAgICAgICAgICB2YXIgd2FzUm9vdERlaHlkcmF0ZWQgPVxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkO1xuICAgICAgICAgICAgICAgIHdhc1Jvb3REZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IHJlbmRlclJvb3RTeW5jKFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGV4aXRTdGF0dXMgJiYgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhleGl0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKTtcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlID0gcm9vdDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgICAgICAgICAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICAgICAgICAgICAgaWYgKChsYW5lcyAmIDQxOTQxNzYpID09PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRXb3JrID0gZm9yY2VTeW5jO1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICBJTU1FRElBVEVfQ09NTUlULFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChsYW5lcyAmIDYyOTE0NTYwKSA9PT0gbGFuZXMgJiZcbiAgICAgICAgICAgICAgICAoKGV4aXRTdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArXG4gICAgICAgICAgICAgICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyAtXG4gICAgICAgICAgICAgICAgICBub3ckMSgpKSxcbiAgICAgICAgICAgICAgICAxMCA8IGV4aXRTdGF0dXMpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSBnZXROZXh0TGFuZXMoc2hvdWxkVGltZVNsaWNlLCAwKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgICAgICAgICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkuYmluZChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgVEhST1RUTEVEX0NPTU1JVCxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgbGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgICAgIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChzdXNwZW5kZWRTdGF0ZSA9IHsgc3R5bGVzaGVldHM6IG51bGwsIGNvdW50OiAwLCB1bnN1c3BlbmQ6IG5vb3AgfSksXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAoZmluaXNoZWRXb3JrID0gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpKSxcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IGZpbmlzaGVkV29yayhcbiAgICAgICAgICAgIGNvbW1pdFJvb3QuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgIFNVU1BFTkRFRF9DT01NSVQsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICFkaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoMCA9PT0gdGFnIHx8IDExID09PSB0YWcgfHwgMTUgPT09IHRhZykgJiZcbiAgICAgICAgICBub2RlLmZsYWdzICYgMTYzODQgJiZcbiAgICAgICAgICAoKHRhZyA9IG5vZGUudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IHRhZyAmJiAoKHRhZyA9IHRhZy5zdG9yZXMpLCBudWxsICE9PSB0YWcpKVxuICAgICAgICApXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IHRhZ1tpXSxcbiAgICAgICAgICAgICAgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcbiAgICAgICAgICAgIGNoZWNrID0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIGNoZWNrKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgdGFnID0gbm9kZS5jaGlsZDtcbiAgICAgICAgaWYgKG5vZGUuc3VidHJlZUZsYWdzICYgMTYzODQgJiYgbnVsbCAhPT0gdGFnKVxuICAgICAgICAgICh0YWcucmV0dXJuID0gbm9kZSksIChub2RlID0gdGFnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgcmV0dXJuICEwO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgIHJvb3QsXG4gICAgICBzdXNwZW5kZWRMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcztcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lcztcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlICYmIChyb290Lndhcm1MYW5lcyB8PSBzdXNwZW5kZWRMYW5lcyk7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICAgICAgZm9yICh2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lczsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlW2luZGV4XSA9IC0xO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIDAgIT09IHNwYXduZWRMYW5lICYmXG4gICAgICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBzdXNwZW5kZWRMYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmskMSgpIHtcbiAgICAgIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHRcbiAgICAgICAgPyAoZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpLCAhMSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCkge1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gTm90U3VzcGVuZGVkKVxuICAgICAgICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCksXG4gICAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQoaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlJDEgPSBudWxsKSxcbiAgICAgICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gaW50ZXJydXB0ZWRXb3JrOyApXG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yay5hbHRlcm5hdGUsIGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybik7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCAmJlxuICAgICAgICAoKHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dCksIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSkpO1xuICAgICAgdGltZW91dEhhbmRsZSA9IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdDtcbiAgICAgIG51bGwgIT09IHRpbWVvdXRIYW5kbGUgJiZcbiAgICAgICAgKChyb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsKSwgdGltZW91dEhhbmRsZSgpKTtcbiAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdGltZW91dEhhbmRsZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICAgICAgbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMTtcbiAgICAgIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgICAgIHZhciBhbGxFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG4gICAgICBpZiAoMCAhPT0gYWxsRW50YW5nbGVkTGFuZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcm9vdCA9IHJvb3QuZW50YW5nbGVtZW50cywgYWxsRW50YW5nbGVkTGFuZXMgJj0gbGFuZXM7XG4gICAgICAgICAgMCA8IGFsbEVudGFuZ2xlZExhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIoYWxsRW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgbGFuZXMgfD0gcm9vdFtpbmRleF07XG4gICAgICAgICAgYWxsRW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgICByZXR1cm4gdGltZW91dEhhbmRsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbW1lZGlhdGUpKVxuICAgICAgICA6IHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb25cbiAgICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2UpKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25IeWRyYXRpb25cbiAgICAgICAgICAgICAgICA6IG51bGwgIT09IHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuXG4gICAgICAgICAgICAgICAgICA/IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgOiBTdXNwZW5kZWRPbkVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSB0aHJvd25WYWx1ZTtcbiAgICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgaWYgKG51bGwgPT09IGVycm9yZWRXb3JrKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQpLFxuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUgJiZcbiAgICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZXJyb3JlZFdvcmspLFxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICBlcnJvcmVkV29yayxcbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gcHJldkRpc3BhdGNoZXIgPyBDb250ZXh0T25seURpc3BhdGNoZXIgOiBwcmV2RGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgIT09XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSB8fFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMCk7XG4gICAgICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzICYgMTM0MjE3NzI3KSkgfHxcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290IHx8XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgICBsYW5lcyA9ICExO1xuICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBhOiBkb1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAocmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkOCkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDgpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2UgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpIDogMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHdvcmtJblByb2dyZXNzID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHR5cGUgb2YgZmliZXIgdHJpZ2dlcmVkIGEgc3VzcGVuc2V5IGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbmRlZFJlYXNvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICAgID8gd29ya0xvb3BTeW5jKClcbiAgICAgICAgICAgIDogd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDkpIHtcbiAgICAgICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQ5KTtcbiAgICAgICAgfVxuICAgICAgd2hpbGUgKDEpO1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCksXG4gICAgICAgICAgUm9vdEluUHJvZ3Jlc3NcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwO1xuICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAhc2hvdWxkWWllbGQoKTsgKVxuICAgICAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gICAgICAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGVcbiAgICAgICAgPyAoc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspLFxuICAgICAgICAgIChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yaykpXG4gICAgICAgIDogKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgbmV4dCA9IHJ1bldpdGhGaWJlckluREVWKHVuaXRPZldvcmssIHJlcGxheUJlZ2luV29yaywgdW5pdE9mV29yayk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IG5leHQgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykgOiAod29ya0luUHJvZ3Jlc3MgPSBuZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5QmVnaW5Xb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGlzUHJvZmlsaW5nTW9kZSA9ICh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZTtcbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJiBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUucmVuZGVyLFxuICAgICAgICAgICAgdW5pdE9mV29yay5yZWYsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspLFxuICAgICAgICAgICAgKHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gICAgICB9XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiZcbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgcm9vdCxcbiAgICAgIHVuaXRPZldvcmssXG4gICAgICB0aHJvd25WYWx1ZSxcbiAgICAgIHN1c3BlbmRlZFJlYXNvblxuICAgICkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nIHx8IHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25FcnJvcikgcm9vdCA9ICEwO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgKVxuICAgICAgICAgIHJvb3QgPSAhMTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uSW1tZWRpYXRlIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSlcbiAgICAgICAgKVxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZFJlYXNvbiAmJlxuICAgICAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICAgICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCByb290KTtcbiAgICAgIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDMyNzY4KSkge1xuICAgICAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICAgIGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGNvbXBsZXRlV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oY29tcGxldGVkV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRXb3JrID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCBza2lwU2libGluZ3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHQpIHtcbiAgICAgICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gdW5pdE9mV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAgIChuZXh0ICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgICBudWxsICE9PSBuZXh0ICYmXG4gICAgICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSxcbiAgICAgICAgICAobmV4dC5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAobmV4dC5kZWxldGlvbnMgPSBudWxsKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAgICAgKCh1bml0T2ZXb3JrID0gdW5pdE9mV29yay5zaWJsaW5nKSwgbnVsbCAhPT0gdW5pdE9mV29yaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdW5pdE9mV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290KFxuICAgICAgcm9vdCxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IERpc2NyZXRlRXZlbnRQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBjb21taXRSb290SW1wbChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHksXG4gICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290SW1wbChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgZG8gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgd2hpbGUgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHJvb3QuZmluaXNoZWRMYW5lcztcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gbWFya0NvbW1pdFN0b3BwZWQoKSwgbnVsbDtcbiAgICAgIDAgPT09IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDA7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgICAgdmFyIHJlbWFpbmluZ0xhbmVzID0gZmluaXNoZWRXb3JrLmxhbmVzIHwgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXM7XG4gICAgICByZW1haW5pbmdMYW5lcyB8PSBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXM7XG4gICAgICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgICByb290LFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgICApO1xuICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCkpO1xuICAgICAgKDAgPT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpICYmXG4gICAgICAgIDAgPT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NikpIHx8XG4gICAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIHx8XG4gICAgICAgICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMCksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgKHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucyksXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cyghMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgdHJhbnNpdGlvbnMgPSAwICE9PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTU5OTApO1xuICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxNTk5MCkgfHwgdHJhbnNpdGlvbnNcbiAgICAgICAgPyAoKHRyYW5zaXRpb25zID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICAoc3Bhd25lZExhbmUgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wKSxcbiAgICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IERpc2NyZXRlRXZlbnRQcmlvcml0eSksXG4gICAgICAgICAgKHVwZGF0ZWRMYW5lcyA9IGV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQpLFxuICAgICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24sIHJvb3QuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgKF9lbmFibGVkID0gISFldmVudHNFbmFibGVkKSxcbiAgICAgICAgICAoc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBldmVudHNFbmFibGVkID0gbnVsbCksXG4gICAgICAgICAgKHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yayksXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkKFxuICAgICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCksXG4gICAgICAgICAgcmVxdWVzdFBhaW50KCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSB1cGRhdGVkTGFuZXMpLFxuICAgICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gc3Bhd25lZExhbmUpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gdHJhbnNpdGlvbnMpKVxuICAgICAgICA6IChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspO1xuICAgICAgKHRyYW5zaXRpb25zID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgID8gKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExKSxcbiAgICAgICAgICAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290KSxcbiAgICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpKVxuICAgICAgICA6IChyZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgICAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCA9PT0gcmVtYWluaW5nTGFuZXMgJiYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCk7XG4gICAgICB0cmFuc2l0aW9ucyB8fCBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gICAgICBvbkNvbW1pdFJvb3QkMShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgb25Db21taXRSb290KCk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICBpZiAobnVsbCAhPT0gcmVjb3ZlcmFibGVFcnJvcnMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yLCBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgICAgIGZpbmlzaGVkV29yayA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsrK1xuICAgICAgICApXG4gICAgICAgICAgKHJlbWFpbmluZ0xhbmVzID0gcmVjb3ZlcmFibGVFcnJvcnNbZmluaXNoZWRXb3JrXSksXG4gICAgICAgICAgICAodHJhbnNpdGlvbnMgPSBtYWtlRXJyb3JJbmZvKHJlbWFpbmluZ0xhbmVzLnN0YWNrKSksXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMuc291cmNlLFxuICAgICAgICAgICAgICByZW5kZXJQcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgICByZW1haW5pbmdMYW5lcy52YWx1ZSxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAwICE9PSAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgJiAzKSAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCAhPT0gKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmIDQxOTQyMTgpICYmXG4gICAgICAwICE9PSAocmVtYWluaW5nTGFuZXMgJiA0MilcbiAgICAgICAgPyAoKG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICByb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXNcbiAgICAgICAgICAgID8gbmVzdGVkVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSkpXG4gICAgICAgIDogKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCk7XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckluZm8oY29tcG9uZW50U3RhY2spIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrID0geyBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2sgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnRTdGFjaywgXCJkaWdlc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1lvdSBhcmUgYWNjZXNzaW5nIFwiZGlnZXN0XCIgZnJvbSB0aGUgZXJyb3JJbmZvIG9iamVjdCBwYXNzZWQgdG8gb25SZWNvdmVyYWJsZUVycm9yLiBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHkgb2YgdGhlIEVycm9yIGluc3RhbmNlIGl0c2VsZi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgICAgIDAgPT09IChyb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXMpICYmXG4gICAgICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICAgICAgbnVsbCAhPSByZW1haW5pbmdMYW5lcyAmJlxuICAgICAgICAgICgocm9vdC5wb29sZWRDYWNoZSA9IG51bGwpLCByZWxlYXNlQ2FjaGUocmVtYWluaW5nTGFuZXMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gICAgICBpZiAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDA7XG4gICAgICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKSxcbiAgICAgICAgICBwcmlvcml0eSA9XG4gICAgICAgICAgICAwID09PSBEZWZhdWx0RXZlbnRQcmlvcml0eSB8fCBEZWZhdWx0RXZlbnRQcmlvcml0eSA+IHJlbmRlclByaW9yaXR5XG4gICAgICAgICAgICAgID8gRGVmYXVsdEV2ZW50UHJpb3JpdHlcbiAgICAgICAgICAgICAgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgICAgcmVuZGVyUHJpb3JpdHkgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByaW9yaXR5O1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIGlmIChudWxsID09PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cylcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztcbiAgICAgICAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJvb3QkanNjb21wJDAgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICAgICAgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgICAgICAgICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgICAgICAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gMDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT1cbiAgICAgICAgICAgICAgTm9Db250ZXh0XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITA7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITE7XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgICAgICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKHJvb3QkanNjb21wJDAuY3VycmVudCk7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgICAgICAgICByb290JGpzY29tcCQwLFxuICAgICAgICAgICAgICByb290JGpzY29tcCQwLmN1cnJlbnQsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gICAgICAgICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCRqc2NvbXAkMCk7XG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzXG4gICAgICAgICAgICAgID8gcm9vdCRqc2NvbXAkMCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgICAgID8gbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgICAgICA6ICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3QkanNjb21wJDApKVxuICAgICAgICAgICAgICA6IChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKTtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPVxuICAgICAgICAgICAgICAhMTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3RcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QkanNjb21wJDApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gcm9vdCRqc2NvbXAkMC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHJlbmRlclByaW9yaXR5KSxcbiAgICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gICAgICByb290RmliZXIgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgc291cmNlRmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdEZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZXJyb3JcbiAgICApIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExO1xuICAgICAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7ICkge1xuICAgICAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKDIpO1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IGVucXVldWVVcGRhdGUobmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IsIDIpO1xuICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIChpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluc3RhbmNlLCAyKSxcbiAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBBdHRlbXB0ZWQgdG8gY2FwdHVyZSBhIGNvbW1pdCBwaGFzZSBlcnJvciBpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gUG90ZW50aWFsIGNhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuIGFscmVhZHktZmluaXNoZWQgdHJlZSwgb3IgYW4gaW5jb25zaXN0ZW50IHJldHVybiBwb2ludGVyLlxcblxcbkVycm9yIG1lc3NhZ2U6XFxuXFxuJXNcIixcbiAgICAgICAgICBlcnJvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBpZiAobnVsbCA9PT0gcGluZ0NhY2hlKSB7XG4gICAgICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgICAgICB2YXIgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKSksXG4gICAgICAgICAgdm9pZCAwID09PSB0aHJlYWRJRHMgJiZcbiAgICAgICAgICAgICgodGhyZWFkSURzID0gbmV3IFNldCgpKSwgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKSk7XG4gICAgICB0aHJlYWRJRHMuaGFzKGxhbmVzKSB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICEwKSxcbiAgICAgICAgdGhyZWFkSURzLmFkZChsYW5lcyksXG4gICAgICAgIChwaW5nQ2FjaGUgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcykpLFxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSxcbiAgICAgICAgd2FrZWFibGUudGhlbihwaW5nQ2FjaGUsIHBpbmdDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgICAgIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgICAgIG51bGwgIT09IHBpbmdDYWNoZSAmJiBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xuICAgICAgcm9vdC53YXJtTGFuZXMgJj0gfnBpbmdlZExhbmVzO1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIlxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHBpbmdlZExhbmVzKSA9PT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpXG4gICAgICAgICAgPyAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDApKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gICAgICBib3VuZGFyeUZpYmVyID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICBudWxsICE9PSBib3VuZGFyeUZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoYm91bmRhcnlGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICByZXRyeUxhbmUgPSAwO1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gICAgICB2YXIgcmV0cnlMYW5lID0gMDtcbiAgICAgIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHJldHJ5Q2FjaGUgJiYgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICByb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpc0luU3RyaWN0TW9kZVxuICAgICkge1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU2MjYyNCkpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBpc0luU3RyaWN0TW9kZSB8fCBpc1N0cmljdE1vZGVGaWJlcjtcbiAgICAgICAgICAyMiAhPT0gZmliZXIudGFnXG4gICAgICAgICAgICA/IGZpYmVyLmZsYWdzICYgMzM1NTQ0MzJcbiAgICAgICAgICAgICAgPyBpc1N0cmljdE1vZGVGaWJlciAmJlxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIChmaWJlci5tb2RlICYgTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUpID09PSBOb01vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIChpc1N0cmljdE1vZGVGaWJlciAmJiBmaWJlci5mbGFncyAmIDgxOTJcbiAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBmaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU1NDQzMiAmJlxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlcikge1xuICAgICAgdmFyIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmliZXIpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpYmVyKSxcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMocm9vdCwgZmliZXIuYWx0ZXJuYXRlLCBmaWJlciwgITEpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmXG4gICAgICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhyb290LCBmaWJlciwgMCwgbnVsbCwgITEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCkge1xuICAgICAgdmFyIGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMDtcbiAgICAgIHJvb3QuY3VycmVudC5tb2RlICYgKFN0cmljdExlZ2FjeU1vZGUgfCBTdHJpY3RFZmZlY3RzTW9kZSkgfHxcbiAgICAgICAgKGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMSk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICByb290LFxuICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDMgPT09IHRhZyB8fFxuICAgICAgICAgIDEgPT09IHRhZyB8fFxuICAgICAgICAgIDAgPT09IHRhZyB8fFxuICAgICAgICAgIDExID09PSB0YWcgfHxcbiAgICAgICAgICAxNCA9PT0gdGFnIHx8XG4gICAgICAgICAgMTUgPT09IHRhZ1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWcgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlJlYWN0Q29tcG9uZW50XCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyh0YWcpKSByZXR1cm47XG4gICAgICAgICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZCh0YWcpO1xuICAgICAgICAgIH0gZWxzZSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbdGFnXSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvIHVzZUVmZmVjdCBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmXG4gICAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsaW5nRmliZXIpIHtcbiAgICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrJDEocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlO1xuICAgICAgcmV0dXJuIG51bGwgIT09IGFjdFF1ZXVlXG4gICAgICAgID8gKGFjdFF1ZXVlLnB1c2goY2FsbGJhY2spLCBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEpXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gICAgICBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmXG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbldoZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSB3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuYWN0KCgpID0+IHtcXG4gIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxufSk7XFxuLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG5UaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdFwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpIHtcbiAgICAgIHJvb3QgIT09IGxhc3RTY2hlZHVsZWRSb290ICYmXG4gICAgICAgIG51bGwgPT09IHJvb3QubmV4dCAmJlxuICAgICAgICAobnVsbCA9PT0gbGFzdFNjaGVkdWxlZFJvb3RcbiAgICAgICAgICA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3QpXG4gICAgICAgICAgOiAobGFzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0ID0gcm9vdCkpO1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICA/IGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITApLFxuICAgICAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKVxuICAgICAgICA6IGRpZFNjaGVkdWxlTWljcm90YXNrIHx8XG4gICAgICAgICAgKChkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICEwKSxcbiAgICAgICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsIG9ubHlMZWdhY3kpIHtcbiAgICAgIGlmICghaXNGbHVzaGluZ1dvcmsgJiYgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrKSB7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZGlkUGVyZm9ybVNvbWVXb3JrID0gITE7XG4gICAgICAgICAgZm9yICh2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDsgbnVsbCAhPT0gcm9vdDsgKSB7XG4gICAgICAgICAgICBpZiAoIW9ubHlMZWdhY3kpXG4gICAgICAgICAgICAgIGlmICgwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHZhciBuZXh0TGFuZXMgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgKDEgPDwgKDMxIC0gY2x6MzIoNDIgfCBzeW5jVHJhbnNpdGlvbkxhbmVzKSArIDEpKSAtIDE7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJj0gcGVuZGluZ0xhbmVzICYgfihzdXNwZW5kZWRMYW5lcyAmIH5waW5nZWRMYW5lcyk7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJiAyMDEzMjY2NzdcbiAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgJiAyMDEzMjY2NzcpIHwgMVxuICAgICAgICAgICAgICAgICAgICAgIDogbmV4dExhbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5leHRMYW5lcyB8IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgMCAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IG5leHRMYW5lcyA6IDBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gKG5leHRMYW5lcyAmIDMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbmV4dExhbmVzKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgcm9vdCA9IHJvb3QubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpIHtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgICAhMTtcbiAgICAgIHZhciBzeW5jVHJhbnNpdGlvbkxhbmVzID0gMDtcbiAgICAgIDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgICAgIChzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkgJiZcbiAgICAgICAgICAoc3luY1RyYW5zaXRpb25MYW5lcyA9IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSxcbiAgICAgICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCkpO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbm93JDEoKSwgcHJldiA9IG51bGwsIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dCxcbiAgICAgICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKDAgPT09IG5leHRMYW5lcylcbiAgICAgICAgICAocm9vdC5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV4dCAmJiAobGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2KTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgICAgICApXG4gICAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICAgIHJvb3QgPSBuZXh0O1xuICAgICAgfVxuICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICAgICAgICBsYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTYyOTE0NTYxO1xuICAgICAgICAwIDwgbGFuZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleCxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleF07XG4gICAgICAgIGlmICgtMSA9PT0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBpZiAoMCA9PT0gKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgfHwgMCAhPT0gKGxhbmUgJiBwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmIChyb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lKTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICBjdXJyZW50VGltZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gY3VycmVudFRpbWUgPyBzdXNwZW5kZWRMYW5lcyA6IDBcbiAgICAgICk7XG4gICAgICBwaW5nZWRMYW5lcyA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSBzdXNwZW5kZWRMYW5lcyB8fFxuICAgICAgICAocm9vdCA9PT0gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbCksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IChzdXNwZW5kZWRMYW5lcyAmIDMpIHx8XG4gICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgc3VzcGVuZGVkTGFuZXMpXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBzdXNwZW5kZWRMYW5lcyAmIC1zdXNwZW5kZWRMYW5lcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnRUaW1lICE9PSByb290LmNhbGxiYWNrUHJpb3JpdHkgfHxcbiAgICAgICAgICAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgICAgIHBpbmdlZExhbmVzICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlKVxuICAgICAgICApXG4gICAgICAgICAgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpO1xuICAgICAgICBlbHNlIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShzdXNwZW5kZWRMYW5lcykpIHtcbiAgICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICB9XG4gICAgICAgIHBpbmdlZExhbmVzID0gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdCk7XG4gICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgPyAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChwaW5nZWRMYW5lcyksXG4gICAgICAgICAgICAoc3VzcGVuZGVkTGFuZXMgPSBmYWtlQWN0Q2FsbGJhY2tOb2RlKSlcbiAgICAgICAgICA6IChzdXNwZW5kZWRMYW5lcyA9IHNjaGVkdWxlQ2FsbGJhY2skMyhzdXNwZW5kZWRMYW5lcywgcGluZ2VkTGFuZXMpKTtcbiAgICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gY3VycmVudFRpbWU7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDI7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrKHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9ICExO1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpICYmIHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA6IDBcbiAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDApIHJldHVybiBudWxsO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwLFxuICAgICAgICBkaWRUaW1lb3V0XG4gICAgICApO1xuICAgICAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3ckMSgpKTtcbiAgICAgIHJldHVybiBudWxsICE9IHJvb3QuY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZVxuICAgICAgICA/IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gICAgICBjYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0XG4gICAgICAgICAgPyBzY2hlZHVsZUNhbGxiYWNrJDMoSW1tZWRpYXRlUHJpb3JpdHksIGNiKVxuICAgICAgICAgIDogY2IoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpKTtcbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlRm9ybUFjdGlvblByb3AoYWN0aW9uUHJvcCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09IGFjdGlvblByb3AgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGFjdGlvblByb3AgfHxcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgICApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvblByb3ApIHJldHVybiBhY3Rpb25Qcm9wO1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihhY3Rpb25Qcm9wLCBcImFjdGlvblwiKTtcbiAgICAgIHJldHVybiBzYW5pdGl6ZVVSTChcIlwiICsgYWN0aW9uUHJvcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICAgIHZhciB0ZW1wID0gc3VibWl0dGVyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgdGVtcC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gICAgICB0ZW1wLnZhbHVlID0gc3VibWl0dGVyLnZhbHVlO1xuICAgICAgZm9ybS5pZCAmJiB0ZW1wLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgZm9ybS5pZCk7XG4gICAgICBzdWJtaXR0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcCwgc3VibWl0dGVyKTtcbiAgICAgIGZvcm0gPSBuZXcgRm9ybURhdGEoZm9ybSk7XG4gICAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcCk7XG4gICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdWJtaXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgIG1heWJlVGFyZ2V0SW5zdCAmJlxuICAgICAgICBtYXliZVRhcmdldEluc3Quc3RhdGVOb2RlID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBjb2VyY2VGb3JtQWN0aW9uUHJvcChcbiAgICAgICAgICAgIChuYXRpdmVFdmVudFRhcmdldFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKS5hY3Rpb25cbiAgICAgICAgICApLFxuICAgICAgICAgIHN1Ym1pdHRlciA9IG5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgICAgc3VibWl0dGVyICYmXG4gICAgICAgICAgKChkb21FdmVudE5hbWUgPSAoZG9tRXZlbnROYW1lID0gc3VibWl0dGVyW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpXG4gICAgICAgICAgICA/IGNvZXJjZUZvcm1BY3Rpb25Qcm9wKGRvbUV2ZW50TmFtZS5mb3JtQWN0aW9uKVxuICAgICAgICAgICAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSksXG4gICAgICAgICAgbnVsbCAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgICAoKGFjdGlvbiA9IGRvbUV2ZW50TmFtZSksIChzdWJtaXR0ZXIgPSBudWxsKSkpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gc3VibWl0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRm9ybURhdGEobmF0aXZlRXZlbnRUYXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEhvc3RUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIChldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgICAgICAoZm9ybURhdGEgPSBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKG5hdGl2ZUV2ZW50VGFyZ2V0KSksXG4gICAgICAgICAgICAgICAgICAgIChwZW5kaW5nU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogITAsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBuYXRpdmVFdmVudFRhcmdldC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1N0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRIb3N0VHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICBtYXliZVRhcmdldEluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gICAgICBldmVudFN5c3RlbUZsYWdzID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2Rpc3BhdGNoUXVldWUkaSA9IGRpc3BhdGNoUXVldWVbaV07XG4gICAgICAgIGE6IHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNJbnN0YW5jZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGV2ZW50ID0gX2Rpc3BhdGNoUXVldWUkaS5ldmVudDtcbiAgICAgICAgICBfZGlzcGF0Y2hRdWV1ZSRpID0gX2Rpc3BhdGNoUXVldWUkaS5saXN0ZW5lcnM7XG4gICAgICAgICAgaWYgKGV2ZW50U3lzdGVtRmxhZ3MpXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgaSRqc2NvbXAkMCA9IF9kaXNwYXRjaFF1ZXVlJGkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMCA8PSBpJGpzY29tcCQwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwLS1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpW2kkanNjb21wJDBdLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBldmVudDtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2hMaXN0ZW5lcnMkaShwcmV2aW91c0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZS5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgX2Rpc3BhdGNoUXVldWUkaS5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoUXVldWUkaVtpJGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBldmVudDtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2hMaXN0ZW5lcnMkaShwcmV2aW91c0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZS5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgICBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZVxuICAgICAgICApO1xuICAgICAgdmFyIGxpc3RlbmVyU2V0ID0gdGFyZ2V0RWxlbWVudFtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuICAgICAgdm9pZCAwID09PSBsaXN0ZW5lclNldCAmJlxuICAgICAgICAobGlzdGVuZXJTZXQgPSB0YXJnZXRFbGVtZW50W2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBuZXcgU2V0KCkpO1xuICAgICAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZG9tRXZlbnROYW1lICsgXCJfX2J1YmJsZVwiO1xuICAgICAgbGlzdGVuZXJTZXQuaGFzKGxpc3RlbmVyU2V0S2V5KSB8fFxuICAgICAgICAoYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCAyLCAhMSksXG4gICAgICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciwgdGFyZ2V0KSB7XG4gICAgICBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgJiZcbiAgICAgICAgIWlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05hdGl2ZUV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiIGluIHRoZSBidWJibGUgcGhhc2UuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICAgZG9tRXZlbnROYW1lXG4gICAgICAgICk7XG4gICAgICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IDA7XG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIChldmVudFN5c3RlbUZsYWdzIHw9IDQpO1xuICAgICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCkge1xuICAgICAgaWYgKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgICAgIHJvb3RDb250YWluZXJFbGVtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMDtcbiAgICAgICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICAgIFwic2VsZWN0aW9uY2hhbmdlXCIgIT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgKG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSB8fFxuICAgICAgICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgITEsIHJvb3RDb250YWluZXJFbGVtZW50KSxcbiAgICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCAhMCwgcm9vdENvbnRhaW5lckVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID1cbiAgICAgICAgICA5ID09PSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZVxuICAgICAgICAgICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgICAgICAgICAgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICBudWxsID09PSBvd25lckRvY3VtZW50IHx8XG4gICAgICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdIHx8XG4gICAgICAgICAgKChvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMCksXG4gICAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChcInNlbGVjdGlvbmNoYW5nZVwiLCAhMSwgb3duZXJEb2N1bWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICB2YXIgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoQ29udGludW91c0V2ZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICB9XG4gICAgICBldmVudFN5c3RlbUZsYWdzID0gbGlzdGVuZXJXcmFwcGVyLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgICApO1xuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gdm9pZCAwO1xuICAgICAgIXBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkIHx8XG4gICAgICAgIChcInRvdWNoc3RhcnRcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgXCJ0b3VjaG1vdmVcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgXCJ3aGVlbFwiICE9PSBkb21FdmVudE5hbWUpIHx8XG4gICAgICAgIChsaXN0ZW5lcldyYXBwZXIgPSAhMCk7XG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgICAgID8gdm9pZCAwICE9PSBsaXN0ZW5lcldyYXBwZXJcbiAgICAgICAgICA/IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywge1xuICAgICAgICAgICAgICBjYXB0dXJlOiAhMCxcbiAgICAgICAgICAgICAgcGFzc2l2ZTogbGlzdGVuZXJXcmFwcGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCAhMClcbiAgICAgICAgOiB2b2lkIDAgIT09IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICAgID8gdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB7XG4gICAgICAgICAgICAgIHBhc3NpdmU6IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICB0YXJnZXRJbnN0JGpzY29tcCQwLFxuICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgKSB7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0ID0gdGFyZ2V0SW5zdCRqc2NvbXAkMDtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiAxKSAmJlxuICAgICAgICAwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDIpICYmXG4gICAgICAgIG51bGwgIT09IHRhcmdldEluc3QkanNjb21wJDBcbiAgICAgIClcbiAgICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICAgIGlmIChudWxsID09PSB0YXJnZXRJbnN0JGpzY29tcCQwKSByZXR1cm47XG4gICAgICAgICAgdmFyIG5vZGVUYWcgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnRhZztcbiAgICAgICAgICBpZiAoMyA9PT0gbm9kZVRhZyB8fCA0ID09PSBub2RlVGFnKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY29udGFpbmVyID09PSB0YXJnZXRDb250YWluZXIgfHxcbiAgICAgICAgICAgICAgKDggPT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKDQgPT09IG5vZGVUYWcpXG4gICAgICAgICAgICAgIGZvciAobm9kZVRhZyA9IHRhcmdldEluc3QkanNjb21wJDAucmV0dXJuOyBudWxsICE9PSBub2RlVGFnOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhbmRUYWcgPSBub2RlVGFnLnRhZztcbiAgICAgICAgICAgICAgICBpZiAoMyA9PT0gZ3JhbmRUYWcgfHwgNCA9PT0gZ3JhbmRUYWcpXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICgoZ3JhbmRUYWcgPSBub2RlVGFnLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRUYWcgPT09IHRhcmdldENvbnRhaW5lciB8fFxuICAgICAgICAgICAgICAgICAgICAgICg4ID09PSBncmFuZFRhZy5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRUYWcucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyKSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5vZGVUYWcgPSBub2RlVGFnLnJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IG51bGwgIT09IGNvbnRhaW5lcjsgKSB7XG4gICAgICAgICAgICAgIG5vZGVUYWcgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZVRhZykgcmV0dXJuO1xuICAgICAgICAgICAgICBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgNSA9PT0gZ3JhbmRUYWcgfHxcbiAgICAgICAgICAgICAgICA2ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgICAgIDI2ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgICAgIDI3ID09PSBncmFuZFRhZ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJbnN0JGpzY29tcCQwID0gYW5jZXN0b3JJbnN0ID0gbm9kZVRhZztcbiAgICAgICAgICAgICAgICBjb250aW51ZSBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRJbnN0JGpzY29tcCQwID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGJhdGNoZWRVcGRhdGVzJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFyZ2V0SW5zdCA9IGFuY2VzdG9ySW5zdCxcbiAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSxcbiAgICAgICAgICBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgICAgIGE6IHtcbiAgICAgICAgICB2YXIgcmVhY3ROYW1lID0gdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuZ2V0KGRvbUV2ZW50TmFtZSk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcmVhY3ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRXZlbnQsXG4gICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuICAgICAgICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpKSBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gXCJmb2N1c1wiO1xuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gXCJibHVyXCI7XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJlZm9yZWJsdXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFmdGVyYmx1clwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgICAgICAgIGlmICgyID09PSBuYXRpdmVFdmVudC5idXR0b24pIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdXhjbGlja1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxuICAgICAgICAgICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb250ZXh0bWVudVwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnZW5kXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRyYWdleGl0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnbGVhdmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRyb3BcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGNhbmNlbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX0VORDpcbiAgICAgICAgICAgICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgICAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUUkFOU0lUSU9OX0VORDpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjcm9sbGVuZFwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjb3B5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBhc3RlXCI6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyY2FuY2VsXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyZG93blwiOlxuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVydXBcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b2dnbGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvZ2dsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluQ2FwdHVyZVBoYXNlID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KSxcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZVRhcmdldE9ubHkgPVxuICAgICAgICAgICAgICAgICFpbkNhcHR1cmVQaGFzZSAmJlxuICAgICAgICAgICAgICAgIChcInNjcm9sbFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJzY3JvbGxlbmRcIiA9PT0gZG9tRXZlbnROYW1lKSxcbiAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBpbkNhcHR1cmVQaGFzZVxuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gcmVhY3ROYW1lXG4gICAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IHJlYWN0TmFtZTtcbiAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gW107XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRJbnN0LCBsYXN0SG9zdENvbXBvbmVudDtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2U7XG5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IF9pbnN0YW5jZTIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBfaW5zdGFuY2UyID0gX2luc3RhbmNlMi50YWc7XG4gICAgICAgICAgICAgICg1ICE9PSBfaW5zdGFuY2UyICYmIDI2ICE9PSBfaW5zdGFuY2UyICYmIDI3ICE9PSBfaW5zdGFuY2UyKSB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT09IGxhc3RIb3N0Q29tcG9uZW50IHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVhY3RFdmVudE5hbWUgfHxcbiAgICAgICAgICAgICAgICAoKF9pbnN0YW5jZTIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpKSxcbiAgICAgICAgICAgICAgICBudWxsICE9IF9pbnN0YW5jZTIgJiZcbiAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlMixcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGVUYXJnZXRPbmx5KSBicmVhaztcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAwIDwgaW5DYXB0dXJlUGhhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICAgICgocmVhY3ROYW1lID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihcbiAgICAgICAgICAgICAgICByZWFjdE5hbWUsXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudDogcmVhY3ROYW1lLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogaW5DYXB0dXJlUGhhc2VcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA3KSkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgICAgIFwibW91c2VvdmVyXCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdmVyXCIgPT09IGRvbUV2ZW50TmFtZTtcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9XG4gICAgICAgICAgICAgIFwibW91c2VvdXRcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwicG9pbnRlcm91dFwiID09PSBkb21FdmVudE5hbWU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJlYWN0TmFtZSAmJlxuICAgICAgICAgICAgICBuYXRpdmVFdmVudCAhPT0gY3VycmVudFJlcGxheWluZ0V2ZW50ICYmXG4gICAgICAgICAgICAgIChyZWFjdEV2ZW50VHlwZSA9XG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgKGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKSB8fFxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3RvciB8fCByZWFjdE5hbWUpIHtcbiAgICAgICAgICAgICAgcmVhY3ROYW1lID1cbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICA6IChyZWFjdE5hbWUgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZS5kZWZhdWx0VmlldyB8fCByZWFjdE5hbWUucGFyZW50V2luZG93XG4gICAgICAgICAgICAgICAgICAgIDogd2luZG93O1xuICAgICAgICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKChyZWFjdEV2ZW50VHlwZSA9XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgIChTeW50aGV0aWNFdmVudEN0b3IgPSB0YXJnZXRJbnN0KSxcbiAgICAgICAgICAgICAgICAgIChyZWFjdEV2ZW50VHlwZSA9IHJlYWN0RXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVhY3RFdmVudFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZWFjdEV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAoKGFjY3VtdWxhdGVUYXJnZXRPbmx5ID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHJlYWN0RXZlbnRUeXBlKSksXG4gICAgICAgICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZSA9IHJlYWN0RXZlbnRUeXBlLnRhZyksXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlICE9PSBhY2N1bXVsYXRlVGFyZ2V0T25seSB8fFxuICAgICAgICAgICAgICAgICAgICAgICg1ICE9PSBpbkNhcHR1cmVQaGFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgMjcgIT09IGluQ2FwdHVyZVBoYXNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICA2ICE9PSBpbkNhcHR1cmVQaGFzZSkpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIChTeW50aGV0aWNFdmVudEN0b3IgPSBudWxsKSwgKHJlYWN0RXZlbnRUeXBlID0gdGFyZ2V0SW5zdCk7XG4gICAgICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgIT09IHJlYWN0RXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICAgICAgICAgIF9pbnN0YW5jZTIgPSBcIm9uTW91c2VMZWF2ZVwiO1xuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lID0gXCJvbk1vdXNlRW50ZXJcIjtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IFwibW91c2VcIjtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBcInBvaW50ZXJvdXRcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgICAgICAgICAgICAgICBcInBvaW50ZXJvdmVyXCIgPT09IGRvbUV2ZW50TmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudCksXG4gICAgICAgICAgICAgICAgICAgIChfaW5zdGFuY2UyID0gXCJvblBvaW50ZXJMZWF2ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlYWN0RXZlbnROYW1lID0gXCJvblBvaW50ZXJFbnRlclwiKSxcbiAgICAgICAgICAgICAgICAgICAgKGluc3RhbmNlID0gXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID1cbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gU3ludGhldGljRXZlbnRDdG9yXG4gICAgICAgICAgICAgICAgICAgID8gcmVhY3ROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Tm9kZUZyb21JbnN0YW5jZShTeW50aGV0aWNFdmVudEN0b3IpO1xuICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID1cbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gcmVhY3RFdmVudFR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyByZWFjdE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBnZXROb2RlRnJvbUluc3RhbmNlKHJlYWN0RXZlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICByZWFjdE5hbWUgPSBuZXcgaW5DYXB0dXJlUGhhc2UoXG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UyLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgKyBcImxlYXZlXCIsXG4gICAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZWFjdE5hbWUudGFyZ2V0ID0gYWNjdW11bGF0ZVRhcmdldE9ubHk7XG4gICAgICAgICAgICAgICAgcmVhY3ROYW1lLnJlbGF0ZWRUYXJnZXQgPSBsYXN0SG9zdENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCkgPT09IHRhcmdldEluc3QgJiZcbiAgICAgICAgICAgICAgICAgICgoaW5DYXB0dXJlUGhhc2UgPSBuZXcgaW5DYXB0dXJlUGhhc2UoXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSArIFwiZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UudGFyZ2V0ID0gbGFzdEhvc3RDb21wb25lbnQpLFxuICAgICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlLnJlbGF0ZWRUYXJnZXQgPSBhY2N1bXVsYXRlVGFyZ2V0T25seSksXG4gICAgICAgICAgICAgICAgICAoX2luc3RhbmNlMiA9IGluQ2FwdHVyZVBoYXNlKSk7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSBfaW5zdGFuY2UyO1xuICAgICAgICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgJiYgcmVhY3RFdmVudFR5cGUpXG4gICAgICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljRXZlbnRDdG9yO1xuICAgICAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBpbkNhcHR1cmVQaGFzZTtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IGdldFBhcmVudChsYXN0SG9zdENvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlKys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UyID0gcmVhY3RFdmVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlMjtcbiAgICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UyID0gZ2V0UGFyZW50KF9pbnN0YW5jZTIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCsrO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgMCA8IGluc3RhbmNlIC0gbGFzdEhvc3RDb21wb25lbnQ7IClcbiAgICAgICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UgPSBnZXRQYXJlbnQoaW5DYXB0dXJlUGhhc2UpKSwgaW5zdGFuY2UtLTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDAgPCBsYXN0SG9zdENvbXBvbmVudCAtIGluc3RhbmNlOyApXG4gICAgICAgICAgICAgICAgICAgICAgKHJlYWN0RXZlbnROYW1lID0gZ2V0UGFyZW50KHJlYWN0RXZlbnROYW1lKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudC0tO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaW5zdGFuY2UtLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobnVsbCAhPT0gcmVhY3RFdmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPT09IHJlYWN0RXZlbnROYW1lLmFsdGVybmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gZ2V0UGFyZW50KGluQ2FwdHVyZVBoYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaW5DYXB0dXJlUGhhc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIG51bGwgIT09IFN5bnRoZXRpY0V2ZW50Q3RvciAmJlxuICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhY3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZWFjdEV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gYWNjdW11bGF0ZVRhcmdldE9ubHkgJiZcbiAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5LFxuICAgICAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UsXG4gICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHJlYWN0TmFtZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID1cbiAgICAgICAgICAgICAgcmVhY3ROYW1lLm5vZGVOYW1lICYmIHJlYWN0TmFtZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInNlbGVjdFwiID09PSBTeW50aGV0aWNFdmVudEN0b3IgfHxcbiAgICAgICAgICAgICAgKFwiaW5wdXRcIiA9PT0gU3ludGhldGljRXZlbnRDdG9yICYmIFwiZmlsZVwiID09PSByZWFjdE5hbWUudHlwZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHJlYWN0TmFtZSkpXG4gICAgICAgICAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoU3ludGhldGljRXZlbnRDdG9yID0gcmVhY3ROYW1lLm5vZGVOYW1lKSxcbiAgICAgICAgICAgICAgICAhU3ludGhldGljRXZlbnRDdG9yIHx8XG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiICE9PSBTeW50aGV0aWNFdmVudEN0b3IudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgIChcImNoZWNrYm94XCIgIT09IHJlYWN0TmFtZS50eXBlICYmIFwicmFkaW9cIiAhPT0gcmVhY3ROYW1lLnR5cGUpXG4gICAgICAgICAgICAgICAgICA/IHRhcmdldEluc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50KHRhcmdldEluc3QuZWxlbWVudFR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudClcbiAgICAgICAgICAgICAgICAgIDogKGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyAmJlxuICAgICAgICAgICAgICAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgICAgIGdldFRhcmdldEluc3RGdW5jLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVFdmVudEZ1bmMgJiZcbiAgICAgICAgICAgICAgaGFuZGxlRXZlbnRGdW5jKGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lLCB0YXJnZXRJbnN0KTtcbiAgICAgICAgICAgIFwiZm9jdXNvdXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgICAgIHRhcmdldEluc3QgJiZcbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gcmVhY3ROYW1lLnR5cGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPSB0YXJnZXRJbnN0Lm1lbW9pemVkUHJvcHMudmFsdWUgJiZcbiAgICAgICAgICAgICAgc2V0RGVmYXVsdFZhbHVlKHJlYWN0TmFtZSwgXCJudW1iZXJcIiwgcmVhY3ROYW1lLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gdGFyZ2V0SW5zdFxuICAgICAgICAgICAgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpXG4gICAgICAgICAgICA6IHdpbmRvdztcbiAgICAgICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzVGV4dElucHV0RWxlbWVudChoYW5kbGVFdmVudEZ1bmMpIHx8XG4gICAgICAgICAgICAgICAgXCJ0cnVlXCIgPT09IGhhbmRsZUV2ZW50RnVuYy5jb250ZW50RWRpdGFibGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIChhY3RpdmVFbGVtZW50ID0gaGFuZGxlRXZlbnRGdW5jKSxcbiAgICAgICAgICAgICAgICAgIChhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3QpLFxuICAgICAgICAgICAgICAgICAgKGxhc3RTZWxlY3Rpb24gPSBudWxsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IGFjdGl2ZUVsZW1lbnRJbnN0ID0gYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxuICAgICAgICAgICAgICBtb3VzZURvd24gPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgICAgICBtb3VzZURvd24gPSAhMTtcbiAgICAgICAgICAgICAgY29uc3RydWN0U2VsZWN0RXZlbnQoXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpcbiAgICAgICAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgICAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZhbGxiYWNrRGF0YTtcbiAgICAgICAgICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudClcbiAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvblN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uRW5kXCI7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpc0NvbXBvc2luZ1xuICAgICAgICAgICAgICA/IGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSAmJlxuICAgICAgICAgICAgICAgIChldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25FbmRcIilcbiAgICAgICAgICAgICAgOiBcImtleWRvd25cIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERSAmJlxuICAgICAgICAgICAgICAgIChldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25TdGFydFwiKTtcbiAgICAgICAgICBldmVudFR5cGUgJiZcbiAgICAgICAgICAgICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJlxuICAgICAgICAgICAgICBcImtvXCIgIT09IG5hdGl2ZUV2ZW50LmxvY2FsZSAmJlxuICAgICAgICAgICAgICAoaXNDb21wb3NpbmcgfHwgXCJvbkNvbXBvc2l0aW9uU3RhcnRcIiAhPT0gZXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgPyBcIm9uQ29tcG9zaXRpb25FbmRcIiA9PT0gZXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgICAgICBpc0NvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAgICAgKGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKSlcbiAgICAgICAgICAgICAgICA6ICgocm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgIChzdGFydFRleHQgPSBcInZhbHVlXCIgaW4gcm9vdCA/IHJvb3QudmFsdWUgOiByb290LnRleHRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgIChpc0NvbXBvc2luZyA9ICEwKSkpLFxuICAgICAgICAgICAgKGhhbmRsZUV2ZW50RnVuYyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhcbiAgICAgICAgICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIDAgPCBoYW5kbGVFdmVudEZ1bmMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICgoZXZlbnRUeXBlID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoXG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBoYW5kbGVFdmVudEZ1bmNcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGZhbGxiYWNrRGF0YVxuICAgICAgICAgICAgICAgID8gKGV2ZW50VHlwZS5kYXRhID0gZmFsbGJhY2tEYXRhKVxuICAgICAgICAgICAgICAgIDogKChmYWxsYmFja0RhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmYWxsYmFja0RhdGEgJiYgKGV2ZW50VHlwZS5kYXRhID0gZmFsbGJhY2tEYXRhKSkpKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoZmFsbGJhY2tEYXRhID0gY2FuVXNlVGV4dElucHV0RXZlbnRcbiAgICAgICAgICAgICAgPyBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpXG4gICAgICAgICAgICAgIDogZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChldmVudFR5cGUgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoXG4gICAgICAgICAgICAgIHRhcmdldEluc3QsXG4gICAgICAgICAgICAgIFwib25CZWZvcmVJbnB1dFwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgMCA8IGV2ZW50VHlwZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoKGhhbmRsZUV2ZW50RnVuYyA9IG5ldyBTeW50aGV0aWNJbnB1dEV2ZW50KFxuICAgICAgICAgICAgICAgICAgXCJvbkJlZm9yZUlucHV0XCIsXG4gICAgICAgICAgICAgICAgICBcImJlZm9yZWlucHV0XCIsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICBldmVudDogaGFuZGxlRXZlbnRGdW5jLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBldmVudFR5cGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAoaGFuZGxlRXZlbnRGdW5jLmRhdGEgPSBmYWxsYmFja0RhdGEpKTtcbiAgICAgICAgICBleHRyYWN0RXZlbnRzJDEoXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiLCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgbnVsbCAhPT0gdGFyZ2V0RmliZXI7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IHRhcmdldEZpYmVyLFxuICAgICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2UzID0gX2luc3RhbmNlMy50YWc7XG4gICAgICAgICg1ICE9PSBfaW5zdGFuY2UzICYmIDI2ICE9PSBfaW5zdGFuY2UzICYmIDI3ICE9PSBfaW5zdGFuY2UzKSB8fFxuICAgICAgICAgIG51bGwgPT09IHN0YXRlTm9kZSB8fFxuICAgICAgICAgICgoX2luc3RhbmNlMyA9IGdldExpc3RlbmVyKHRhcmdldEZpYmVyLCBjYXB0dXJlTmFtZSkpLFxuICAgICAgICAgIG51bGwgIT0gX2luc3RhbmNlMyAmJlxuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoXG4gICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0RmliZXIsIF9pbnN0YW5jZTMsIHN0YXRlTm9kZSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKF9pbnN0YW5jZTMgPSBnZXRMaXN0ZW5lcih0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSksXG4gICAgICAgICAgbnVsbCAhPSBfaW5zdGFuY2UzICYmXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXRGaWJlciwgX2luc3RhbmNlMywgc3RhdGVOb2RlKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIHRhcmdldEZpYmVyID0gdGFyZ2V0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgICAgIGlmIChudWxsID09PSBpbnN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGRvIGluc3QgPSBpbnN0LnJldHVybjtcbiAgICAgIHdoaWxlIChpbnN0ICYmIDUgIT09IGluc3QudGFnICYmIDI3ICE9PSBpbnN0LnRhZyk7XG4gICAgICByZXR1cm4gaW5zdCA/IGluc3QgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGV2ZW50LFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29tbW9uLFxuICAgICAgaW5DYXB0dXJlUGhhc2VcbiAgICApIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZSwgbGlzdGVuZXJzID0gW107XG4gICAgICAgIG51bGwgIT09IHRhcmdldCAmJiB0YXJnZXQgIT09IGNvbW1vbjtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2U0ID0gdGFyZ2V0LFxuICAgICAgICAgIGFsdGVybmF0ZSA9IF9pbnN0YW5jZTQuYWx0ZXJuYXRlLFxuICAgICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTQuc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2U0ID0gX2luc3RhbmNlNC50YWc7XG4gICAgICAgIGlmIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIGJyZWFrO1xuICAgICAgICAoNSAhPT0gX2luc3RhbmNlNCAmJiAyNiAhPT0gX2luc3RhbmNlNCAmJiAyNyAhPT0gX2luc3RhbmNlNCkgfHxcbiAgICAgICAgICBudWxsID09PSBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAoKGFsdGVybmF0ZSA9IHN0YXRlTm9kZSksXG4gICAgICAgICAgaW5DYXB0dXJlUGhhc2VcbiAgICAgICAgICAgID8gKChzdGF0ZU5vZGUgPSBnZXRMaXN0ZW5lcih0YXJnZXQsIHJlZ2lzdHJhdGlvbk5hbWUpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBzdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0LCBzdGF0ZU5vZGUsIGFsdGVybmF0ZSlcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiBpbkNhcHR1cmVQaGFzZSB8fFxuICAgICAgICAgICAgICAoKHN0YXRlTm9kZSA9IGdldExpc3RlbmVyKHRhcmdldCwgcmVnaXN0cmF0aW9uTmFtZSkpLFxuICAgICAgICAgICAgICBudWxsICE9IHN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXQsIHN0YXRlTm9kZSwgYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJldHVybjtcbiAgICAgIH1cbiAgICAgIDAgIT09IGxpc3RlbmVycy5sZW5ndGggJiZcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBsaXN0ZW5lcnM6IGxpc3RlbmVycyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0eXBlLCBwcm9wcykge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIHZhciBldmVudFJlZ2lzdHJ5ID0ge1xuICAgICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzXG4gICAgICB9O1xuICAgICAgaXNDdXN0b21FbGVtZW50KHR5cGUpIHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xuICAgICAgcHJvcHMuY29udGVudEVkaXRhYmxlICYmXG4gICAgICAgICFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgIHByb3BOYW1lLFxuICAgICAgc2VydmVyVmFsdWUsXG4gICAgICBjbGllbnRWYWx1ZSxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBzZXJ2ZXJWYWx1ZSAhPT0gY2xpZW50VmFsdWUgJiZcbiAgICAgICAgKChjbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSkpLFxuICAgICAgICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpICE9PSBjbGllbnRWYWx1ZSAmJlxuICAgICAgICAgIChzZXJ2ZXJEaWZmZXJlbmNlc1twcm9wTmFtZV0gPSBzZXJ2ZXJWYWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzLFxuICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICApIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNbZ2V0UHJvcE5hbWVGcm9tQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKV0gPVxuICAgICAgICAgIFwic3R5bGVcIiA9PT0gYXR0cmlidXRlTmFtZVxuICAgICAgICAgICAgPyBnZXRTdHlsZXNPYmplY3RGcm9tRWxlbWVudChkb21FbGVtZW50KVxuICAgICAgICAgICAgOiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICExID09PSBsaXN0ZW5lclxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG5JZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuXCIsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbk5hbWVcbiAgICAgICAgICApXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS5cIixcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgICAgICB0eXBlb2YgbGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVIVE1MKHBhcmVudCwgaHRtbCkge1xuICAgICAgcGFyZW50ID1cbiAgICAgICAgcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSF9OQU1FU1BBQ0UgfHxcbiAgICAgICAgcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRVxuICAgICAgICAgID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICBwYXJlbnQubmFtZXNwYWNlVVJJLFxuICAgICAgICAgICAgICBwYXJlbnQudGFnTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSk7XG4gICAgICBwYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBwYXJlbnQuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUobWFya3VwKSB7XG4gICAgICB3aWxsQ29lcmNpb25UaHJvdyhtYXJrdXApICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICB0eXBlTmFtZShtYXJrdXApXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihtYXJrdXApKTtcbiAgICAgIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1hcmt1cCA/IG1hcmt1cCA6IFwiXCIgKyBtYXJrdXApXG4gICAgICAgIC5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgXCJcXG5cIilcbiAgICAgICAgLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCBcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICAgIGNsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpID09PSBjbGllbnRUZXh0XG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywga2V5LCB2YWx1ZSwgcHJvcHMsIHByZXZWYWx1ZSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgICAgIHZhbGlkYXRlVGV4dE5lc3RpbmcodmFsdWUsIHRhZyksXG4gICAgICAgICAgICAgIFwiYm9keVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgICAgICAoXCJ0ZXh0YXJlYVwiID09PSB0YWcgJiYgXCJcIiA9PT0gdmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgdmFsdWUpO1xuICAgICAgICAgIGVsc2UgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcImJpZ2ludFwiID09PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgICAgICB2YWxpZGF0ZVRleHROZXN0aW5nKFwiXCIgKyB2YWx1ZSwgdGFnKSxcbiAgICAgICAgICAgICAgXCJib2R5XCIgIT09IHRhZyAmJiBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBcImNsYXNzXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBcInRhYmluZGV4XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwicm9sZVwiOlxuICAgICAgICBjYXNlIFwidmlld0JveFwiOlxuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHZhbHVlLCBwcmV2VmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0YWcpIHtcbiAgICAgICAgICAgIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUoZG9tRWxlbWVudCwgXCJkYXRhXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIGlmIChcIlwiID09PSB2YWx1ZSAmJiAoXCJhXCIgIT09IHRhZyB8fCBcImhyZWZcIiAhPT0ga2V5KSkge1xuICAgICAgICAgICAgXCJzcmNcIiA9PT0ga2V5XG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVGhpcyBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHdob2xlIHBhZ2UgYWdhaW4gb3ZlciB0aGUgbmV0d29yay4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBrZXkpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZvcm1cIiA9PT0gdGFnXG4gICAgICAgICAgICAgID8gXCJmb3JtQWN0aW9uXCIgPT09IGtleVxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgY2FuIG9ubHkgcGFzcyB0aGUgZm9ybUFjdGlvbiBwcm9wIHRvIDxpbnB1dD4gb3IgPGJ1dHRvbj4uIFVzZSB0aGUgYWN0aW9uIHByb3Agb24gPGZvcm0+LlwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgKChudWxsID09IHByb3BzLmVuY1R5cGUgJiYgbnVsbCA9PSBwcm9wcy5tZXRob2QpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGVuY1R5cGUgb3IgbWV0aG9kIGZvciBhIGZvcm0gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBudWxsID09IHByb3BzLnRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogXCJpbnB1dFwiID09PSB0YWcgfHwgXCJidXR0b25cIiA9PT0gdGFnXG4gICAgICAgICAgICAgICAgPyBcImFjdGlvblwiID09PSBrZXlcbiAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIllvdSBjYW4gb25seSBwYXNzIHRoZSBhY3Rpb24gcHJvcCB0byA8Zm9ybT4uIFVzZSB0aGUgZm9ybUFjdGlvbiBwcm9wIG9uIDxpbnB1dD4gb3IgPGJ1dHRvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBcImlucHV0XCIgIT09IHRhZyB8fFxuICAgICAgICAgICAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyBcImJ1dHRvblwiICE9PSB0YWcgfHxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICBcInN1Ym1pdFwiID09PSBwcm9wcy50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlXG4gICAgICAgICAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gcHJvcHMubmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IGEgXCJuYW1lXCIgcHJvcCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IHByb3BzLmZvcm1FbmNUeXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT0gcHJvcHMuZm9ybU1ldGhvZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybUVuY1R5cGUgb3IgZm9ybU1ldGhvZCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IHByb3ZpZGVzIHRob3NlIGF1dG9tYXRpY2FsbHkuIFRoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT0gcHJvcHMuZm9ybVRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtVGFyZ2V0IGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICgoZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0EgYnV0dG9uIGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIG5vIHR5cGUuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgOiAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FuIGlucHV0IGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIHR5cGU9XCJpbWFnZVwiLidcbiAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogXCJhY3Rpb25cIiA9PT0ga2V5XG4gICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJZb3UgY2FuIG9ubHkgcGFzcyB0aGUgYWN0aW9uIHByb3AgdG8gPGZvcm0+LlwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIllvdSBjYW4gb25seSBwYXNzIHRoZSBmb3JtQWN0aW9uIHByb3AgdG8gPGlucHV0PiBvciA8YnV0dG9uPi5cIlxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ0EgUmVhY3QgZm9ybSB3YXMgdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4gSWYgeW91IGNhbGxlZCBmb3JtLnN1Ym1pdCgpIG1hbnVhbGx5LCBjb25zaWRlciB1c2luZyBmb3JtLnJlcXVlc3RTdWJtaXQoKSBpbnN0ZWFkLiBJZiB5b3VcXFxcJ3JlIHRyeWluZyB0byB1c2UgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgaW4gYSBzdWJtaXQgZXZlbnQgaGFuZGxlciwgY29uc2lkZXIgYWxzbyBjYWxsaW5nIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuJylcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldlZhbHVlICYmXG4gICAgICAgICAgICAgIChcImZvcm1BY3Rpb25cIiA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyAoXCJpbnB1dFwiICE9PSB0YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwibmFtZVwiLCBwcm9wcy5uYW1lLCBwcm9wcywgbnVsbCksXG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybUVuY1R5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBcImZvcm1NZXRob2RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9ybU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybVRhcmdldFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JtVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6IChzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIFwiZW5jVHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5lbmNUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcIm1ldGhvZFwiLCBwcm9wcy5tZXRob2QsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBrZXkpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9uQ2xpY2tcIjpcbiAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgKGRvbUVsZW1lbnQub25jbGljayA9IG5vb3AkMSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkb21FbGVtZW50KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvblNjcm9sbEVuZFwiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSksXG4gICAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRvbUVsZW1lbnQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgdmFsdWUgfHwgIShcIl9faHRtbFwiIGluIHZhbHVlKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAga2V5ID0gdmFsdWUuX19odG1sO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgZG9tRWxlbWVudC5tdWx0aXBsZSA9XG4gICAgICAgICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgIGRvbUVsZW1lbnQubXV0ZWQgPVxuICAgICAgICAgICAgdmFsdWUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiYgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rSHJlZlwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwieGxpbms6aHJlZlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBrZXkpO1xuICAgICAgICAgIGtleSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyh4bGlua05hbWVzcGFjZSwgXCJ4bGluazpocmVmXCIsIGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgID8gKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKSlcbiAgICAgICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgXCJcIiAhPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtrZXldIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtrZXldID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiBlbXB0eSBzdHJpbmcgZm9yIGEgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gVGhpcyB3aWxsIHRyZWF0IHRoZSBhdHRyaWJ1dGUgYXMgaWYgaXQgd2VyZSBmYWxzZS4gRWl0aGVyIHBhc3MgYGZhbHNlYCB0byBzaWxlbmNlIHRoaXMgd2FybmluZywgb3IgcGFzcyBgdHJ1ZWAgaWYgeW91IHVzZWQgYW4gZW1wdHkgc3RyaW5nIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgUmVhY3QgdG8gaW5kaWNhdGUgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZS5cIixcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICEwID09PSB2YWx1ZVxuICAgICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgICAgICA6ICExICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgICA/IChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBrZXkpLFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgIDEgPD0gdmFsdWVcbiAgICAgICAgICAgID8gKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpKVxuICAgICAgICAgICAgOiBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm93U3BhblwiOlxuICAgICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICBpc05hTih2YWx1ZSlcbiAgICAgICAgICAgID8gZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgICAgICAgOiAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwga2V5KSxcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9wb3ZlclwiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJiZWZvcmV0b2dnbGVcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBcInBvcG92ZXJcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhsaW5rTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bGluazphY3R1YXRlXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeGxpbmtOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhsaW5rOmFyY3JvbGVcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB4bGlua05hbWVzcGFjZSxcbiAgICAgICAgICAgIFwieGxpbms6cm9sZVwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhsaW5rTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bGluazpzaG93XCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhsaW5rTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bGluazp0aXRsZVwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhsaW5rTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bGluazp0eXBlXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhtbE5hbWVzcGFjZSxcbiAgICAgICAgICAgIFwieG1sOmJhc2VcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbExhbmdcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeG1sTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bWw6bGFuZ1wiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sU3BhY2VcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeG1sTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bWw6c3BhY2VcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlzXCI6XG4gICAgICAgICAgbnVsbCAhPSBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXBkYXRlIHRoZSBcImlzXCIgcHJvcCBhZnRlciBpdCBoYXMgYmVlbiBpbml0aWFsaXplZC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwiaXNcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9wb3ZlclRhcmdldFwiOlxuICAgICAgICAgIGRpZFdhcm5Qb3BvdmVyVGFyZ2V0T2JqZWN0IHx8XG4gICAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgICgoZGlkV2FyblBvcG92ZXJUYXJnZXRPYmplY3QgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgcG9wb3ZlclRhcmdldGAgcHJvcCBleHBlY3RzIHRoZSBJRCBvZiBhbiBFbGVtZW50IGFzIGEgc3RyaW5nLiBSZWNlaXZlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgISgyIDwga2V5Lmxlbmd0aCkgfHxcbiAgICAgICAgICAoXCJvXCIgIT09IGtleVswXSAmJiBcIk9cIiAhPT0ga2V5WzBdKSB8fFxuICAgICAgICAgIChcIm5cIiAhPT0ga2V5WzFdICYmIFwiTlwiICE9PSBrZXlbMV0pXG4gICAgICAgICAgICA/ICgoa2V5ID0gZ2V0QXR0cmlidXRlQWxpYXMoa2V5KSksXG4gICAgICAgICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIGtleSwgdmFsdWUpKVxuICAgICAgICAgICAgOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFByb3BPbkN1c3RvbUVsZW1lbnQoXG4gICAgICBkb21FbGVtZW50LFxuICAgICAgdGFnLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBwcm9wcyxcbiAgICAgIHByZXZWYWx1ZVxuICAgICkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgdmFsdWUsIHByZXZWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgIGlmIChudWxsICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHZhbHVlIHx8ICEoXCJfX2h0bWxcIiBpbiB2YWx1ZSkpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGtleSA9IHZhbHVlLl9faHRtbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkb21FbGVtZW50LmlubmVySFRNTCA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgPyBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCB2YWx1ZSlcbiAgICAgICAgICAgIDogKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcImJpZ2ludFwiID09PSB0eXBlb2YgdmFsdWUpICYmXG4gICAgICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvblNjcm9sbFwiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSksXG4gICAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsXCIsIGRvbUVsZW1lbnQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9uU2Nyb2xsRW5kXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKSxcbiAgICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxlbmRcIiwgZG9tRWxlbWVudCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSksXG4gICAgICAgICAgICAoZG9tRWxlbWVudC5vbmNsaWNrID0gbm9vcCQxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvXCIgPT09IGtleVswXSAmJlxuICAgICAgICAgICAgICAgIFwiblwiID09PSBrZXlbMV0gJiZcbiAgICAgICAgICAgICAgICAoKHByb3BzID0ga2V5LmVuZHNXaXRoKFwiQ2FwdHVyZVwiKSksXG4gICAgICAgICAgICAgICAgKHRhZyA9IGtleS5zbGljZSgyLCBwcm9wcyA/IGtleS5sZW5ndGggLSA3IDogdm9pZCAwKSksXG4gICAgICAgICAgICAgICAgKHByZXZWYWx1ZSA9IGRvbUVsZW1lbnRbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgKHByZXZWYWx1ZSA9IG51bGwgIT0gcHJldlZhbHVlID8gcHJldlZhbHVlW2tleV0gOiBudWxsKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0YWcsIHByZXZWYWx1ZSwgcHJvcHMpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgKGtleSBpbiBkb21FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgID8gKGRvbUVsZW1lbnRba2V5XSA9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIDogZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSkpO1xuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0YWcsIHZhbHVlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBrZXkgaW4gZG9tRWxlbWVudFxuICAgICAgICAgICAgICAgID8gKGRvbUVsZW1lbnRba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgICAgIDogITAgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIilcbiAgICAgICAgICAgICAgICAgIDogc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBwcm9wcyk7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgY2FzZSBcImxpXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgdmFyIGhhc1NyYyA9ICExLFxuICAgICAgICAgICAgaGFzU3JjU2V0ID0gITEsXG4gICAgICAgICAgICBwcm9wS2V5O1xuICAgICAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgICAgICAgICAgICAgaGFzU3JjID0gITA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNyY1NldFwiOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcmNTZXQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXksIHByb3BWYWx1ZSwgcHJvcHMsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBoYXNTcmNTZXQgJiZcbiAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcInNyY1NldFwiLCBwcm9wcy5zcmNTZXQsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICBoYXNTcmMgJiYgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwic3JjXCIsIHByb3BzLnNyYywgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcImlucHV0XCIsIHByb3BzKTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gKHByb3BLZXkgPSBwcm9wVmFsdWUgPSBoYXNTcmNTZXQgPSBudWxsKSxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuICAgICAgICAgIGZvciAoaGFzU3JjIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGhhc1NyYykpIHtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wVmFsdWUgPSBwcm9wc1toYXNTcmNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBfcHJvcFZhbHVlKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGFzU3JjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcmNTZXQgPSBfcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IF9wcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IF9wcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gX3Byb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IF9wcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBfcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IF9wcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgaGFzU3JjLCBfcHJvcFZhbHVlLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICAgICAgaW5pdElucHV0KFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICBwcm9wVmFsdWUsXG4gICAgICAgICAgICBoYXNTcmNTZXQsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInNlbGVjdFwiLCBwcm9wcyk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgaGFzU3JjID0gcHJvcFZhbHVlID0gcHJvcEtleSA9IG51bGw7XG4gICAgICAgICAgZm9yIChoYXNTcmNTZXQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGhhc1NyY1NldCkgJiZcbiAgICAgICAgICAgICAgKChkZWZhdWx0VmFsdWUgPSBwcm9wc1toYXNTcmNTZXRdKSwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoaGFzU3JjU2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBwcm9wS2V5ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgICAgICBoYXNTcmMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgaGFzU3JjU2V0LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgdmFsaWRhdGVTZWxlY3RQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICAgICAgdGFnID0gcHJvcEtleTtcbiAgICAgICAgICBwcm9wcyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBkb21FbGVtZW50Lm11bHRpcGxlID0gISFoYXNTcmM7XG4gICAgICAgICAgbnVsbCAhPSB0YWdcbiAgICAgICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIWhhc1NyYywgdGFnLCAhMSlcbiAgICAgICAgICAgIDogbnVsbCAhPSBwcm9wcyAmJiB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhaGFzU3JjLCBwcm9wcywgITApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInRleHRhcmVhXCIsIHByb3BzKTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBwcm9wS2V5ID0gaGFzU3JjU2V0ID0gaGFzU3JjID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHByb3BWYWx1ZSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcFZhbHVlKSAmJlxuICAgICAgICAgICAgICAoKGRlZmF1bHRWYWx1ZSA9IHByb3BzW3Byb3BWYWx1ZV0pLCBudWxsICE9IGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB2YWxpZGF0ZVRleHRhcmVhUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgICAgIGluaXRUZXh0YXJlYShkb21FbGVtZW50LCBoYXNTcmMsIGhhc1NyY1NldCwgcHJvcEtleSk7XG4gICAgICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgdmFsaWRhdGVPcHRpb25Qcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICAgICAgZm9yIChjaGVja2VkIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShjaGVja2VkKSAmJlxuICAgICAgICAgICAgICAoKGhhc1NyYyA9IHByb3BzW2NoZWNrZWRdKSwgbnVsbCAhPSBoYXNTcmMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgIGhhc1NyYyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBoYXNTcmMgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGhhc1NyYztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgY2hlY2tlZCwgaGFzU3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2FuY2VsXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjbG9zZVwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlmcmFtZVwiOlxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgICAgICBmb3IgKGhhc1NyYyA9IDA7IGhhc1NyYyA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGhhc1NyYysrKVxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaGFzU3JjXSwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFpbHNcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KSxcbiAgICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdENoZWNrZWQpICYmXG4gICAgICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdENoZWNrZWRdKSwgbnVsbCAhPSBoYXNTcmMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoZGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0Q2hlY2tlZCwgaGFzU3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKF9wcm9wVmFsdWUgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KF9wcm9wVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1tfcHJvcFZhbHVlXSksXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBoYXNTcmMgJiZcbiAgICAgICAgICAgICAgICAgIHNldFByb3BPbkN1c3RvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaGFzU3JjLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGRlZmF1bHRWYWx1ZSBpbiBwcm9wcylcbiAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSAmJlxuICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgbnVsbCAhPSBoYXNTcmMgJiZcbiAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIGhhc1NyYywgcHJvcHMsIG51bGwpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFByb3BzKTtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJkaXZcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgdHlwZSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsLFxuICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGVja2VkID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICBpZiAobGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpICYmIG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9wcm9wS2V5OCBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wS2V5ID0gbmV4dFByb3BzW19wcm9wS2V5OF07XG4gICAgICAgICAgICBsYXN0UHJvcCA9IGxhc3RQcm9wc1tfcHJvcEtleThdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXk4KSAmJlxuICAgICAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5IHx8IG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoX3Byb3BLZXk4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BLZXk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSAhPT0gbGFzdFByb3AgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTgsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcgPVxuICAgICAgICAgICAgXCJjaGVja2JveFwiID09PSBsYXN0UHJvcHMudHlwZSB8fCBcInJhZGlvXCIgPT09IGxhc3RQcm9wcy50eXBlXG4gICAgICAgICAgICAgID8gbnVsbCAhPSBsYXN0UHJvcHMuY2hlY2tlZFxuICAgICAgICAgICAgICA6IG51bGwgIT0gbGFzdFByb3BzLnZhbHVlO1xuICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICBcImNoZWNrYm94XCIgPT09IG5leHRQcm9wcy50eXBlIHx8IFwicmFkaW9cIiA9PT0gbmV4dFByb3BzLnR5cGVcbiAgICAgICAgICAgICAgPyBudWxsICE9IG5leHRQcm9wcy5jaGVja2VkXG4gICAgICAgICAgICAgIDogbnVsbCAhPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICAgICAgdGFnIHx8XG4gICAgICAgICAgICAhbmV4dFByb3BzIHx8XG4gICAgICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgY29udHJvbGxlZC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byBhIGRlZmluZWQgdmFsdWUsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9ICEwKSk7XG4gICAgICAgICAgIXRhZyB8fFxuICAgICAgICAgICAgbmV4dFByb3BzIHx8XG4gICAgICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgdW5jb250cm9sbGVkLiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvIHVuZGVmaW5lZCwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gITApKTtcbiAgICAgICAgICB1cGRhdGVJbnB1dChcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgcHJvcEtleSA9IHZhbHVlID0gZGVmYXVsdFZhbHVlID0gX3Byb3BLZXk4ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHR5cGUgaW4gbGFzdFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbdHlwZV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IGxhc3REZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChuYW1lIGluIG5leHRQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKCh0eXBlID0gbmV4dFByb3BzW25hbWVdKSxcbiAgICAgICAgICAgICAgKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbbmFtZV0pLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAobnVsbCAhPSB0eXBlIHx8IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4ID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gbGFzdERlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3BzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIHRhZyA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RQcm9wcyA9IHByb3BLZXk7XG4gICAgICAgICAgbnVsbCAhPSBfcHJvcEtleThcbiAgICAgICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIXRhZywgX3Byb3BLZXk4LCAhMSlcbiAgICAgICAgICAgIDogISFsYXN0UHJvcHMgIT09ICEhdGFnICYmXG4gICAgICAgICAgICAgIChudWxsICE9IG5leHRQcm9wc1xuICAgICAgICAgICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIXRhZywgbmV4dFByb3BzLCAhMClcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISF0YWcsIHRhZyA/IFtdIDogXCJcIiwgITEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIHByb3BLZXkgPSBfcHJvcEtleTggPSBudWxsO1xuICAgICAgICAgIGZvciAoZGVmYXVsdFZhbHVlIGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gbGFzdFByb3BzW2RlZmF1bHRWYWx1ZV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIG51bGwsIG5leHRQcm9wcywgbmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhbHVlIGluIG5leHRQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gbmV4dFByb3BzW3ZhbHVlXSksXG4gICAgICAgICAgICAgICh0eXBlID0gbGFzdFByb3BzW3ZhbHVlXSksXG4gICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgKG51bGwgIT0gbmFtZSB8fCBudWxsICE9IHR5cGUpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBfcHJvcEtleTggPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5hbWUgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHZhbHVlLCBuYW1lLCBuZXh0UHJvcHMsIHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlVGV4dGFyZWEoZG9tRWxlbWVudCwgX3Byb3BLZXk4LCBwcm9wS2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTEzIGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChfcHJvcEtleTggPSBsYXN0UHJvcHNbX3Byb3BLZXkxM10pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxMykgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxMykpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoX3Byb3BLZXkxMykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXkxMyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleThcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxhc3REZWZhdWx0VmFsdWUgaW4gbmV4dFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKF9wcm9wS2V5OCA9IG5leHRQcm9wc1tsYXN0RGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2xhc3REZWZhdWx0VmFsdWVdKSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGxhc3REZWZhdWx0VmFsdWUpICYmXG4gICAgICAgICAgICAgICAgX3Byb3BLZXk4ICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgKG51bGwgIT0gX3Byb3BLZXk4IHx8IG51bGwgIT0gcHJvcEtleSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAobGFzdERlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgIF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfcHJvcEtleTggJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIF9wcm9wS2V5ODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wS2V5OCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTE1IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIChfcHJvcEtleTggPSBsYXN0UHJvcHNbX3Byb3BLZXkxNV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxNSkgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxNSkgJiZcbiAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgIF9wcm9wS2V5MTUsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGNoZWNrZWQgaW4gbmV4dFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKF9wcm9wS2V5OCA9IG5leHRQcm9wc1tjaGVja2VkXSksXG4gICAgICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2NoZWNrZWRdKSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgX3Byb3BLZXk4ICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgKG51bGwgIT0gX3Byb3BLZXk4IHx8IG51bGwgIT0gcHJvcEtleSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gX3Byb3BLZXk4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTE3IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgICAgKF9wcm9wS2V5OCA9IGxhc3RQcm9wc1tfcHJvcEtleTE3XSksXG4gICAgICAgICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wS2V5MTcpICYmXG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcEtleTE3KSAmJlxuICAgICAgICAgICAgICAgICAgc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTE3LFxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgIChfcHJvcEtleTggPSBuZXh0UHJvcHNbZGVmYXVsdENoZWNrZWRdKSxcbiAgICAgICAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tkZWZhdWx0Q2hlY2tlZF0pLFxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgICBfcHJvcEtleTggPT09IHByb3BLZXkgfHxcbiAgICAgICAgICAgICAgICAgICh2b2lkIDAgPT09IF9wcm9wS2V5OCAmJiB2b2lkIDAgPT09IHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTgsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcEtleTE5IGluIGxhc3RQcm9wcylcbiAgICAgICAgKF9wcm9wS2V5OCA9IGxhc3RQcm9wc1tfcHJvcEtleTE5XSksXG4gICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wS2V5MTkpICYmXG4gICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcEtleTE5KSAmJlxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIF9wcm9wS2V5MTksIG51bGwsIG5leHRQcm9wcywgX3Byb3BLZXk4KTtcbiAgICAgIGZvciAobGFzdFByb3AgaW4gbmV4dFByb3BzKVxuICAgICAgICAoX3Byb3BLZXk4ID0gbmV4dFByb3BzW2xhc3RQcm9wXSksXG4gICAgICAgICAgKHByb3BLZXkgPSBsYXN0UHJvcHNbbGFzdFByb3BdKSxcbiAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KGxhc3RQcm9wKSB8fFxuICAgICAgICAgICAgX3Byb3BLZXk4ID09PSBwcm9wS2V5IHx8XG4gICAgICAgICAgICAobnVsbCA9PSBfcHJvcEtleTggJiYgbnVsbCA9PSBwcm9wS2V5KSB8fFxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wLCBfcHJvcEtleTgsIG5leHRQcm9wcywgcHJvcEtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByb3BOYW1lRnJvbUF0dHJpYnV0ZU5hbWUoYXR0ck5hbWUpIHtcbiAgICAgIHN3aXRjaCAoYXR0ck5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgcmV0dXJuIFwiY2xhc3NOYW1lXCI7XG4gICAgICAgIGNhc2UgXCJmb3JcIjpcbiAgICAgICAgICByZXR1cm4gXCJodG1sRm9yXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGF0dHJOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZXNPYmplY3RGcm9tRWxlbWVudChkb21FbGVtZW50KSB7XG4gICAgICB2YXIgc2VydmVyVmFsdWVJbk9iamVjdEZvcm0gPSB7fTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LnN0eWxlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21FbGVtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZU5hbWUgPSBkb21FbGVtZW50W2ldO1xuICAgICAgICBzZXJ2ZXJWYWx1ZUluT2JqZWN0Rm9ybVtzdHlsZU5hbWVdID1cbiAgICAgICAgICBkb21FbGVtZW50LmdldFByb3BlcnR5VmFsdWUoc3R5bGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZUluT2JqZWN0Rm9ybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZkh5ZHJhdGVkU3R5bGVzKGRvbUVsZW1lbnQsIHZhbHVlJGpzY29tcCQwLCBzZXJ2ZXJEaWZmZXJlbmNlcykge1xuICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDAgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHZhbHVlJGpzY29tcCQwKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIHZhciBjbGllbnRWYWx1ZTtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IChjbGllbnRWYWx1ZSA9IFwiXCIpLFxuICAgICAgICAgIHN0eWxlTmFtZTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgaWYgKHZhbHVlJGpzY29tcCQwLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlJGpzY29tcCQwW3N0eWxlTmFtZV07XG4gICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJcIiAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgKDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIilcbiAgICAgICAgICAgICAgICA/IChjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHN0eWxlTmFtZSksXG4gICAgICAgICAgICAgICAgICAoY2xpZW50VmFsdWUgKz1cbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyICsgc3R5bGVOYW1lICsgXCI6XCIgKyAoXCJcIiArIHZhbHVlKS50cmltKCkpKVxuICAgICAgICAgICAgICAgIDogXCJudW1iZXJcIiAhPT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgIHVuaXRsZXNzTnVtYmVycy5oYXMoc3R5bGVOYW1lKVxuICAgICAgICAgICAgICAgICAgPyAoY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAoY2xpZW50VmFsdWUgKz1cbiAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgK1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgXCItJDFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShtc1BhdHRlcm4kMSwgXCItbXMtXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyB2YWx1ZSkudHJpbSgpKSlcbiAgICAgICAgICAgICAgICAgIDogKGNsaWVudFZhbHVlICs9XG4gICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyICtcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIFwiLSQxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobXNQYXR0ZXJuJDEsIFwiLW1zLVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICBcInB4XCIpLFxuICAgICAgICAgICAgICAoZGVsaW1pdGVyID0gXCI7XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNsaWVudFZhbHVlID0gY2xpZW50VmFsdWUgfHwgbnVsbDtcbiAgICAgICAgdmFsdWUkanNjb21wJDAgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICB2YWx1ZSRqc2NvbXAkMCAhPT0gY2xpZW50VmFsdWUgJiZcbiAgICAgICAgICAoKGNsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKSksXG4gICAgICAgICAgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHZhbHVlJGpzY29tcCQwKSAhPT0gY2xpZW50VmFsdWUgJiZcbiAgICAgICAgICAgIChzZXJ2ZXJEaWZmZXJlbmNlcy5zdHlsZSA9IGdldFN0eWxlc09iamVjdEZyb21FbGVtZW50KGRvbUVsZW1lbnQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICBkb21FbGVtZW50LFxuICAgICAgcHJvcEtleSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKG51bGwgPT09IGRvbUVsZW1lbnQpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChudWxsICE9IHZhbHVlKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BLZXkpLFxuICAgICAgICAgICAgICBkb21FbGVtZW50ID09PSBcIlwiICsgdmFsdWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIGRvbUVsZW1lbnQsIHZhbHVlLCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh5ZHJhdGVCb29sZWFuQXR0cmlidXRlKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIHByb3BLZXksXG4gICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmIChudWxsID09PSBkb21FbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodmFsdWUpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIGRvbUVsZW1lbnQsIHZhbHVlLCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh5ZHJhdGVCb29sZWFuaXNoQXR0cmlidXRlKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIHByb3BLZXksXG4gICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmIChudWxsID09PSBkb21FbGVtZW50KVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgICAgICBkb21FbGVtZW50ID09PSBcIlwiICsgdmFsdWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIGRvbUVsZW1lbnQsIHZhbHVlLCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh5ZHJhdGVOdW1lcmljQXR0cmlidXRlKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIHByb3BLZXksXG4gICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmIChudWxsID09PSBkb21FbGVtZW50KVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChudWxsICE9IHZhbHVlKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcEtleSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQgPT09IFwiXCIgKyB2YWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHlkcmF0ZVNhbml0aXplZEF0dHJpYnV0ZShcbiAgICAgIGRvbUVsZW1lbnQsXG4gICAgICBwcm9wS2V5LFxuICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICApIHtcbiAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBkb21FbGVtZW50ID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBpZiAobnVsbCA9PT0gZG9tRWxlbWVudClcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcEtleSksXG4gICAgICAgICAgICAgIChhdHRyaWJ1dGVOYW1lID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQgPT09IGF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIGRvbUVsZW1lbnQsIHZhbHVlLCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBwcm9wcywgaG9zdENvbnRleHQpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzZXJ2ZXJEaWZmZXJlbmNlcyA9IHt9LFxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyA9IG5ldyBTZXQoKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgICBpIDwgYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXNbaV0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgICB9XG4gICAgICBpZiAoaXNDdXN0b21FbGVtZW50KHRhZykpXG4gICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKVxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICBlbHNlIGlmICghMCAhPT0gcHJvcHMuc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUgJiYgXCJudW1iZXJcIiAhPT0gdHlwZW9mIHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUuX19odG1sIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh2YWx1ZSA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgdmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShwcm9wS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZkh5ZHJhdGVkU3R5bGVzKGRvbUVsZW1lbnQsIHZhbHVlLCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldFBhcmVudFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldFRvcFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldExlZnRcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJvZmZzZXRXaWR0aFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldEhlaWdodFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImlzQ29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib3V0ZXJUZXh0XCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib3V0ZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkFzc2lnbm1lbnQgdG8gcmVhZC1vbmx5IHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGEgbm8tb3A6IGAlc2BcIixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZU9uQ3VzdG9tQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBob3N0Q29udGV4dC5jb250ZXh0ID09PSBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdmdcIiAhPT0gdGFnICYmXG4gICAgICAgICAgICAgICAgICAgIFwibWF0aFwiICE9PSB0YWdcbiAgICAgICAgICAgICAgICAgICAgICA/IGV4dHJhQXR0cmlidXRlcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShwcm9wS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAoYXR0cmlidXRlcyA9IGdldFZhbHVlRm9yQXR0cmlidXRlT25DdXN0b21Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAodmFsdWUgaW4gcHJvcHMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmXG4gICAgICAgICAgICAoKHByb3BLZXkgPSBwcm9wc1t2YWx1ZV0pLCBudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKVxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHZhbHVlLCBwcm9wS2V5KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCEwICE9PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpXG4gICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcEtleSAmJlxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiICE9PSB0eXBlb2YgcHJvcEtleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LnRleHRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IHByb3BLZXkgPyBwcm9wS2V5Ll9faHRtbCA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgICAgICAgICAoKHByb3BLZXkgPSBub3JtYWxpemVIVE1MKGRvbUVsZW1lbnQsIHByb3BLZXkpKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyAhPT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzZXJ2ZXJEaWZmZXJlbmNlc1t2YWx1ZV0gPSB7IF9faHRtbDogYXR0cmlidXRlcyB9KSk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWJpbmRleFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGRpZmZIeWRyYXRlZFN0eWxlcyhkb21FbGVtZW50LCBwcm9wS2V5LCBzZXJ2ZXJEaWZmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5tdWx0aXBsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5tdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwiYXV0b2ZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5hdXRvZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gcHJvcEtleSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcImFcIiA9PT0gdGFnICYmIFwiaHJlZlwiID09PSB2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdGFnICYmIFwiZGF0YVwiID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRoaXMgbWF5IGNhdXNlIHRoZSBicm93c2VyIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBwYWdlIGFnYWluIG92ZXIgdGhlIG5ldHdvcmsuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTYW5pdGl6ZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTYW5pdGl6ZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybUFjdGlvblwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJuYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShcImZvcm1lbmN0eXBlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShcImZvcm1tZXRob2RcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwiZm9ybXRhcmdldFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IChleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwiZW5jdHlwZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJtZXRob2RcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwidGFyZ2V0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMgPT09IEVYUEVDVEVEX0ZPUk1fQUNUSU9OX1VSTCkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlU2FuaXRpemVkQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua0hyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTYW5pdGl6ZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVCb29sZWFuaXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50ZWRpdGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQm9vbGVhbmlzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwic3BlbGxjaGVja1wiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQm9vbGVhbmlzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUJvb2xlYW5BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGRvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gKGF0dHJpYnV0ZXMgPSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXMkanNjb21wJDAgPSBzZXJ2ZXJEaWZmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGkuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gaSlcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gcHJvcEtleSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT0gcHJvcEtleSlcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHByb3BLZXkgJiYgXCJcIiA9PT0gaSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJvcEtleSwgYXR0cmlidXRlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9PT0gXCJcIiArIHByb3BLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sc1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICBpID0gZG9tRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXMkanNjb21wJDAgPSBzZXJ2ZXJEaWZmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGkuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gaSlcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocHJvcEtleSkgfHwgMSA+IHByb3BLZXkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGlzTmFOKHByb3BLZXkpIHx8IDEgPiBwcm9wS2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByb3BLZXksIGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IFwiXCIgKyBwcm9wS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOdW1lcmljQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJyb3dzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOdW1lcmljQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieEhlaWdodFwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwieC1oZWlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua0FjdHVhdGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOmFjdHVhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOmFyY3JvbGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua1JvbGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOnJvbGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua1Nob3dcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOnNob3dcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazp0aXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInhsaW5rVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwieGxpbms6dHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInhtbEJhc2VcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhtbDpiYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwieG1sOmxhbmdcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bWxTcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwieG1sOnNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgICAgIFwiXCIgIT09IHByb3BLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW3ZhbHVlXSB8fFxuICAgICAgICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVt2YWx1ZV0gPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiBlbXB0eSBzdHJpbmcgZm9yIGEgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gVGhpcyB3aWxsIHRyZWF0IHRoZSBhdHRyaWJ1dGUgYXMgaWYgaXQgd2VyZSBmYWxzZS4gRWl0aGVyIHBhc3MgYGZhbHNlYCB0byBzaWxlbmNlIHRoaXMgd2FybmluZywgb3IgcGFzcyBgdHJ1ZWAgaWYgeW91IHVzZWQgYW4gZW1wdHkgc3RyaW5nIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgUmVhY3QgdG8gaW5kaWNhdGUgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVCb29sZWFuQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhKDIgPCB2YWx1ZS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgICAgIChcIm9cIiAhPT0gdmFsdWVbMF0gJiYgXCJPXCIgIT09IHZhbHVlWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoXCJuXCIgIT09IHZhbHVlWzFdICYmIFwiTlwiICE9PSB2YWx1ZVsxXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpID0gZ2V0QXR0cmlidXRlQWxpYXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gITE7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RDb250ZXh0LmNvbnRleHQgPT09IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZSAmJlxuICAgICAgICAgICAgICAgICAgICBcInN2Z1wiICE9PSB0YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJtYXRoXCIgIT09IHRhZ1xuICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKGF0dHJpYnV0ZU5hbWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChhdHRyaWJ1dGVOYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gcG9zc2libGVTdGFuZGFyZE5hbWVzW2F0dHJpYnV0ZU5hbWVdIHx8IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGF0dHJpYnV0ZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChhdHRyaWJ1dGVzID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoaSkpO1xuICAgICAgICAgICAgICAgICAgICBhOiBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgKChhdHRyaWJ1dGVOYW1lID0gZG9tRWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgKHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwID0gaSksXG4gICAgICAgICAgICAgICAgICAgICAgKGkgPSBwcm9wS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZU5hbWVTYWZlKHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUuaGFzQXR0cmlidXRlKHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIChhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS5nZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChpID0gYXR0cmlidXRlTmFtZSA9PT0gXCJcIiArIGkgPyBpIDogYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGF0dHJpYnV0ZU5hbWUgPSBzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgNSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhLVwiICE9PSBhdHRyaWJ1dGVOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1cIiAhPT0gYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHZvaWQgMCA9PT0gaSA/IHZvaWQgMCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAwIDwgZXh0cmFBdHRyaWJ1dGVzLnNpemUgJiZcbiAgICAgICAgITAgIT09IHByb3BzLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyAmJlxuICAgICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGRvbUVsZW1lbnQsIGV4dHJhQXR0cmlidXRlcywgc2VydmVyRGlmZmVyZW5jZXMpO1xuICAgICAgcmV0dXJuIDAgPT09IE9iamVjdC5rZXlzKHNlcnZlckRpZmZlcmVuY2VzKS5sZW5ndGhcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogc2VydmVyRGlmZmVyZW5jZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BOYW1lc0xpc3RKb2luKGxpc3QsIGNvbWJpbmF0b3IpIHtcbiAgICAgIHN3aXRjaCAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGxpc3RbMF07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbGlzdFswXSArIFwiIFwiICsgY29tYmluYXRvciArIFwiIFwiICsgbGlzdFsxXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbGlzdC5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICBjb21iaW5hdG9yICtcbiAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgIGxpc3RbbGlzdC5sZW5ndGggLSAxXVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuIDkgPT09IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlXG4gICAgICAgID8gcm9vdENvbnRhaW5lckVsZW1lbnRcbiAgICAgICAgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25Ib3N0Q29udGV4dChuYW1lc3BhY2VVUkkpIHtcbiAgICAgIHN3aXRjaCAobmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGNhc2UgU1ZHX05BTUVTUEFDRTpcbiAgICAgICAgICByZXR1cm4gSG9zdENvbnRleHROYW1lc3BhY2VTdmc7XG4gICAgICAgIGNhc2UgTUFUSF9OQU1FU1BBQ0U6XG4gICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlTWF0aDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gSG9zdENvbnRleHROYW1lc3BhY2VOb25lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0UHJvZChwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgICAgIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZSlcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnO1xuICAgICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gSG9zdENvbnRleHROYW1lc3BhY2VNYXRoO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSG9zdENvbnRleHROYW1lc3BhY2VOb25lO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50TmFtZXNwYWNlID09PSBIb3N0Q29udGV4dE5hbWVzcGFjZVN2ZyAmJlxuICAgICAgICBcImZvcmVpZ25PYmplY3RcIiA9PT0gdHlwZVxuICAgICAgICA/IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZVxuICAgICAgICA6IHBhcmVudE5hbWVzcGFjZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwidGV4dGFyZWFcIiA9PT0gdHlwZSB8fFxuICAgICAgICBcIm5vc2NyaXB0XCIgPT09IHR5cGUgfHxcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gfHxcbiAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxuICAgICAgICAgIG51bGwgIT09IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmXG4gICAgICAgICAgbnVsbCAhPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICAgICAgaWYgKGV2ZW50ICYmIFwicG9wc3RhdGVcIiA9PT0gZXZlbnQudHlwZSkge1xuICAgICAgICBpZiAoZXZlbnQgPT09IGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCkgcmV0dXJuICExO1xuICAgICAgICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgY3VycmVudFBvcHN0YXRlVHJhbnNpdGlvbkV2ZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3JJbk5leHRUaWNrKGVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIG5ld1Byb3BzLmF1dG9Gb2N1cyAmJiBkb21FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICBuZXdQcm9wcy5zcmNcbiAgICAgICAgICAgID8gKGRvbUVsZW1lbnQuc3JjID0gbmV3UHJvcHMuc3JjKVxuICAgICAgICAgICAgOiBuZXdQcm9wcy5zcmNTZXQgJiYgKGRvbUVsZW1lbnQuc3Jjc2V0ID0gbmV3UHJvcHMuc3JjU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0VXBkYXRlKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgZG9tRWxlbWVudFtpbnRlcm5hbFByb3BzS2V5XSA9IG5ld1Byb3BzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgOCA9PT0gY29udGFpbmVyLm5vZGVUeXBlXG4gICAgICAgID8gY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gICAgICAgIDogY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KHBhcmVudEluc3RhbmNlLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSAmJiA4ID09PSBuZXh0Tm9kZS5ub2RlVHlwZSlcbiAgICAgICAgICBpZiAoKChub2RlID0gbmV4dE5vZGUuZGF0YSksIG5vZGUgPT09IFNVU1BFTlNFX0VORF9EQVRBKSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGRlcHRoKSB7XG4gICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5leHROb2RlKTtcbiAgICAgICAgICAgICAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChub2RlICE9PSBTVVNQRU5TRV9TVEFSVF9EQVRBICYmXG4gICAgICAgICAgICAgIG5vZGUgIT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSAmJlxuICAgICAgICAgICAgICBub2RlICE9PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBKSB8fFxuICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5zdHlsZTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNldFByb3BlcnR5XG4gICAgICAgID8gaW5zdGFuY2Uuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKVxuICAgICAgICA6IChpbnN0YW5jZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgcHJvcHMgPSBwcm9wc1tTVFlMRV07XG4gICAgICBwcm9wcyA9XG4gICAgICAgIHZvaWQgMCAhPT0gcHJvcHMgJiYgbnVsbCAhPT0gcHJvcHMgJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpXG4gICAgICAgICAgPyBwcm9wcy5kaXNwbGF5XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9XG4gICAgICAgIG51bGwgPT0gcHJvcHMgfHwgXCJib29sZWFuXCIgPT09IHR5cGVvZiBwcm9wcyA/IFwiXCIgOiAoXCJcIiArIHByb3BzKS50cmltKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lclNwYXJpbmdseShjb250YWluZXIpIHtcbiAgICAgIHZhciBuZXh0Tm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgbmV4dE5vZGUgJiYgMTAgPT09IG5leHROb2RlLm5vZGVUeXBlICYmIChuZXh0Tm9kZSA9IG5leHROb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgIGZvciAoOyBuZXh0Tm9kZTsgKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV4dE5vZGU7XG4gICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJIVE1MXCI6XG4gICAgICAgICAgY2FzZSBcIkhFQURcIjpcbiAgICAgICAgICBjYXNlIFwiQk9EWVwiOlxuICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkobm9kZSk7XG4gICAgICAgICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiU0NSSVBUXCI6XG4gICAgICAgICAgY2FzZSBcIlNUWUxFXCI6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiTElOS1wiOlxuICAgICAgICAgICAgaWYgKFwic3R5bGVzaGVldFwiID09PSBub2RlLnJlbC50b0xvd2VyQ2FzZSgpKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGluUm9vdE9yU2luZ2xldG9uKSB7XG4gICAgICBmb3IgKDsgMSA9PT0gaW5zdGFuY2Uubm9kZVR5cGU7ICkge1xuICAgICAgICB2YXIgYW55UHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpblJvb3RPclNpbmdsZXRvbiAmJlxuICAgICAgICAgICAgKFwiSU5QVVRcIiAhPT0gaW5zdGFuY2Uubm9kZU5hbWUgfHwgXCJoaWRkZW5cIiAhPT0gaW5zdGFuY2UudHlwZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICghaW5Sb290T3JTaW5nbGV0b24pXG4gICAgICAgICAgaWYgKFwiaW5wdXRcIiA9PT0gdHlwZSAmJiBcImhpZGRlblwiID09PSBpbnN0YW5jZS50eXBlKSB7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGFueVByb3BzLm5hbWUsIFwibmFtZVwiKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbCA9PSBhbnlQcm9wcy5uYW1lID8gbnVsbCA6IFwiXCIgKyBhbnlQcm9wcy5uYW1lO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcImhpZGRlblwiID09PSBhbnlQcm9wcy50eXBlICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IG5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGVsc2UgaWYgKCFpbnN0YW5jZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0pXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInJlbFwiKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gYW55UHJvcHMucmVsIHx8XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSAhPT1cbiAgICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmhyZWYgPyBudWxsIDogYW55UHJvcHMuaHJlZikgfHxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSAhPT1cbiAgICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IGFueVByb3BzLmNyb3NzT3JpZ2luKSB8fFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpICE9PVxuICAgICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMudGl0bGUgPyBudWxsIDogYW55UHJvcHMudGl0bGUpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIikpIGJyZWFrO1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIG5hbWUgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobmFtZSAhPT0gKG51bGwgPT0gYW55UHJvcHMuc3JjID8gbnVsbCA6IGFueVByb3BzLnNyYykgfHxcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09XG4gICAgICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLnR5cGUgPyBudWxsIDogYW55UHJvcHMudHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpICE9PVxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgIDogYW55UHJvcHMuY3Jvc3NPcmlnaW4pKSAmJlxuICAgICAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJhc3luY1wiKSAmJlxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJpdGVtcHJvcFwiKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO1xuICAgICAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQsIGluUm9vdE9yU2luZ2xldG9uKSB7XG4gICAgICBpZiAoXCJcIiA9PT0gdGV4dCkgcmV0dXJuIG51bGw7XG4gICAgICBmb3IgKDsgMyAhPT0gaW5zdGFuY2Uubm9kZVR5cGU7ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDEgIT09IGluc3RhbmNlLm5vZGVUeXBlIHx8XG4gICAgICAgICAgICBcIklOUFVUXCIgIT09IGluc3RhbmNlLm5vZGVOYW1lIHx8XG4gICAgICAgICAgICBcImhpZGRlblwiICE9PSBpbnN0YW5jZS50eXBlKSAmJlxuICAgICAgICAgICFpblJvb3RPclNpbmdsZXRvblxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO1xuICAgICAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPSBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICBpZiAoMSA9PT0gbm9kZVR5cGUgfHwgMyA9PT0gbm9kZVR5cGUpIGJyZWFrO1xuICAgICAgICBpZiAoOCA9PT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICBub2RlVHlwZSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HIHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gRk9STV9TVEFURV9JU19OT1RfTUFUQ0hJTkdcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IFNVU1BFTlNFX0VORF9EQVRBKSByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MoaW5zdGFuY2UpIHtcbiAgICAgIGlmICgxID09PSBpbnN0YW5jZS5ub2RlVHlwZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXMgPSB7fSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBpbnN0YW5jZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgIGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNbZ2V0UHJvcE5hbWVGcm9tQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpXSA9XG4gICAgICAgICAgICBcInN0eWxlXCIgPT09IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgID8gZ2V0U3R5bGVzT2JqZWN0RnJvbUVsZW1lbnQoaW5zdGFuY2UpXG4gICAgICAgICAgICAgIDogYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiBKU0NvbXBpbGVyX3RlbXBfY29uc3QsIHByb3BzOiBzZXJ2ZXJEaWZmZXJlbmNlcyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDggPT09IGluc3RhbmNlLm5vZGVUeXBlXG4gICAgICAgID8geyB0eXBlOiBcIlN1c3BlbnNlXCIsIHByb3BzOiB7fSB9XG4gICAgICAgIDogaW5zdGFuY2Uubm9kZVZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3ModGV4dEluc3RhbmNlLCB0ZXh0LCBwYXJlbnRQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGwgPT09IHBhcmVudFByb3BzIHx8XG4gICAgICAgICEwICE9PSBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR11cbiAgICAgICAgPyAodGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9PT0gdGV4dFxuICAgICAgICAgICAgPyAodGV4dEluc3RhbmNlID0gbnVsbClcbiAgICAgICAgICAgIDogKCh0ZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHRleHQpKSxcbiAgICAgICAgICAgICAgKHRleHRJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHRleHRJbnN0YW5jZS5ub2RlVmFsdWUpID09PVxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlKSksXG4gICAgICAgICAgdGV4dEluc3RhbmNlKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IDA7IHN1c3BlbnNlSW5zdGFuY2U7ICkge1xuICAgICAgICBpZiAoOCA9PT0gc3VzcGVuc2VJbnN0YW5jZS5ub2RlVHlwZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gc3VzcGVuc2VJbnN0YW5jZS5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGRlcHRoKVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoc3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGRhdGEgIT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgJiZcbiAgICAgICAgICAgICAgZGF0YSAhPT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSAmJlxuICAgICAgICAgICAgICBkYXRhICE9PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHx8XG4gICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2UgPSB0YXJnZXRJbnN0YW5jZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IDA7IHRhcmdldEluc3RhbmNlOyApIHtcbiAgICAgICAgaWYgKDggPT09IHRhcmdldEluc3RhbmNlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0YXJnZXRJbnN0YW5jZS5kYXRhO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGRlcHRoKSByZXR1cm4gdGFyZ2V0SW5zdGFuY2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH0gZWxzZSBkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSAmJiBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldEluc3RhbmNlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgcmV0cnlJZkJsb2NrZWRPbihjb250YWluZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgICAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgaG9zdENvbnRleHQsXG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmdEZXZcbiAgICApIHtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZ0RldiAmJlxuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgaG9zdENvbnRleHQuYW5jZXN0b3JJbmZvKTtcbiAgICAgIHByb3BzID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICB0eXBlID0gcHJvcHMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIGFuIDxodG1sPiBlbGVtZW50IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHRvIGV4aXN0IGluIHRoZSBEb2N1bWVudCBidXQgb25lIHdhcyBub3QgZm91bmQuIFJlYWN0IG5ldmVyIHJlbW92ZXMgdGhlIGRvY3VtZW50RWxlbWVudCBmb3IgYW55IERvY3VtZW50IGl0IHJlbmRlcnMgaW50byBzbyB0aGUgY2F1c2UgaXMgbGlrZWx5IGluIHNvbWUgb3RoZXIgc2NyaXB0IHJ1bm5pbmcgb24gdGhpcyBwYWdlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIHR5cGUgPSBwcm9wcy5oZWFkO1xuICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIGEgPGhlYWQ+IGVsZW1lbnQgKGRvY3VtZW50LmhlYWQpIHRvIGV4aXN0IGluIHRoZSBEb2N1bWVudCBidXQgb25lIHdhcyBub3QgZm91bmQuIFJlYWN0IG5ldmVyIHJlbW92ZXMgdGhlIGhlYWQgZm9yIGFueSBEb2N1bWVudCBpdCByZW5kZXJzIGludG8gc28gdGhlIGNhdXNlIGlzIGxpa2VseSBpbiBzb21lIG90aGVyIHNjcmlwdCBydW5uaW5nIG9uIHRoaXMgcGFnZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICB0eXBlID0gcHJvcHMuYm9keTtcbiAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCBhIDxib2R5PiBlbGVtZW50IChkb2N1bWVudC5ib2R5KSB0byBleGlzdCBpbiB0aGUgRG9jdW1lbnQgYnV0IG9uZSB3YXMgbm90IGZvdW5kLiBSZWFjdCBuZXZlciByZW1vdmVzIHRoZSBib2R5IGZvciBhbnkgRG9jdW1lbnQgaXQgcmVuZGVycyBpbnRvIHNvIHRoZSBjYXVzZSBpcyBsaWtlbHkgaW4gc29tZSBvdGhlciBzY3JpcHQgcnVubmluZyBvbiB0aGlzIHBhZ2UuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSB3YXMgY2FsbGVkIHdpdGggYW4gZWxlbWVudCB0eXBlIHRoYXQgaXMgbm90IHN1cHBvcnRlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZVxuICAgICkge1xuICAgICAgaWYgKGdldEluc3RhbmNlRnJvbU5vZGUoaW5zdGFuY2UpKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gaW5zdGFuY2UudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IGFyZSBtb3VudGluZyBhIG5ldyAlcyBjb21wb25lbnQgd2hlbiBhIHByZXZpb3VzIG9uZSBoYXMgbm90IGZpcnN0IHVubW91bnRlZC4gSXQgaXMgYW4gZXJyb3IgdG8gcmVuZGVyIG1vcmUgdGhhbiBvbmUgJXMgY29tcG9uZW50IGF0IGEgdGltZSBhbmQgYXR0cmlidXRlcyBhbmQgY2hpbGRyZW4gb2YgdGhlc2UgY29tcG9uZW50cyB3aWxsIGxpa2VseSBmYWlsIGluIHVucHJlZGljdGFibGUgd2F5cy4gUGxlYXNlIG9ubHkgcmVuZGVyIGEgc2luZ2xlIGluc3RhbmNlIG9mIDwlcz4gYW5kIGlmIHlvdSBuZWVkIHRvIG1vdW50IGEgbmV3IG9uZSwgZW5zdXJlIGFueSBwcmV2aW91cyBvbmVzIGhhdmUgdW5tb3VudGVkIGZpcnN0LlwiLFxuICAgICAgICAgIHRhZ05hbWUsXG4gICAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2Ugd2FzIGNhbGxlZCB3aXRoIGFuIGVsZW1lbnQgdHlwZSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yICh0YWdOYW1lID0gaW5zdGFuY2UuYXR0cmlidXRlczsgdGFnTmFtZS5sZW5ndGg7IClcbiAgICAgICAgaW5zdGFuY2UucmVtb3ZlQXR0cmlidXRlTm9kZSh0YWdOYW1lWzBdKTtcbiAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICBpbnN0YW5jZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGludGVybmFsSW5zdGFuY2VIYW5kbGU7XG4gICAgICBpbnN0YW5jZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb2lzdGFibGVSb290KGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRhaW5lci5nZXRSb290Tm9kZVxuICAgICAgICA/IGNvbnRhaW5lci5nZXRSb290Tm9kZSgpXG4gICAgICAgIDogY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWNvbm5lY3RBcyhyZWwsIGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICB2YXIgbGltaXRlZEVzY2FwZWRIcmVmID1cbiAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpO1xuICAgICAgICBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgICAgICdsaW5rW3JlbD1cIicgKyByZWwgKyAnXCJdW2hyZWY9XCInICsgbGltaXRlZEVzY2FwZWRIcmVmICsgJ1wiXSc7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbiAmJlxuICAgICAgICAgIChsaW1pdGVkRXNjYXBlZEhyZWYgKz0gJ1tjcm9zc29yaWdpbj1cIicgKyBjcm9zc09yaWdpbiArICdcIl0nKTtcbiAgICAgICAgcHJlY29ubmVjdHNTZXQuaGFzKGxpbWl0ZWRFc2NhcGVkSHJlZikgfHxcbiAgICAgICAgICAocHJlY29ubmVjdHNTZXQuYWRkKGxpbWl0ZWRFc2NhcGVkSHJlZiksXG4gICAgICAgICAgKHJlbCA9IHsgcmVsOiByZWwsIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbiwgaHJlZjogaHJlZiB9KSxcbiAgICAgICAgICBudWxsID09PSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobGltaXRlZEVzY2FwZWRIcmVmKSAmJlxuICAgICAgICAgICAgKChocmVmID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhocmVmLCBcImxpbmtcIiwgcmVsKSxcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaHJlZiksXG4gICAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaHJlZikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVzb3VyY2UodHlwZSwgY3VycmVudFByb3BzLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgdmFyIHJlc291cmNlUm9vdCA9IChyZXNvdXJjZVJvb3QgPSByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KVxuICAgICAgICA/IGdldEhvaXN0YWJsZVJvb3QocmVzb3VyY2VSb290KVxuICAgICAgICA6IG51bGw7XG4gICAgICBpZiAoIXJlc291cmNlUm9vdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ1wicmVzb3VyY2VSb290XCIgd2FzIGV4cGVjdGVkIHRvIGV4aXN0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LidcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZSAmJlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5ocmVmXG4gICAgICAgICAgICA/ICgocGVuZGluZ1Byb3BzID0gZ2V0U3R5bGVLZXkocGVuZGluZ1Byb3BzLmhyZWYpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRQcm9wcyA9XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VzRnJvbVJvb3QocmVzb3VyY2VSb290KS5ob2lzdGFibGVTdHlsZXMpLFxuICAgICAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gY3VycmVudFByb3BzLmdldChwZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlIHx8XG4gICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcHMuc2V0KHBlbmRpbmdQcm9wcywgY3VycmVudFJlc291cmNlKSksXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgIDogeyB0eXBlOiBcInZvaWRcIiwgaW5zdGFuY2U6IG51bGwsIGNvdW50OiAwLCBzdGF0ZTogbnVsbCB9O1xuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSBwZW5kaW5nUHJvcHMucmVsICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWYgJiZcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHlwZSA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHZhciBfc3R5bGVzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3QocmVzb3VyY2VSb290KS5ob2lzdGFibGVTdHlsZXMsXG4gICAgICAgICAgICAgIF9yZXNvdXJjZSA9IF9zdHlsZXMuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhX3Jlc291cmNlICYmXG4gICAgICAgICAgICAgICgocmVzb3VyY2VSb290ID0gcmVzb3VyY2VSb290Lm93bmVyRG9jdW1lbnQgfHwgcmVzb3VyY2VSb290KSxcbiAgICAgICAgICAgICAgKF9yZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogeyBsb2FkaW5nOiBOb3RMb2FkZWQsIHByZWxvYWQ6IG51bGwgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgX3N0eWxlcy5zZXQodHlwZSwgX3Jlc291cmNlKSxcbiAgICAgICAgICAgICAgKF9zdHlsZXMgPSByZXNvdXJjZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KHR5cGUpXG4gICAgICAgICAgICAgICkpICYmXG4gICAgICAgICAgICAgICAgIV9zdHlsZXMuX3AgJiZcbiAgICAgICAgICAgICAgICAoKF9yZXNvdXJjZS5pbnN0YW5jZSA9IF9zdHlsZXMpLFxuICAgICAgICAgICAgICAgIChfcmVzb3VyY2Uuc3RhdGUubG9hZGluZyA9IExvYWRlZCB8IEluc2VydGVkKSksXG4gICAgICAgICAgICAgICFwcmVsb2FkUHJvcHNNYXAuaGFzKHR5cGUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgIGhyZWY6IHBlbmRpbmdQcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwZW5kaW5nUHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwZW5kaW5nUHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIG1lZGlhOiBwZW5kaW5nUHJvcHMubWVkaWEsXG4gICAgICAgICAgICAgICAgaHJlZkxhbmc6IHBlbmRpbmdQcm9wcy5ocmVmTGFuZyxcbiAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcGVuZGluZ1Byb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQodHlwZSwgcHJlbG9hZFByb3BzKTtcbiAgICAgICAgICAgICAgX3N0eWxlcyB8fFxuICAgICAgICAgICAgICAgIHByZWxvYWRTdHlsZXNoZWV0KFxuICAgICAgICAgICAgICAgICAgcmVzb3VyY2VSb290LFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIF9yZXNvdXJjZS5zdGF0ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFByb3BzICYmIG51bGwgPT09IGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICgocGVuZGluZ1Byb3BzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICAtIFwiICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYoY3VycmVudFByb3BzKSArXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgKyBcIiArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZUxpbmtGb3JSZXNvdXJjZUVycm9yREVWKHBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCA8bGluaz4gbm90IHRvIHVwZGF0ZSB0byBiZSB1cGRhdGVkIHRvIGEgc3R5bGVzaGVldCB3aXRoIHByZWNlZGVuY2UuIENoZWNrIHRoZSBgcmVsYCwgYGhyZWZgLCBhbmQgYHByZWNlZGVuY2VgIHByb3BzIG9mIHRoaXMgY29tcG9uZW50LiBBbHRlcm5hdGl2ZWx5LCBjaGVjayB3aGV0aGVyIHR3byBkaWZmZXJlbnQgPGxpbms+IGNvbXBvbmVudHMgcmVuZGVyIGluIHRoZSBzYW1lIHNsb3Qgb3Igc2hhcmUgdGhlIHNhbWUga2V5LlwiICtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBfcmVzb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50UHJvcHMgJiYgbnVsbCAhPT0gY3VycmVudFJlc291cmNlKVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG4gIC0gXCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYoY3VycmVudFByb3BzKSArXG4gICAgICAgICAgICAgICAgXCJcXG4gICsgXCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYocGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgc3R5bGVzaGVldCB3aXRoIHByZWNlZGVuY2UgdG8gbm90IGJlIHVwZGF0ZWQgdG8gYSBkaWZmZXJlbnQga2luZCBvZiA8bGluaz4uIENoZWNrIHRoZSBgcmVsYCwgYGhyZWZgLCBhbmQgYHByZWNlZGVuY2VgIHByb3BzIG9mIHRoaXMgY29tcG9uZW50LiBBbHRlcm5hdGl2ZWx5LCBjaGVjayB3aGV0aGVyIHR3byBkaWZmZXJlbnQgPGxpbms+IGNvbXBvbmVudHMgcmVuZGVyIGluIHRoZSBzYW1lIHNsb3Qgb3Igc2hhcmUgdGhlIHNhbWUga2V5LlwiICtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9wc1xuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudFByb3BzID0gcGVuZGluZ1Byb3BzLmFzeW5jKSxcbiAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMuc3JjKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMgJiZcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzXG4gICAgICAgICAgICAgID8gKChwZW5kaW5nUHJvcHMgPSBnZXRTY3JpcHRLZXkocGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcm9wcyA9XG4gICAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZXNGcm9tUm9vdChyZXNvdXJjZVJvb3QpLmhvaXN0YWJsZVNjcmlwdHMpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBjdXJyZW50UHJvcHMuZ2V0KHBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BzLnNldChwZW5kaW5nUHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgOiB7IHR5cGU6IFwidm9pZFwiLCBpbnN0YW5jZTogbnVsbCwgY291bnQ6IDAsIHN0YXRlOiBudWxsIH1cbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ2dldFJlc291cmNlIGVuY291bnRlcmVkIGEgdHlwZSBpdCBkaWQgbm90IGV4cGVjdDogXCInICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgICdcIi4gdGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVMaW5rRm9yUmVzb3VyY2VFcnJvckRFVihwcm9wcykge1xuICAgICAgdmFyIGRlc2NyaWJlZFByb3BzID0gMCxcbiAgICAgICAgZGVzY3JpcHRpb24gPSBcIjxsaW5rXCI7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMucmVsXG4gICAgICAgID8gKGRlc2NyaWJlZFByb3BzKyssIChkZXNjcmlwdGlvbiArPSAnIHJlbD1cIicgKyBwcm9wcy5yZWwgKyAnXCInKSlcbiAgICAgICAgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcInJlbFwiKSAmJlxuICAgICAgICAgIChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPVxuICAgICAgICAgICAgJyByZWw9XCInICtcbiAgICAgICAgICAgIChudWxsID09PSBwcm9wcy5yZWwgPyBcIm51bGxcIiA6IFwiaW52YWxpZCB0eXBlIFwiICsgdHlwZW9mIHByb3BzLnJlbCkgK1xuICAgICAgICAgICAgJ1wiJykpO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmhyZWZcbiAgICAgICAgPyAoZGVzY3JpYmVkUHJvcHMrKywgKGRlc2NyaXB0aW9uICs9ICcgaHJlZj1cIicgKyBwcm9wcy5ocmVmICsgJ1wiJykpXG4gICAgICAgIDogaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJocmVmXCIpICYmXG4gICAgICAgICAgKGRlc2NyaWJlZFByb3BzKyssXG4gICAgICAgICAgKGRlc2NyaXB0aW9uICs9XG4gICAgICAgICAgICAnIGhyZWY9XCInICtcbiAgICAgICAgICAgIChudWxsID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgICAgID8gXCJudWxsXCJcbiAgICAgICAgICAgICAgOiBcImludmFsaWQgdHlwZSBcIiArIHR5cGVvZiBwcm9wcy5ocmVmKSArXG4gICAgICAgICAgICAnXCInKSk7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZVxuICAgICAgICA/IChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPSAnIHByZWNlZGVuY2U9XCInICsgcHJvcHMucHJlY2VkZW5jZSArICdcIicpKVxuICAgICAgICA6IGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwicHJlY2VkZW5jZVwiKSAmJlxuICAgICAgICAgIChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPVxuICAgICAgICAgICAgXCIgcHJlY2VkZW5jZT17XCIgK1xuICAgICAgICAgICAgKG51bGwgPT09IHByb3BzLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgPyBcIm51bGxcIlxuICAgICAgICAgICAgICA6IFwiaW52YWxpZCB0eXBlIFwiICsgdHlwZW9mIHByb3BzLnByZWNlZGVuY2UpICtcbiAgICAgICAgICAgIFwifVwiKSk7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wcykubGVuZ3RoID4gZGVzY3JpYmVkUHJvcHMgJiZcbiAgICAgICAgKGRlc2NyaXB0aW9uICs9IFwiIC4uLlwiKTtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbiArIFwiIC8+XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0eWxlS2V5KGhyZWYpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdocmVmPVwiJyArIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgKyAnXCInXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSkge1xuICAgICAgcmV0dXJuICdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1bJyArIGtleSArIFwiXVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocmF3UHJvcHMpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkU3R5bGVzaGVldChvd25lckRvY3VtZW50LCBrZXksIHByZWxvYWRQcm9wcywgc3RhdGUpIHtcbiAgICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdWycgKyBrZXkgKyBcIl1cIlxuICAgICAgKVxuICAgICAgICA/IChzdGF0ZS5sb2FkaW5nID0gTG9hZGVkKVxuICAgICAgICA6ICgoa2V5ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAgICAgKHN0YXRlLnByZWxvYWQgPSBrZXkpLFxuICAgICAgICAgIGtleS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gTG9hZGVkKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBrZXkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3RhdGUubG9hZGluZyB8PSBFcnJvcmVkKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhrZXksIFwibGlua1wiLCBwcmVsb2FkUHJvcHMpLFxuICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoa2V5KSxcbiAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoa2V5KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjcmlwdEtleShzcmMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdbc3JjPVwiJyArIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoc3JjKSArICdcIl0nXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSB7XG4gICAgICByZXR1cm4gXCJzY3JpcHRbYXN5bmNdXCIgKyBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCByZXNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHJlc291cmNlLmNvdW50Kys7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpXG4gICAgICAgIHN3aXRjaCAocmVzb3VyY2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAnc3R5bGVbZGF0YS1ocmVmfj1cIicgK1xuICAgICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMocHJvcHMuaHJlZikgK1xuICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0eWxlUHJvcHMgPSBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIFwiZGF0YS1ocmVmXCI6IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSAoXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290XG4gICAgICAgICAgICApLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UsIFwic3R5bGVcIiwgc3R5bGVQcm9wcyk7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgIHJldHVybiAocmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZSk7XG4gICAgICAgICAgY2FzZSBcInN0eWxlc2hlZXRcIjpcbiAgICAgICAgICAgIHN0eWxlUHJvcHMgPSBnZXRTdHlsZUtleShwcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoc3R5bGVQcm9wcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IEluc2VydGVkKSxcbiAgICAgICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoX2luc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgICAgICAgIChzdHlsZVByb3BzID0gcHJlbG9hZFByb3BzTWFwLmdldChzdHlsZVByb3BzKSkgJiZcbiAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGluc3RhbmNlLCBzdHlsZVByb3BzKTtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IChcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICkuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKF9pbnN0YW5jZSk7XG4gICAgICAgICAgICB2YXIgbGlua0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgbGlua0luc3RhbmNlLl9wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBsaW5rSW5zdGFuY2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgbGlua0luc3RhbmNlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKF9pbnN0YW5jZSwgXCJsaW5rXCIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gSW5zZXJ0ZWQ7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KF9pbnN0YW5jZSwgcHJvcHMucHJlY2VkZW5jZSwgaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gKHJlc291cmNlLmluc3RhbmNlID0gX2luc3RhbmNlKTtcbiAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRTY3JpcHRLZXkocHJvcHMuc3JjKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KF9pbnN0YW5jZSlcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBzdHlsZVByb3BzKSxcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHN0eWxlUHJvcHMpLFxuICAgICAgICAgICAgICAgIHN0eWxlUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlID0gcHJvcHM7XG4gICAgICAgICAgICBpZiAoKHN0eWxlUHJvcHMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KF9pbnN0YW5jZSkpKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoaW5zdGFuY2UsIHN0eWxlUHJvcHMpO1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgICAgc3R5bGVQcm9wcyA9IGhvaXN0YWJsZVJvb3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoc3R5bGVQcm9wcyk7XG4gICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhzdHlsZVByb3BzLCBcImxpbmtcIiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IHN0eWxlUHJvcHMpO1xuICAgICAgICAgIGNhc2UgXCJ2b2lkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdhY3F1aXJlUmVzb3VyY2UgZW5jb3VudGVyZWQgYSByZXNvdXJjZSB0eXBlIGl0IGRpZCBub3QgZXhwZWN0OiBcIicgK1xuICAgICAgICAgICAgICAgIHJlc291cmNlLnR5cGUgK1xuICAgICAgICAgICAgICAgICdcIi4gdGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZXNvdXJjZS50eXBlICYmXG4gICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiBJbnNlcnRlZCkgPT09IE5vdExvYWRlZCAmJlxuICAgICAgICAgICgoaW5zdGFuY2UgPSByZXNvdXJjZS5pbnN0YW5jZSksXG4gICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gSW5zZXJ0ZWQpLFxuICAgICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByb3BzLnByZWNlZGVuY2UsIGhvaXN0YWJsZVJvb3QpKTtcbiAgICAgIHJldHVybiByZXNvdXJjZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3R5bGVzaGVldChpbnN0YW5jZSwgcHJlY2VkZW5jZSwgcm9vdCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV0nXG4gICAgICAgICAgKSxcbiAgICAgICAgICBsYXN0ID0gbm9kZXMubGVuZ3RoID8gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsLFxuICAgICAgICAgIHByaW9yID0gbGFzdCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlID09PSBwcmVjZWRlbmNlKSBwcmlvciA9IG5vZGU7XG4gICAgICAgIGVsc2UgaWYgKHByaW9yICE9PSBsYXN0KSBicmVhaztcbiAgICAgIH1cbiAgICAgIHByaW9yXG4gICAgICAgID8gcHJpb3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByaW9yLm5leHRTaWJsaW5nKVxuICAgICAgICA6ICgocHJlY2VkZW5jZSA9IDkgPT09IHJvb3Qubm9kZVR5cGUgPyByb290LmhlYWQgOiByb290KSxcbiAgICAgICAgICBwcmVjZWRlbmNlLmluc2VydEJlZm9yZShpbnN0YW5jZSwgcHJlY2VkZW5jZS5maXJzdENoaWxkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChzdHlsZXNoZWV0UHJvcHMsIHByZWxvYWRQcm9wcykge1xuICAgICAgbnVsbCA9PSBzdHlsZXNoZWV0UHJvcHMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgKHN0eWxlc2hlZXRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICBudWxsID09IHN0eWxlc2hlZXRQcm9wcy5yZWZlcnJlclBvbGljeSAmJlxuICAgICAgICAoc3R5bGVzaGVldFByb3BzLnJlZmVycmVyUG9saWN5ID0gcHJlbG9hZFByb3BzLnJlZmVycmVyUG9saWN5KTtcbiAgICAgIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnRpdGxlICYmXG4gICAgICAgIChzdHlsZXNoZWV0UHJvcHMudGl0bGUgPSBwcmVsb2FkUHJvcHMudGl0bGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdChzY3JpcHRQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgICAgIChzY3JpcHRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLnJlZmVycmVyUG9saWN5ICYmXG4gICAgICAgIChzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLmludGVncml0eSAmJlxuICAgICAgICAoc2NyaXB0UHJvcHMuaW50ZWdyaXR5ID0gcHJlbG9hZFByb3BzLmludGVncml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZSh0eXBlLCBrZXlBdHRyaWJ1dGUsIG93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSB0YWdDYWNoZXMpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY2FjaGVzID0gKHRhZ0NhY2hlcyA9IG5ldyBNYXAoKSk7XG4gICAgICAgIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIChjYWNoZXMgPSB0YWdDYWNoZXMpLFxuICAgICAgICAgIChjYWNoZSA9IGNhY2hlcy5nZXQob3duZXJEb2N1bWVudCkpLFxuICAgICAgICAgIGNhY2hlIHx8ICgoY2FjaGUgPSBuZXcgTWFwKCkpLCBjYWNoZXMuc2V0KG93bmVyRG9jdW1lbnQsIGNhY2hlKSk7XG4gICAgICBpZiAoY2FjaGUuaGFzKHR5cGUpKSByZXR1cm4gY2FjaGU7XG4gICAgICBjYWNoZS5zZXQodHlwZSwgbnVsbCk7XG4gICAgICBvd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKTtcbiAgICAgIGZvciAoY2FjaGVzID0gMDsgY2FjaGVzIDwgb3duZXJEb2N1bWVudC5sZW5ndGg7IGNhY2hlcysrKSB7XG4gICAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudFtjYWNoZXNdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgICAgICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICAoXCJsaW5rXCIgPT09IHR5cGUgJiYgXCJzdHlsZXNoZWV0XCIgPT09IG5vZGUuZ2V0QXR0cmlidXRlKFwicmVsXCIpKVxuICAgICAgICAgICkgJiZcbiAgICAgICAgICBub2RlLm5hbWVzcGFjZVVSSSAhPT0gU1ZHX05BTUVTUEFDRVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbm9kZUtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKGtleUF0dHJpYnV0ZSkgfHwgXCJcIjtcbiAgICAgICAgICBub2RlS2V5ID0gdHlwZSArIG5vZGVLZXk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gY2FjaGUuZ2V0KG5vZGVLZXkpO1xuICAgICAgICAgIGV4aXN0aW5nID8gZXhpc3RpbmcucHVzaChub2RlKSA6IGNhY2hlLnNldChub2RlS2V5LCBbbm9kZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIHR5cGUsIGluc3RhbmNlKSB7XG4gICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICBob2lzdGFibGVSb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgXCJ0aXRsZVwiID09PSB0eXBlID8gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFwiaGVhZCA+IHRpdGxlXCIpIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwcm9wcywgaG9zdENvbnRleHQpIHtcbiAgICAgIHZhciBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgPVxuICAgICAgICAhaG9zdENvbnRleHQuYW5jZXN0b3JJbmZvLmNvbnRhaW5lclRhZ0luU2NvcGU7XG4gICAgICBpZiAoXG4gICAgICAgIGhvc3RDb250ZXh0LmNvbnRleHQgPT09IEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnIHx8XG4gICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3BcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhb3V0c2lkZUhvc3RDb250YWluZXJDb250ZXh0IHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICAoXCJtZXRhXCIgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgXCJ0aXRsZVwiICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgIFwic3R5bGVcIiAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICBcImxpbmtcIiAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICBcInNjcmlwdFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJDYW5ub3QgcmVuZGVyIGEgPCVzPiBvdXRzaWRlIHRoZSBtYWluIGRvY3VtZW50IGlmIGl0IGhhcyBhbiBgaXRlbVByb3BgIHByb3AuIGBpdGVtUHJvcGAgc3VnZ2VzdHMgdGhlIHRhZyBiZWxvbmdzIHRvIGFuIGBpdGVtU2NvcGVgIHdoaWNoIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIERPTS4gSWYgeW91IHdlcmUgaW50ZW5kaW5nIGZvciBSZWFjdCB0byBob2lzdCB0aGlzIDwlcz4gcmVtb3ZlIHRoZSBgaXRlbVByb3BgIHByb3AuIE90aGVyd2lzZSwgdHJ5IG1vdmluZyB0aGlzIHRhZyBpbnRvIHRoZSA8aGVhZD4gb3IgPGJvZHk+IG9mIHRoZSBEb2N1bWVudC5cIixcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5ocmVmIHx8XG4gICAgICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IHJlbmRlciBhIDxzdHlsZT4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGtub3dpbmcgaXRzIHByZWNlZGVuY2UgYW5kIGEgdW5pcXVlIGhyZWYga2V5LiBSZWFjdCBjYW4gaG9pc3QgYW5kIGRlZHVwbGljYXRlIDxzdHlsZT4gdGFncyBpZiB5b3UgcHJvdmlkZSBhIGBwcmVjZWRlbmNlYCBwcm9wIGFsb25nIHdpdGggYW4gYGhyZWZgIHByb3AgdGhhdCBkb2VzIG5vdCBjb25mbGljIHdpdGggdGhlIGBocmVmYCB2YWx1ZXMgdXNlZCBpbiBhbnkgb3RoZXIgaG9pc3RlZCA8c3R5bGU+IG9yIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4+IHRhZ3MuICBOb3RlIHRoYXQgaG9pc3RpbmcgPHN0eWxlPiB0YWdzIGlzIGNvbnNpZGVyZWQgYW4gYWR2YW5jZWQgZmVhdHVyZSB0aGF0IG1vc3Qgd2lsbCBub3QgdXNlIGRpcmVjdGx5LiBDb25zaWRlciBtb3ZpbmcgdGhlIDxzdHlsZT4gdGFnIHRvIHRoZSA8aGVhZD4gb3IgY29uc2lkZXIgYWRkaW5nIGEgYHByZWNlZGVuY2U9XCJkZWZhdWx0XCJgIGFuZCBgaHJlZj1cInNvbWUgdW5pcXVlIHJlc291cmNlIGlkZW50aWZpZXJcImAsIG9yIG1vdmUgdGhlIDxzdHlsZT4gdG8gdGhlIDxzdHlsZT4gdGFnLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLmhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IHByb3BzLmhyZWYgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5wcmVjZWRlbmNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3BzLmhyZWY7XG4gICAgICAgICAgICAgIHZhciBvbkVycm9yID0gcHJvcHMub25FcnJvcixcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgICAgICAgICAgICBob3N0Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgaG9zdENvbnRleHQucHVzaChcImBvbkxvYWRgXCIpO1xuICAgICAgICAgICAgICBvbkVycm9yICYmIGhvc3RDb250ZXh0LnB1c2goXCJgb25FcnJvcmBcIik7XG4gICAgICAgICAgICAgIG51bGwgIT0gZGlzYWJsZWQgJiYgaG9zdENvbnRleHQucHVzaChcImBkaXNhYmxlZGBcIik7XG4gICAgICAgICAgICAgIG9uRXJyb3IgPSBwcm9wTmFtZXNMaXN0Sm9pbihob3N0Q29udGV4dCwgXCJhbmRcIik7XG4gICAgICAgICAgICAgIG9uRXJyb3IgKz0gMSA9PT0gaG9zdENvbnRleHQubGVuZ3RoID8gXCIgcHJvcFwiIDogXCIgcHJvcHNcIjtcbiAgICAgICAgICAgICAgZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgIDEgPT09IGhvc3RDb250ZXh0Lmxlbmd0aCA/IFwiYW4gXCIgKyBvbkVycm9yIDogXCJ0aGUgXCIgKyBvbkVycm9yO1xuICAgICAgICAgICAgICBob3N0Q29udGV4dC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCIlc1wiIC4uLiAvPiB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgdGhhdCBhbHNvIGluY2x1ZGVkICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICBvbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHNpZGVIb3N0Q29udGFpbmVyQ29udGV4dCAmJlxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnJlbCB8fFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuaHJlZiB8fFxuICAgICAgICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCByZW5kZXIgYSA8bGluaz4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGEgYHJlbGAgYW5kIGBocmVmYCBwcm9wLiBUcnkgYWRkaW5nIGEgYHJlbGAgYW5kL29yIGBocmVmYCBwcm9wIHRvIHRoaXMgPGxpbms+IG9yIG1vdmluZyB0aGUgbGluayBpbnRvIHRoZSA8aGVhZD4gdGFnXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChwcm9wcy5vbkVycm9yIHx8IHByb3BzLm9uTG9hZCkgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciBhIDxsaW5rPiB3aXRoIG9uTG9hZCBvciBvbkVycm9yIGxpc3RlbmVycyBvdXRzaWRlIHRoZSBtYWluIGRvY3VtZW50LiBUcnkgcmVtb3Zpbmcgb25Mb2FkPXsuLi59IGFuZCBvbkVycm9yPXsuLi59IG9yIG1vdmluZyBpdCBpbnRvIHRoZSByb290IDxoZWFkPiB0YWcgb3Igc29tZXdoZXJlIGluIHRoZSA8Ym9keT4uXCJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAocHJvcHMucmVsKSB7XG4gICAgICAgICAgICBjYXNlIFwic3R5bGVzaGVldFwiOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICh0eXBlID0gcHJvcHMucHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgKHByb3BzID0gcHJvcHMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgcmVuZGVyIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC8+IG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQgd2l0aG91dCBrbm93aW5nIGl0cyBwcmVjZWRlbmNlLiBDb25zaWRlciBhZGRpbmcgcHJlY2VkZW5jZT1cImRlZmF1bHRcIiBvciBtb3ZpbmcgaXQgaW50byB0aGUgcm9vdCA8aGVhZD4gdGFnLidcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCA9PSBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIHR5cGUgPVxuICAgICAgICAgICAgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzLmFzeW5jICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMuYXN5bmM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXR5cGUgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvciB8fFxuICAgICAgICAgICAgIXByb3BzLnNyYyB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyY1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgb3V0c2lkZUhvc3RDb250YWluZXJDb250ZXh0ICYmXG4gICAgICAgICAgICAgICh0eXBlXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciBhIDxzY3JpcHQ+IHdpdGggb25Mb2FkIG9yIG9uRXJyb3IgbGlzdGVuZXJzIG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQuIFRyeSByZW1vdmluZyBvbkxvYWQ9ey4uLn0gYW5kIG9uRXJyb3I9ey4uLn0gb3IgbW92aW5nIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZyBvciBzb21ld2hlcmUgaW4gdGhlIDxib2R5Pi5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgcmVuZGVyIGEgPHNjcmlwdD4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGBhc3luYz17dHJ1ZX1gIGFuZCBhIG5vbi1lbXB0eSBgc3JjYCBwcm9wLiBFbnN1cmUgdGhlcmUgaXMgYSB2YWxpZCBgc3JjYCBhbmQgZWl0aGVyIG1ha2UgdGhlIHNjcmlwdCBhc3luYyBvciBtb3ZlIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZyBvciBzb21ld2hlcmUgaW4gdGhlIDxib2R5Pi5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHJlbmRlciBhIHN5bmMgb3IgZGVmZXIgPHNjcmlwdD4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGtub3dpbmcgaXRzIG9yZGVyLiBUcnkgYWRkaW5nIGFzeW5jPVwiXCIgb3IgbW92aW5nIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZy4nXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciA8JXM+IG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQuIFRyeSBtb3ZpbmcgaXQgaW50byB0aGUgcm9vdCA8aGVhZD4gdGFnLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgICAgICAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIFNldHRsZWQpID09PSBOb3RMb2FkZWRcbiAgICAgICAgPyAhMVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBzdXNwZW5kUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgcmVzb3VyY2UsIHByb3BzKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkU3RhdGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgRXJyb3I6IHN1c3BlbmRlZFN0YXRlIG51bGwgd2hlbiBpdCB3YXMgZXhwZWN0ZWQgdG8gZXhpc3RzLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBSZWFjdCBidWcuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBzdGF0ZSA9IHN1c3BlbmRlZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLm1lZGlhIHx8XG4gICAgICAgICAgITEgIT09IG1hdGNoTWVkaWEocHJvcHMubWVkaWEpLm1hdGNoZXMpICYmXG4gICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgSW5zZXJ0ZWQpID09PSBOb3RMb2FkZWRcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0U3R5bGVLZXkocHJvcHMuaHJlZiksXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleShrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGluc3RhbmNlLl9wO1xuICAgICAgICAgICAgbnVsbCAhPT0gaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBob2lzdGFibGVSb290LnRoZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmNvdW50KyssXG4gICAgICAgICAgICAgIChzdGF0ZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC50aGVuKHN0YXRlLCBzdGF0ZSkpO1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSBJbnNlcnRlZDtcbiAgICAgICAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBwcm9wcyA9IHN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgKGtleSA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChwcm9wcywga2V5KTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhciBsaW5rSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICBsaW5rSW5zdGFuY2UuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBsaW5rSW5zdGFuY2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGluc3RhbmNlLCBcImxpbmtcIiwgcHJvcHMpO1xuICAgICAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PT0gc3RhdGUuc3R5bGVzaGVldHMgJiYgKHN0YXRlLnN0eWxlc2hlZXRzID0gbmV3IE1hcCgpKTtcbiAgICAgICAgc3RhdGUuc3R5bGVzaGVldHMuc2V0KHJlc291cmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgKGhvaXN0YWJsZVJvb3QgPSByZXNvdXJjZS5zdGF0ZS5wcmVsb2FkKSAmJlxuICAgICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgU2V0dGxlZCkgPT09IE5vdExvYWRlZCAmJlxuICAgICAgICAgIChzdGF0ZS5jb3VudCsrLFxuICAgICAgICAgIChyZXNvdXJjZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgICAgICBob2lzdGFibGVSb290LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc291cmNlKSxcbiAgICAgICAgICBob2lzdGFibGVSb290LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZXNvdXJjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFN0YXRlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IEVycm9yOiBzdXNwZW5kZWRTdGF0ZSBudWxsIHdoZW4gaXQgd2FzIGV4cGVjdGVkIHRvIGV4aXN0cy4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgUmVhY3QgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgc3RhdGUgPSBzdXNwZW5kZWRTdGF0ZTtcbiAgICAgIHN0YXRlLnN0eWxlc2hlZXRzICYmXG4gICAgICAgIDAgPT09IHN0YXRlLmNvdW50ICYmXG4gICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gICAgICByZXR1cm4gMCA8IHN0YXRlLmNvdW50XG4gICAgICAgID8gZnVuY3Rpb24gKGNvbW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzdGF0ZS5zdHlsZXNoZWV0cyAmJlxuICAgICAgICAgICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS51bnN1c3BlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5zdXNwZW5kID0gc3RhdGUudW5zdXNwZW5kO1xuICAgICAgICAgICAgICAgIHN0YXRlLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDZlNCk7XG4gICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBjb21taXQ7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBudWxsO1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3R5bGVzaGVldFRpbWVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVW5zdXNwZW5kKCkge1xuICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgaWYgKDAgPT09IHRoaXMuY291bnQpXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc2hlZXRzKVxuICAgICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHRoaXMsIHRoaXMuc3R5bGVzaGVldHMpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnVuc3VzcGVuZCkge1xuICAgICAgICAgIHZhciB1bnN1c3BlbmQgPSB0aGlzLnVuc3VzcGVuZDtcbiAgICAgICAgICB0aGlzLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHMoc3RhdGUsIHJlc291cmNlcykge1xuICAgICAgc3RhdGUuc3R5bGVzaGVldHMgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gc3RhdGUudW5zdXNwZW5kICYmXG4gICAgICAgIChzdGF0ZS5jb3VudCsrLFxuICAgICAgICAocHJlY2VkZW5jZXNCeVJvb3QgPSBuZXcgTWFwKCkpLFxuICAgICAgICByZXNvdXJjZXMuZm9yRWFjaChpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3QsIHN0YXRlKSxcbiAgICAgICAgKHByZWNlZGVuY2VzQnlSb290ID0gbnVsbCksXG4gICAgICAgIG9uVW5zdXNwZW5kLmNhbGwoc3RhdGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3R5bGVzaGVldEludG9Sb290KHJvb3QsIHJlc291cmNlKSB7XG4gICAgICBpZiAoIShyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgSW5zZXJ0ZWQpKSB7XG4gICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IHByZWNlZGVuY2VzQnlSb290LmdldChyb290KTtcbiAgICAgICAgaWYgKHByZWNlZGVuY2VzKSB2YXIgbGFzdCA9IHByZWNlZGVuY2VzLmdldChMQVNUX1BSRUNFREVOQ0UpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwcmVjZWRlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBwcmVjZWRlbmNlc0J5Um9vdC5zZXQocm9vdCwgcHJlY2VkZW5jZXMpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJMSU5LXCIgPT09IG5vZGUubm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgXCJub3QgYWxsXCIgIT09IG5vZGUuZ2V0QXR0cmlidXRlKFwibWVkaWFcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZXMuc2V0KG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlLCBub2RlKSwgKGxhc3QgPSBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdCAmJiBwcmVjZWRlbmNlcy5zZXQoTEFTVF9QUkVDRURFTkNFLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlcyA9IHJlc291cmNlLmluc3RhbmNlO1xuICAgICAgICBub2RlID0gbm9kZXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO1xuICAgICAgICBpID0gcHJlY2VkZW5jZXMuZ2V0KG5vZGUpIHx8IGxhc3Q7XG4gICAgICAgIGkgPT09IGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KExBU1RfUFJFQ0VERU5DRSwgbm9kZXMpO1xuICAgICAgICBwcmVjZWRlbmNlcy5zZXQobm9kZSwgbm9kZXMpO1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIGxhc3QgPSBvblVuc3VzcGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsYXN0KTtcbiAgICAgICAgbm9kZXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGxhc3QpO1xuICAgICAgICBpXG4gICAgICAgICAgPyBpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzLCBpLm5leHRTaWJsaW5nKVxuICAgICAgICAgIDogKChyb290ID0gOSA9PT0gcm9vdC5ub2RlVHlwZSA/IHJvb3QuaGVhZCA6IHJvb3QpLFxuICAgICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUobm9kZXMsIHJvb3QuZmlyc3RDaGlsZCkpO1xuICAgICAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IEluc2VydGVkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiaW5kVG9Db25zb2xlKG1ldGhvZE5hbWUsIGFyZ3MsIGJhZGdlTmFtZSkge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwiZGlyeG1sXCI6XG4gICAgICAgIGNhc2UgXCJncm91cEVuZFwiOlxuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICByZXR1cm4gYmluZC5hcHBseShjb25zb2xlW21ldGhvZE5hbWVdLCBbY29uc29sZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgY2FzZSBcImFzc2VydFwiOlxuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICB9XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBhcmdzW29mZnNldF1cbiAgICAgICAgPyBhcmdzLnNwbGljZShcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBiYWRnZUZvcm1hdCArIGFyZ3Nbb2Zmc2V0XSxcbiAgICAgICAgICAgIGJhZGdlU3R5bGUsXG4gICAgICAgICAgICBwYWQgKyBiYWRnZU5hbWUgKyBwYWQsXG4gICAgICAgICAgICByZXNldFN0eWxlXG4gICAgICAgICAgKVxuICAgICAgICA6IGFyZ3Muc3BsaWNlKFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGJhZGdlRm9ybWF0LFxuICAgICAgICAgICAgYmFkZ2VTdHlsZSxcbiAgICAgICAgICAgIHBhZCArIGJhZGdlTmFtZSArIHBhZCxcbiAgICAgICAgICAgIHJlc2V0U3R5bGVcbiAgICAgICAgICApO1xuICAgICAgYXJncy51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgcmV0dXJuIGJpbmQuYXBwbHkoY29uc29sZVttZXRob2ROYW1lXSwgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnRhZyA9IDE7XG4gICAgICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICAgICAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgICAgICB0aGlzLnBpbmdDYWNoZSA9XG4gICAgICAgIHRoaXMuY3VycmVudCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgICAgICB0aGlzLm5leHQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICAgICAgdGhpcy5jb250ZXh0ID1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcCgtMSk7XG4gICAgICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICAgICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICAgICAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICAgICAgdGhpcy53YXJtTGFuZXMgPVxuICAgICAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICAgICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgICAgIHRoaXMucGVuZGluZ0xhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgICAgIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IDA7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSB0aGlzLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBjb250YWluZXJJbmZvID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG4gICAgICBmb3IgKHRhZyA9IDA7IDMxID4gdGFnOyB0YWcrKykgY29udGFpbmVySW5mby5wdXNoKG5ldyBTZXQoKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/IFwiaHlkcmF0ZVJvb3QoKVwiIDogXCJjcmVhdGVSb290KClcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgdGFnID0gQ29uY3VycmVudE1vZGU7XG4gICAgICAhMCA9PT0gaXNTdHJpY3RNb2RlICYmICh0YWcgfD0gU3RyaWN0TGVnYWN5TW9kZSB8IFN0cmljdEVmZmVjdHNNb2RlKTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmICh0YWcgfD0gUHJvZmlsZU1vZGUpO1xuICAgICAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXIoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8uY3VycmVudCA9IGlzU3RyaWN0TW9kZTtcbiAgICAgIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICAgICAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLnBvb2xlZENhY2hlID0gdGFnO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgICAgY2FjaGU6IHRhZ1xuICAgICAgfTtcbiAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZShpc1N0cmljdE1vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJTeW5jKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICAwID09PSBjb250YWluZXIudGFnICYmIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICAgIGNvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICAyLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgIHJvb3RGaWJlcixcbiAgICAgIGxhbmUsXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290XG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCwgY29udGFpbmVyLCBlbGVtZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICAgICAgcGFyZW50Q29tcG9uZW50ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIG51bGwgPT09IGNvbnRhaW5lci5jb250ZXh0XG4gICAgICAgID8gKGNvbnRhaW5lci5jb250ZXh0ID0gcGFyZW50Q29tcG9uZW50KVxuICAgICAgICA6IChjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgaXNSZW5kZXJpbmcgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyAmJlxuICAgICAgICAoKGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuXCIsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50KSB8fCBcIlVua25vd25cIlxuICAgICAgICApKTtcbiAgICAgIGNvbnRhaW5lciA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGNvbnRhaW5lci5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCA9PT0gY2FsbGJhY2sgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2sgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApLFxuICAgICAgICAoY29udGFpbmVyLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgIGVsZW1lbnQgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgY29udGFpbmVyLCBsYW5lKTtcbiAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihlbGVtZW50LCByb290RmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgbnVsbCAhPT0gZmliZXIuZGVoeWRyYXRlZCkge1xuICAgICAgICB2YXIgYSA9IGZpYmVyLnJldHJ5TGFuZTtcbiAgICAgICAgZmliZXIucmV0cnlMYW5lID0gMCAhPT0gYSAmJiBhIDwgcmV0cnlMYW5lID8gYSA6IHJldHJ5TGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICAoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpICYmIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCkge1xuICAgICAgZm9yICh2YXIgbWFwID0gbmV3IE1hcCgpLCBsYW5lID0gMSwgaW5kZXggPSAwOyAzMSA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGdldExhYmVsRm9yTGFuZShsYW5lKTtcbiAgICAgICAgbWFwLnNldChsYW5lLCBsYWJlbCk7XG4gICAgICAgIGxhbmUgKj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICBjb250YWluZXIsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpLFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQ29udGludW91c0V2ZW50KFxuICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5KSxcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KFxuICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKSB7XG4gICAgICBpZiAoX2VuYWJsZWQpIHtcbiAgICAgICAgdmFyIGJsb2NrZWRPbiA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgICAgICBpZiAobnVsbCA9PT0gYmxvY2tlZE9uKVxuICAgICAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIHJldHVybl90YXJnZXRJbnN0LFxuICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoXG4gICAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICBuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCksXG4gICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyAmIDQgJiZcbiAgICAgICAgICAgIC0xIDwgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzLmluZGV4T2YoZG9tRXZlbnROYW1lKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICg7IG51bGwgIT09IGJsb2NrZWRPbjsgKSB7XG4gICAgICAgICAgICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgZmliZXIgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBpZiAoZmliZXIuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChyb290LmVudGFuZ2xlZExhbmVzIHw9IDI7IGxhbmVzOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gMSA8PCAoMzEgLSBjbHozMihsYW5lcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIChyb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hTeW5jV29yayQxKCksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCAyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmliZXIgPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByZXR1cm5fdGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChmaWJlciA9PT0gYmxvY2tlZE9uKSBicmVhaztcbiAgICAgICAgICAgIGJsb2NrZWRPbiA9IGZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBibG9ja2VkT24gJiYgbmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gICAgICBuYXRpdmVFdmVudCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybiBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChuYXRpdmVFdmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nVGFyZ2V0KHRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybl90YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIHRhcmdldE5vZGUgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKTtcbiAgICAgIGlmIChudWxsICE9PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIodGFyZ2V0Tm9kZSk7XG4gICAgICAgIGlmIChudWxsID09PSBuZWFyZXN0TW91bnRlZCkgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG4gICAgICAgICAgaWYgKDEzID09PSB0YWcpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB0YXJnZXROb2RlKSByZXR1cm4gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gdGFnKSB7XG4gICAgICAgICAgICBpZiAobmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiAzID09PSBuZWFyZXN0TW91bnRlZC50YWdcbiAgICAgICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXROb2RlICYmICh0YXJnZXROb2RlID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybl90YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkge1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgICAgICBjYXNlIFwiY2FuY2VsXCI6XG4gICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICAgIGNhc2UgXCJjb3B5XCI6XG4gICAgICAgIGNhc2UgXCJjdXRcIjpcbiAgICAgICAgY2FzZSBcImF1eGNsaWNrXCI6XG4gICAgICAgIGNhc2UgXCJkYmxjbGlja1wiOlxuICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJkcm9wXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgY2FzZSBcImludmFsaWRcIjpcbiAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgICAgICBjYXNlIFwicGF1c2VcIjpcbiAgICAgICAgY2FzZSBcInBsYXlcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJjYW5jZWxcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJkb3duXCI6XG4gICAgICAgIGNhc2UgXCJwb2ludGVydXBcIjpcbiAgICAgICAgY2FzZSBcInJhdGVjaGFuZ2VcIjpcbiAgICAgICAgY2FzZSBcInJlc2V0XCI6XG4gICAgICAgIGNhc2UgXCJyZXNpemVcIjpcbiAgICAgICAgY2FzZSBcInNlZWtlZFwiOlxuICAgICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICAgIGNhc2UgXCJ0b2dnbGVcIjpcbiAgICAgICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICBjYXNlIFwidm9sdW1lY2hhbmdlXCI6XG4gICAgICAgIGNhc2UgXCJjaGFuZ2VcIjpcbiAgICAgICAgY2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOlxuICAgICAgICBjYXNlIFwidGV4dElucHV0XCI6XG4gICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICAgICAgY2FzZSBcImJlZm9yZWJsdXJcIjpcbiAgICAgICAgY2FzZSBcImFmdGVyYmx1clwiOlxuICAgICAgICBjYXNlIFwiYmVmb3JlaW5wdXRcIjpcbiAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgY2FzZSBcImZ1bGxzY3JlZW5jaGFuZ2VcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICAgIGNhc2UgXCJoYXNoY2hhbmdlXCI6XG4gICAgICAgIGNhc2UgXCJwb3BzdGF0ZVwiOlxuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGNhc2UgXCJzZWxlY3RzdGFydFwiOlxuICAgICAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgICAgIGNhc2UgXCJkcmFnXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcImRyYWdleGl0XCI6XG4gICAgICAgIGNhc2UgXCJkcmFnbGVhdmVcIjpcbiAgICAgICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJtb3ZlXCI6XG4gICAgICAgIGNhc2UgXCJwb2ludGVyb3V0XCI6XG4gICAgICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgY2FzZSBcIndoZWVsXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZWVudGVyXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZWxlYXZlXCI6XG4gICAgICAgIGNhc2UgXCJwb2ludGVyZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJsZWF2ZVwiOlxuICAgICAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICBzd2l0Y2ggKGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkpIHtcbiAgICAgICAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgICAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICAgICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5JDE6XG4gICAgICAgICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICAgICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgICAgICAgcmV0dXJuIElkbGVFdmVudFByaW9yaXR5O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnbGVhdmVcIjpcbiAgICAgICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgICAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxuICAgICAgICAgIHF1ZXVlZFBvaW50ZXJzLmRlbGV0ZShuYXRpdmVFdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5kZWxldGUobmF0aXZlRXZlbnQucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgIGV4aXN0aW5nUXVldWVkRXZlbnQsXG4gICAgICBibG9ja2VkT24sXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCA9PT0gZXhpc3RpbmdRdWV1ZWRFdmVudCB8fFxuICAgICAgICBleGlzdGluZ1F1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50ICE9PSBuYXRpdmVFdmVudFxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChleGlzdGluZ1F1ZXVlZEV2ZW50ID0ge1xuICAgICAgICAgICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgICAgICAgICBkb21FdmVudE5hbWU6IGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3M6IGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXJzOiBbdGFyZ2V0Q29udGFpbmVyXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG51bGwgIT09IGJsb2NrZWRPbiAmJlxuICAgICAgICAgICAgKChibG9ja2VkT24gPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbikpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGJsb2NrZWRPbikpLFxuICAgICAgICAgIGV4aXN0aW5nUXVldWVkRXZlbnRcbiAgICAgICAgKTtcbiAgICAgIGV4aXN0aW5nUXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncyB8PSBldmVudFN5c3RlbUZsYWdzO1xuICAgICAgYmxvY2tlZE9uID0gZXhpc3RpbmdRdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuICAgICAgbnVsbCAhPT0gdGFyZ2V0Q29udGFpbmVyICYmXG4gICAgICAgIC0xID09PSBibG9ja2VkT24uaW5kZXhPZih0YXJnZXRDb250YWluZXIpICYmXG4gICAgICAgIGJsb2NrZWRPbi5wdXNoKHRhcmdldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gZXhpc3RpbmdRdWV1ZWRFdmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVJZkNvbnRpbnVvdXNFdmVudChcbiAgICAgIGJsb2NrZWRPbixcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICkge1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHF1ZXVlZEZvY3VzID0gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICAgICAgcXVldWVkRm9jdXMsXG4gICAgICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImRyYWdlbnRlclwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocXVldWVkRHJhZyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgICAgIHF1ZXVlZERyYWcsXG4gICAgICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgICAgICBxdWV1ZWRNb3VzZSxcbiAgICAgICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICAgICAgICB2YXIgcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChcbiAgICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICAgIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgICAgIHF1ZXVlZFBvaW50ZXJzLmdldChwb2ludGVySWQpIHx8IG51bGwsXG4gICAgICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkKSxcbiAgICAgICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5zZXQoXG4gICAgICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpIHtcbiAgICAgIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocXVldWVkVGFyZ2V0LnRhcmdldCk7XG4gICAgICBpZiAobnVsbCAhPT0gdGFyZ2V0SW5zdCkge1xuICAgICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmVhcmVzdE1vdW50ZWQpXG4gICAgICAgICAgaWYgKCgodGFyZ2V0SW5zdCA9IG5lYXJlc3RNb3VudGVkLnRhZyksIDEzID09PSB0YXJnZXRJbnN0KSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHRhcmdldEluc3QgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IHRhcmdldEluc3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgICAgIHJ1bldpdGhQcmlvcml0eShxdWV1ZWRUYXJnZXQucHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoMTMgPT09IG5lYXJlc3RNb3VudGVkLnRhZykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShuZWFyZXN0TW91bnRlZCksXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUobmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgbmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQobmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgMyA9PT0gdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPVxuICAgICAgICAgICAgICAzID09PSBuZWFyZXN0TW91bnRlZC50YWdcbiAgICAgICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSB7XG4gICAgICBpZiAobnVsbCAhPT0gcXVldWVkRXZlbnQuYmxvY2tlZE9uKSByZXR1cm4gITE7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IHF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gICAgICAgIDAgPCB0YXJnZXRDb250YWluZXJzLmxlbmd0aDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChudWxsID09PSBuZXh0QmxvY2tlZE9uKSB7XG4gICAgICAgICAgbmV4dEJsb2NrZWRPbiA9IHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgICAgIHZhciBuYXRpdmVFdmVudENsb25lID0gbmV3IG5leHRCbG9ja2VkT24uY29uc3RydWN0b3IoXG4gICAgICAgICAgICAgIG5leHRCbG9ja2VkT24udHlwZSxcbiAgICAgICAgICAgICAgbmV4dEJsb2NrZWRPblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV2ZW50ID0gbmF0aXZlRXZlbnRDbG9uZTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50UmVwbGF5aW5nRXZlbnQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9IGV2ZW50O1xuICAgICAgICAgIG5leHRCbG9ja2VkT24udGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudFJlcGxheWluZ0V2ZW50ICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIGN1cnJlbnRseSByZXBsYXlpbmcgZXZlbnQgdG8gbm90IGJlIG51bGwuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0YXJnZXRDb250YWluZXJzID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKSksXG4gICAgICAgICAgICBudWxsICE9PSB0YXJnZXRDb250YWluZXJzICYmXG4gICAgICAgICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKHRhcmdldENvbnRhaW5lcnMpLFxuICAgICAgICAgICAgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT24pLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcChxdWV1ZWRFdmVudCwga2V5LCBtYXApIHtcbiAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpICYmIG1hcC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICAgICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExO1xuICAgICAgbnVsbCAhPT0gcXVldWVkRm9jdXMgJiZcbiAgICAgICAgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykgJiZcbiAgICAgICAgKHF1ZXVlZEZvY3VzID0gbnVsbCk7XG4gICAgICBudWxsICE9PSBxdWV1ZWREcmFnICYmXG4gICAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRHJhZykgJiZcbiAgICAgICAgKHF1ZXVlZERyYWcgPSBudWxsKTtcbiAgICAgIG51bGwgIT09IHF1ZXVlZE1vdXNlICYmXG4gICAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkTW91c2UpICYmXG4gICAgICAgIChxdWV1ZWRNb3VzZSA9IG51bGwpO1xuICAgICAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xuICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpIHtcbiAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkICYmXG4gICAgICAgICgocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbCksXG4gICAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgfHxcbiAgICAgICAgICAoKGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSAhMCksXG4gICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgICAgICBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICAgICAgICByZXBsYXlVbmJsb2NrZWRFdmVudHNcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChmb3JtUmVwbGF5aW5nUXVldWUpIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSAhPT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICgobGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlID0gZm9ybVJlcGxheWluZ1F1ZXVlKSxcbiAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9PT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICAgICAgIChsYXN0U2NoZWR1bGVkUmVwbGF5UXVldWUgPSBudWxsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybVJlcGxheWluZ1F1ZXVlLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgIHZhciBmb3JtID0gZm9ybVJlcGxheWluZ1F1ZXVlW2ldLFxuICAgICAgICAgICAgICAgIHN1Ym1pdHRlck9yQWN0aW9uID0gZm9ybVJlcGxheWluZ1F1ZXVlW2kgKyAxXSxcbiAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IGZvcm1SZXBsYXlpbmdRdWV1ZVtpICsgMl07XG4gICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdWJtaXR0ZXJPckFjdGlvbilcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChzdWJtaXR0ZXJPckFjdGlvbiB8fCBmb3JtKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgIHZhciBmb3JtSW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZm9ybSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvcm1JbnN0ICYmXG4gICAgICAgICAgICAgICAgKGZvcm1SZXBsYXlpbmdRdWV1ZS5zcGxpY2UoaSwgMyksXG4gICAgICAgICAgICAgICAgKGkgLT0gMyksXG4gICAgICAgICAgICAgICAgKGZvcm0gPSB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nOiAhMCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiBmb3JtLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogc3VibWl0dGVyT3JBY3Rpb25cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGZvcm0pLFxuICAgICAgICAgICAgICAgIHN0YXJ0SG9zdFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgICBmb3JtSW5zdCxcbiAgICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbixcbiAgICAgICAgICAgICAgICAgIGZvcm1EYXRhXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgICAgIGZ1bmN0aW9uIHVuYmxvY2socXVldWVkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHF1ZXVlZEZvY3VzICYmXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRGb2N1cywgdW5ibG9ja2VkKTtcbiAgICAgIG51bGwgIT09IHF1ZXVlZERyYWcgJiYgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gICAgICBudWxsICE9PSBxdWV1ZWRNb3VzZSAmJlxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkTW91c2UsIHVuYmxvY2tlZCk7XG4gICAgICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKHVuYmxvY2spO1xuICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcXVldWVkVGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW2ldO1xuICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQgJiYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsKTtcbiAgICAgIH1cbiAgICAgIGZvciAoXG4gICAgICAgIDtcbiAgICAgICAgMCA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAgICAgKChpID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdKSwgbnVsbCA9PT0gaS5ibG9ja2VkT24pO1xuXG4gICAgICApXG4gICAgICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChpKSxcbiAgICAgICAgICBudWxsID09PSBpLmJsb2NrZWRPbiAmJiBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTtcbiAgICAgIGkgPSAodW5ibG9ja2VkLm93bmVyRG9jdW1lbnQgfHwgdW5ibG9ja2VkKS4kJHJlYWN0Rm9ybVJlcGxheTtcbiAgICAgIGlmIChudWxsICE9IGkpXG4gICAgICAgIGZvciAocXVldWVkVGFyZ2V0ID0gMDsgcXVldWVkVGFyZ2V0IDwgaS5sZW5ndGg7IHF1ZXVlZFRhcmdldCArPSAzKSB7XG4gICAgICAgICAgdmFyIGZvcm0gPSBpW3F1ZXVlZFRhcmdldF0sXG4gICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbiA9IGlbcXVldWVkVGFyZ2V0ICsgMV0sXG4gICAgICAgICAgICBmb3JtUHJvcHMgPSBmb3JtW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN1Ym1pdHRlck9yQWN0aW9uKVxuICAgICAgICAgICAgZm9ybVByb3BzIHx8IHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChpKTtcbiAgICAgICAgICBlbHNlIGlmIChmb3JtUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbiAmJlxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbi5oYXNBdHRyaWJ1dGUoXCJmb3JtQWN0aW9uXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKGZvcm0gPSBzdWJtaXR0ZXJPckFjdGlvbiksXG4gICAgICAgICAgICAgICAgKGZvcm1Qcm9wcyA9IHN1Ym1pdHRlck9yQWN0aW9uW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gZm9ybVByb3BzLmZvcm1BY3Rpb247XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChmb3JtKSkgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgYWN0aW9uID0gZm9ybVByb3BzLmFjdGlvbjtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvblxuICAgICAgICAgICAgICA/IChpW3F1ZXVlZFRhcmdldCArIDFdID0gYWN0aW9uKVxuICAgICAgICAgICAgICA6IChpLnNwbGljZShxdWV1ZWRUYXJnZXQsIDMpLCAocXVldWVkVGFyZ2V0IC09IDMpKTtcbiAgICAgICAgICAgIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RET01Sb290KGludGVybmFsUm9vdCkge1xuICAgICAgdGhpcy5faW50ZXJuYWxSb290ID0gaW50ZXJuYWxSb290O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW50ZXJuYWxSb290KSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gJiZcbiAgICAgICAgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBhcmUgY2FsbGluZyBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSBwYXNzZWQgdG8gUmVhY3RET00ucmVuZGVyKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgYXJlIGNhbGxpbmcgUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpIG9uIGEgY29udGFpbmVyIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gY3JlYXRlUm9vdCgpIGJlZm9yZS4gSW5zdGVhZCwgY2FsbCByb290LnJlbmRlcigpIG9uIHRoZSBleGlzdGluZyByb290IGluc3RlYWQgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGl0LlwiXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgU2NoZWR1bGVyID0gcmVxdWlyZShcInNjaGVkdWxlclwiKSxcbiAgICAgIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLFxuICAgICAgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbiAgICB2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC50cmFjaW5nX21hcmtlclwiKTtcbiAgICB2YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGlzUmVuZGVyaW5nID0gITEsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHZhbHVlU3RhY2sgPSBbXTtcbiAgICB2YXIgZmliZXJTdGFjayA9IFtdO1xuICAgIHZhciBpbmRleCRqc2NvbXAkMCA9IC0xLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDMgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgICBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgICAgIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsXG4gICAgICBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgICBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IFNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgTG93UHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTG93UHJpb3JpdHksXG4gICAgICBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5LFxuICAgICAgbG9nJDEgPSBTY2hlZHVsZXIubG9nLFxuICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUsXG4gICAgICByZW5kZXJlcklEID0gbnVsbCxcbiAgICAgIGluamVjdGVkSG9vayA9IG51bGwsXG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbCxcbiAgICAgIGhhc0xvZ2dlZEVycm9yID0gITEsXG4gICAgICBpc0RldlRvb2xzUHJlc2VudCA9IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sXG4gICAgICBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgsXG4gICAgICBuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCxcbiAgICAgIERpc2NyZXRlRXZlbnRQcmlvcml0eSA9IDIsXG4gICAgICBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IDgsXG4gICAgICBEZWZhdWx0RXZlbnRQcmlvcml0eSA9IDMyLFxuICAgICAgSWRsZUV2ZW50UHJpb3JpdHkgPSAyNjg0MzU0NTYsXG4gICAgICByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcbiAgICAgIGludGVybmFsSW5zdGFuY2VLZXkgPSBcIl9fcmVhY3RGaWJlciRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsUHJvcHNLZXkgPSBcIl9fcmVhY3RQcm9wcyRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkgPSBcIl9fcmVhY3RDb250YWluZXIkXCIgKyByYW5kb21LZXksXG4gICAgICBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSBcIl9fcmVhY3RFdmVudHMkXCIgKyByYW5kb21LZXksXG4gICAgICBpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleSA9IFwiX19yZWFjdExpc3RlbmVycyRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5ID0gXCJfX3JlYWN0SGFuZGxlcyRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsUm9vdE5vZGVSZXNvdXJjZXNLZXkgPSBcIl9fcmVhY3RSZXNvdXJjZXMkXCIgKyByYW5kb21LZXksXG4gICAgICBpbnRlcm5hbEhvaXN0YWJsZU1hcmtlciA9IFwiX19yZWFjdE1hcmtlciRcIiArIHJhbmRvbUtleSxcbiAgICAgIGFsbE5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoKSxcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fSxcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fSxcbiAgICAgIGNhblVzZURPTSA9ICEoXG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cgfHxcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5kb2N1bWVudCB8fFxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgICAgICksXG4gICAgICBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgICAgICBidXR0b246ICEwLFxuICAgICAgICBjaGVja2JveDogITAsXG4gICAgICAgIGltYWdlOiAhMCxcbiAgICAgICAgaGlkZGVuOiAhMCxcbiAgICAgICAgcmFkaW86ICEwLFxuICAgICAgICByZXNldDogITAsXG4gICAgICAgIHN1Ym1pdDogITBcbiAgICAgIH0sXG4gICAgICBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IFJlZ0V4cChcbiAgICAgICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzUmVnZXggPSAvW1xcblwiXFxcXF0vZyxcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gITEsXG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gITEsXG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRDaGlsZCA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRJbm5lckhUTUwgPSAhMTtcbiAgICB2YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gITE7XG4gICAgdmFyIHZhbHVlUHJvcE5hbWVzID0gW1widmFsdWVcIiwgXCJkZWZhdWx0VmFsdWVcIl0sXG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9ICExLFxuICAgICAgbmVlZHNFc2NhcGluZyA9IC9bXCInJjw+XFxuXFx0XXxeXFxzfFxccyQvLFxuICAgICAgc3BlY2lhbFRhZ3MgPVxuICAgICAgICBcImFkZHJlc3MgYXBwbGV0IGFyZWEgYXJ0aWNsZSBhc2lkZSBiYXNlIGJhc2Vmb250IGJnc291bmQgYmxvY2txdW90ZSBib2R5IGJyIGJ1dHRvbiBjYXB0aW9uIGNlbnRlciBjb2wgY29sZ3JvdXAgZGQgZGV0YWlscyBkaXIgZGl2IGRsIGR0IGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGZyYW1lIGZyYW1lc2V0IGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhncm91cCBociBodG1sIGlmcmFtZSBpbWcgaW5wdXQgaXNpbmRleCBsaSBsaW5rIGxpc3RpbmcgbWFpbiBtYXJxdWVlIG1lbnUgbWVudWl0ZW0gbWV0YSBuYXYgbm9lbWJlZCBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3Qgb2wgcCBwYXJhbSBwbGFpbnRleHQgcHJlIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzb3VyY2Ugc3R5bGUgc3VtbWFyeSB0YWJsZSB0Ym9keSB0ZCB0ZW1wbGF0ZSB0ZXh0YXJlYSB0Zm9vdCB0aCB0aGVhZCB0aXRsZSB0ciB0cmFjayB1bCB3YnIgeG1wXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgIGluU2NvcGVUYWdzID1cbiAgICAgICAgXCJhcHBsZXQgY2FwdGlvbiBodG1sIHRhYmxlIHRkIHRoIG1hcnF1ZWUgb2JqZWN0IHRlbXBsYXRlIGZvcmVpZ25PYmplY3QgZGVzYyB0aXRsZVwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgICksXG4gICAgICBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoW1wiYnV0dG9uXCJdKSxcbiAgICAgIGltcGxpZWRFbmRUYWdzID0gXCJkZCBkdCBsaSBvcHRpb24gb3B0Z3JvdXAgcCBycCBydFwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIGVtcHR5QW5jZXN0b3JJbmZvRGV2ID0ge1xuICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICBmb3JtVGFnOiBudWxsLFxuICAgICAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICAgICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICAgICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuICAgICAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgICAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICAgICAgY29udGFpbmVyVGFnSW5TY29wZTogbnVsbFxuICAgICAgfSxcbiAgICAgIGRpZFdhcm4gPSB7fSxcbiAgICAgIE1BVEhfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsXG4gICAgICBTVkdfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgICAgICAgYW5pbWF0aW9uOlxuICAgICAgICAgIFwiYW5pbWF0aW9uRGVsYXkgYW5pbWF0aW9uRGlyZWN0aW9uIGFuaW1hdGlvbkR1cmF0aW9uIGFuaW1hdGlvbkZpbGxNb2RlIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IGFuaW1hdGlvbk5hbWUgYW5pbWF0aW9uUGxheVN0YXRlIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIuc3BsaXQoXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICksXG4gICAgICAgIGJhY2tncm91bmQ6XG4gICAgICAgICAgXCJiYWNrZ3JvdW5kQXR0YWNobWVudCBiYWNrZ3JvdW5kQ2xpcCBiYWNrZ3JvdW5kQ29sb3IgYmFja2dyb3VuZEltYWdlIGJhY2tncm91bmRPcmlnaW4gYmFja2dyb3VuZFBvc2l0aW9uWCBiYWNrZ3JvdW5kUG9zaXRpb25ZIGJhY2tncm91bmRSZXBlYXQgYmFja2dyb3VuZFNpemVcIi5zcGxpdChcbiAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBbXCJiYWNrZ3JvdW5kUG9zaXRpb25YXCIsIFwiYmFja2dyb3VuZFBvc2l0aW9uWVwiXSxcbiAgICAgICAgYm9yZGVyOlxuICAgICAgICAgIFwiYm9yZGVyQm90dG9tQ29sb3IgYm9yZGVyQm90dG9tU3R5bGUgYm9yZGVyQm90dG9tV2lkdGggYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VSZXBlYXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVNvdXJjZSBib3JkZXJJbWFnZVdpZHRoIGJvcmRlckxlZnRDb2xvciBib3JkZXJMZWZ0U3R5bGUgYm9yZGVyTGVmdFdpZHRoIGJvcmRlclJpZ2h0Q29sb3IgYm9yZGVyUmlnaHRTdHlsZSBib3JkZXJSaWdodFdpZHRoIGJvcmRlclRvcENvbG9yIGJvcmRlclRvcFN0eWxlIGJvcmRlclRvcFdpZHRoXCIuc3BsaXQoXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICksXG4gICAgICAgIGJvcmRlckJsb2NrRW5kOiBbXG4gICAgICAgICAgXCJib3JkZXJCbG9ja0VuZENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJCbG9ja0VuZFN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJCbG9ja0VuZFdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQmxvY2tTdGFydDogW1xuICAgICAgICAgIFwiYm9yZGVyQmxvY2tTdGFydENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJCbG9ja1N0YXJ0U3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlckJsb2NrU3RhcnRXaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckJvdHRvbTogW1xuICAgICAgICAgIFwiYm9yZGVyQm90dG9tQ29sb3JcIixcbiAgICAgICAgICBcImJvcmRlckJvdHRvbVN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJCb3R0b21XaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgXCJib3JkZXJCb3R0b21Db2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVyTGVmdENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJSaWdodENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJUb3BDb2xvclwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckltYWdlOiBbXG4gICAgICAgICAgXCJib3JkZXJJbWFnZU91dHNldFwiLFxuICAgICAgICAgIFwiYm9yZGVySW1hZ2VSZXBlYXRcIixcbiAgICAgICAgICBcImJvcmRlckltYWdlU2xpY2VcIixcbiAgICAgICAgICBcImJvcmRlckltYWdlU291cmNlXCIsXG4gICAgICAgICAgXCJib3JkZXJJbWFnZVdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVySW5saW5lRW5kOiBbXG4gICAgICAgICAgXCJib3JkZXJJbmxpbmVFbmRDb2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVySW5saW5lRW5kU3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlcklubGluZUVuZFdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVySW5saW5lU3RhcnQ6IFtcbiAgICAgICAgICBcImJvcmRlcklubGluZVN0YXJ0Q29sb3JcIixcbiAgICAgICAgICBcImJvcmRlcklubGluZVN0YXJ0U3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlcklubGluZVN0YXJ0V2lkdGhcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJMZWZ0OiBbXCJib3JkZXJMZWZ0Q29sb3JcIiwgXCJib3JkZXJMZWZ0U3R5bGVcIiwgXCJib3JkZXJMZWZ0V2lkdGhcIl0sXG4gICAgICAgIGJvcmRlclJhZGl1czogW1xuICAgICAgICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgICAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICAgICAgICBcImJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICAgICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyUmlnaHQ6IFtcbiAgICAgICAgICBcImJvcmRlclJpZ2h0Q29sb3JcIixcbiAgICAgICAgICBcImJvcmRlclJpZ2h0U3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlclJpZ2h0V2lkdGhcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJTdHlsZTogW1xuICAgICAgICAgIFwiYm9yZGVyQm90dG9tU3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlckxlZnRTdHlsZVwiLFxuICAgICAgICAgIFwiYm9yZGVyUmlnaHRTdHlsZVwiLFxuICAgICAgICAgIFwiYm9yZGVyVG9wU3R5bGVcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJUb3A6IFtcImJvcmRlclRvcENvbG9yXCIsIFwiYm9yZGVyVG9wU3R5bGVcIiwgXCJib3JkZXJUb3BXaWR0aFwiXSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IFtcbiAgICAgICAgICBcImJvcmRlckJvdHRvbVdpZHRoXCIsXG4gICAgICAgICAgXCJib3JkZXJMZWZ0V2lkdGhcIixcbiAgICAgICAgICBcImJvcmRlclJpZ2h0V2lkdGhcIixcbiAgICAgICAgICBcImJvcmRlclRvcFdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgY29sdW1uUnVsZTogW1wiY29sdW1uUnVsZUNvbG9yXCIsIFwiY29sdW1uUnVsZVN0eWxlXCIsIFwiY29sdW1uUnVsZVdpZHRoXCJdLFxuICAgICAgICBjb2x1bW5zOiBbXCJjb2x1bW5Db3VudFwiLCBcImNvbHVtbldpZHRoXCJdLFxuICAgICAgICBmbGV4OiBbXCJmbGV4QmFzaXNcIiwgXCJmbGV4R3Jvd1wiLCBcImZsZXhTaHJpbmtcIl0sXG4gICAgICAgIGZsZXhGbG93OiBbXCJmbGV4RGlyZWN0aW9uXCIsIFwiZmxleFdyYXBcIl0sXG4gICAgICAgIGZvbnQ6IFwiZm9udEZhbWlseSBmb250RmVhdHVyZVNldHRpbmdzIGZvbnRLZXJuaW5nIGZvbnRMYW5ndWFnZU92ZXJyaWRlIGZvbnRTaXplIGZvbnRTaXplQWRqdXN0IGZvbnRTdHJldGNoIGZvbnRTdHlsZSBmb250VmFyaWFudCBmb250VmFyaWFudEFsdGVybmF0ZXMgZm9udFZhcmlhbnRDYXBzIGZvbnRWYXJpYW50RWFzdEFzaWFuIGZvbnRWYXJpYW50TGlnYXR1cmVzIGZvbnRWYXJpYW50TnVtZXJpYyBmb250VmFyaWFudFBvc2l0aW9uIGZvbnRXZWlnaHQgbGluZUhlaWdodFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgICksXG4gICAgICAgIGZvbnRWYXJpYW50OlxuICAgICAgICAgIFwiZm9udFZhcmlhbnRBbHRlcm5hdGVzIGZvbnRWYXJpYW50Q2FwcyBmb250VmFyaWFudEVhc3RBc2lhbiBmb250VmFyaWFudExpZ2F0dXJlcyBmb250VmFyaWFudE51bWVyaWMgZm9udFZhcmlhbnRQb3NpdGlvblwiLnNwbGl0KFxuICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICApLFxuICAgICAgICBnYXA6IFtcImNvbHVtbkdhcFwiLCBcInJvd0dhcFwiXSxcbiAgICAgICAgZ3JpZDogXCJncmlkQXV0b0NvbHVtbnMgZ3JpZEF1dG9GbG93IGdyaWRBdXRvUm93cyBncmlkVGVtcGxhdGVBcmVhcyBncmlkVGVtcGxhdGVDb2x1bW5zIGdyaWRUZW1wbGF0ZVJvd3NcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgICBncmlkQXJlYTogW1xuICAgICAgICAgIFwiZ3JpZENvbHVtbkVuZFwiLFxuICAgICAgICAgIFwiZ3JpZENvbHVtblN0YXJ0XCIsXG4gICAgICAgICAgXCJncmlkUm93RW5kXCIsXG4gICAgICAgICAgXCJncmlkUm93U3RhcnRcIlxuICAgICAgICBdLFxuICAgICAgICBncmlkQ29sdW1uOiBbXCJncmlkQ29sdW1uRW5kXCIsIFwiZ3JpZENvbHVtblN0YXJ0XCJdLFxuICAgICAgICBncmlkQ29sdW1uR2FwOiBbXCJjb2x1bW5HYXBcIl0sXG4gICAgICAgIGdyaWRHYXA6IFtcImNvbHVtbkdhcFwiLCBcInJvd0dhcFwiXSxcbiAgICAgICAgZ3JpZFJvdzogW1wiZ3JpZFJvd0VuZFwiLCBcImdyaWRSb3dTdGFydFwiXSxcbiAgICAgICAgZ3JpZFJvd0dhcDogW1wicm93R2FwXCJdLFxuICAgICAgICBncmlkVGVtcGxhdGU6IFtcbiAgICAgICAgICBcImdyaWRUZW1wbGF0ZUFyZWFzXCIsXG4gICAgICAgICAgXCJncmlkVGVtcGxhdGVDb2x1bW5zXCIsXG4gICAgICAgICAgXCJncmlkVGVtcGxhdGVSb3dzXCJcbiAgICAgICAgXSxcbiAgICAgICAgbGlzdFN0eWxlOiBbXCJsaXN0U3R5bGVJbWFnZVwiLCBcImxpc3RTdHlsZVBvc2l0aW9uXCIsIFwibGlzdFN0eWxlVHlwZVwiXSxcbiAgICAgICAgbWFyZ2luOiBbXCJtYXJnaW5Cb3R0b21cIiwgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Ub3BcIl0sXG4gICAgICAgIG1hcmtlcjogW1wibWFya2VyRW5kXCIsIFwibWFya2VyTWlkXCIsIFwibWFya2VyU3RhcnRcIl0sXG4gICAgICAgIG1hc2s6IFwibWFza0NsaXAgbWFza0NvbXBvc2l0ZSBtYXNrSW1hZ2UgbWFza01vZGUgbWFza09yaWdpbiBtYXNrUG9zaXRpb25YIG1hc2tQb3NpdGlvblkgbWFza1JlcGVhdCBtYXNrU2l6ZVwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgICksXG4gICAgICAgIG1hc2tQb3NpdGlvbjogW1wibWFza1Bvc2l0aW9uWFwiLCBcIm1hc2tQb3NpdGlvbllcIl0sXG4gICAgICAgIG91dGxpbmU6IFtcIm91dGxpbmVDb2xvclwiLCBcIm91dGxpbmVTdHlsZVwiLCBcIm91dGxpbmVXaWR0aFwiXSxcbiAgICAgICAgb3ZlcmZsb3c6IFtcIm92ZXJmbG93WFwiLCBcIm92ZXJmbG93WVwiXSxcbiAgICAgICAgcGFkZGluZzogW1wicGFkZGluZ0JvdHRvbVwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIsIFwicGFkZGluZ1RvcFwiXSxcbiAgICAgICAgcGxhY2VDb250ZW50OiBbXCJhbGlnbkNvbnRlbnRcIiwgXCJqdXN0aWZ5Q29udGVudFwiXSxcbiAgICAgICAgcGxhY2VJdGVtczogW1wiYWxpZ25JdGVtc1wiLCBcImp1c3RpZnlJdGVtc1wiXSxcbiAgICAgICAgcGxhY2VTZWxmOiBbXCJhbGlnblNlbGZcIiwgXCJqdXN0aWZ5U2VsZlwiXSxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFtcbiAgICAgICAgICBcInRleHREZWNvcmF0aW9uQ29sb3JcIixcbiAgICAgICAgICBcInRleHREZWNvcmF0aW9uTGluZVwiLFxuICAgICAgICAgIFwidGV4dERlY29yYXRpb25TdHlsZVwiXG4gICAgICAgIF0sXG4gICAgICAgIHRleHRFbXBoYXNpczogW1widGV4dEVtcGhhc2lzQ29sb3JcIiwgXCJ0ZXh0RW1waGFzaXNTdHlsZVwiXSxcbiAgICAgICAgdHJhbnNpdGlvbjogW1xuICAgICAgICAgIFwidHJhbnNpdGlvbkRlbGF5XCIsXG4gICAgICAgICAgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICAgICAgICBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgICAgICAgIFwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgd29yZFdyYXA6IFtcIm92ZXJmbG93V3JhcFwiXVxuICAgICAgfSxcbiAgICAgIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nLFxuICAgICAgbXNQYXR0ZXJuJDEgPSAvXm1zLS8sXG4gICAgICBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS8sXG4gICAgICBtc1BhdHRlcm4gPSAvXi1tcy0vLFxuICAgICAgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2csXG4gICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLyxcbiAgICAgIHdhcm5lZFN0eWxlTmFtZXMgPSB7fSxcbiAgICAgIHdhcm5lZFN0eWxlVmFsdWVzID0ge30sXG4gICAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9ICExLFxuICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICExLFxuICAgICAgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChcbiAgICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudCBhc3BlY3RSYXRpbyBib3JkZXJJbWFnZU91dHNldCBib3JkZXJJbWFnZVNsaWNlIGJvcmRlckltYWdlV2lkdGggYm94RmxleCBib3hGbGV4R3JvdXAgYm94T3JkaW5hbEdyb3VwIGNvbHVtbkNvdW50IGNvbHVtbnMgZmxleCBmbGV4R3JvdyBmbGV4UG9zaXRpdmUgZmxleFNocmluayBmbGV4TmVnYXRpdmUgZmxleE9yZGVyIGdyaWRBcmVhIGdyaWRSb3cgZ3JpZFJvd0VuZCBncmlkUm93U3BhbiBncmlkUm93U3RhcnQgZ3JpZENvbHVtbiBncmlkQ29sdW1uRW5kIGdyaWRDb2x1bW5TcGFuIGdyaWRDb2x1bW5TdGFydCBmb250V2VpZ2h0IGxpbmVDbGFtcCBsaW5lSGVpZ2h0IG9wYWNpdHkgb3JkZXIgb3JwaGFucyBzY2FsZSB0YWJTaXplIHdpZG93cyB6SW5kZXggem9vbSBmaWxsT3BhY2l0eSBmbG9vZE9wYWNpdHkgc3RvcE9wYWNpdHkgc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTWl0ZXJsaW1pdCBzdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIE1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IE1vekJveEZsZXggTW96Qm94RmxleEdyb3VwIE1vekxpbmVDbGFtcCBtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IG1zRmxleCBtc1pvb20gbXNGbGV4R3JvdyBtc0ZsZXhOZWdhdGl2ZSBtc0ZsZXhPcmRlciBtc0ZsZXhQb3NpdGl2ZSBtc0ZsZXhTaHJpbmsgbXNHcmlkQ29sdW1uIG1zR3JpZENvbHVtblNwYW4gbXNHcmlkUm93IG1zR3JpZFJvd1NwYW4gV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgV2Via2l0Qm94RmxleCBXZWJLaXRCb3hGbGV4R3JvdXAgV2Via2l0Qm94T3JkaW5hbEdyb3VwIFdlYmtpdENvbHVtbkNvdW50IFdlYmtpdENvbHVtbnMgV2Via2l0RmxleCBXZWJraXRGbGV4R3JvdyBXZWJraXRGbGV4UG9zaXRpdmUgV2Via2l0RmxleFNocmluayBXZWJraXRMaW5lQ2xhbXBcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICApLFxuICAgICAgYWxpYXNlcyA9IG5ldyBNYXAoW1xuICAgICAgICBbXCJhY2NlcHRDaGFyc2V0XCIsIFwiYWNjZXB0LWNoYXJzZXRcIl0sXG4gICAgICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgICAgIFtcImh0dHBFcXVpdlwiLCBcImh0dHAtZXF1aXZcIl0sXG4gICAgICAgIFtcImNyb3NzT3JpZ2luXCIsIFwiY3Jvc3NvcmlnaW5cIl0sXG4gICAgICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImFsaWdubWVudEJhc2VsaW5lXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJhcmFiaWNGb3JtXCIsIFwiYXJhYmljLWZvcm1cIl0sXG4gICAgICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICAgICAgW1wiY2FwSGVpZ2h0XCIsIFwiY2FwLWhlaWdodFwiXSxcbiAgICAgICAgW1wiY2xpcFBhdGhcIiwgXCJjbGlwLXBhdGhcIl0sXG4gICAgICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCJdLFxuICAgICAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgICAgICBbXCJjb2xvclJlbmRlcmluZ1wiLCBcImNvbG9yLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wiZG9taW5hbnRCYXNlbGluZVwiLCBcImRvbWluYW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgICAgIFtcImZpbGxPcGFjaXR5XCIsIFwiZmlsbC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmaWxsUnVsZVwiLCBcImZpbGwtcnVsZVwiXSxcbiAgICAgICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgICAgICBbXCJmbG9vZE9wYWNpdHlcIiwgXCJmbG9vZC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmb250RmFtaWx5XCIsIFwiZm9udC1mYW1pbHlcIl0sXG4gICAgICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgICAgICBbXCJmb250U2l6ZUFkanVzdFwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIl0sXG4gICAgICAgIFtcImZvbnRTdHJldGNoXCIsIFwiZm9udC1zdHJldGNoXCJdLFxuICAgICAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgICAgICBbXCJmb250VmFyaWFudFwiLCBcImZvbnQtdmFyaWFudFwiXSxcbiAgICAgICAgW1wiZm9udFdlaWdodFwiLCBcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCJdLFxuICAgICAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICAgICAgW1wiaG9yaXpPcmlnaW5YXCIsIFwiaG9yaXotb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcImltYWdlUmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcImxpZ2h0aW5nQ29sb3JcIiwgXCJsaWdodGluZy1jb2xvclwiXSxcbiAgICAgICAgW1wibWFya2VyRW5kXCIsIFwibWFya2VyLWVuZFwiXSxcbiAgICAgICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICAgICAgW1wibWFya2VyU3RhcnRcIiwgXCJtYXJrZXItc3RhcnRcIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lUG9zaXRpb25cIiwgXCJvdmVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInBhaW50T3JkZXJcIiwgXCJwYWludC1vcmRlclwiXSxcbiAgICAgICAgW1wicGFub3NlLTFcIiwgXCJwYW5vc2UtMVwiXSxcbiAgICAgICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICBbXCJyZW5kZXJpbmdJbnRlbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCJdLFxuICAgICAgICBbXCJzaGFwZVJlbmRlcmluZ1wiLCBcInNoYXBlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICAgICAgW1wic3RvcE9wYWNpdHlcIiwgXCJzdG9wLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaG9mZnNldFwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVqb2luXCIsIFwic3Ryb2tlLWxpbmVqb2luXCJdLFxuICAgICAgICBbXCJzdHJva2VNaXRlcmxpbWl0XCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIl0sXG4gICAgICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgICAgIFtcInRleHRBbmNob3JcIiwgXCJ0ZXh0LWFuY2hvclwiXSxcbiAgICAgICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgICAgIFtcInRleHRSZW5kZXJpbmdcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1widHJhbnNmb3JtT3JpZ2luXCIsIFwidHJhbnNmb3JtLW9yaWdpblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVRoaWNrbmVzc1wiLCBcInVuZGVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInVuaWNvZGVCaWRpXCIsIFwidW5pY29kZS1iaWRpXCJdLFxuICAgICAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgICAgICBbXCJ1bml0c1BlckVtXCIsIFwidW5pdHMtcGVyLWVtXCJdLFxuICAgICAgICBbXCJ2QWxwaGFiZXRpY1wiLCBcInYtYWxwaGFiZXRpY1wiXSxcbiAgICAgICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgICAgIFtcInZJZGVvZ3JhcGhpY1wiLCBcInYtaWRlb2dyYXBoaWNcIl0sXG4gICAgICAgIFtcInZNYXRoZW1hdGljYWxcIiwgXCJ2LW1hdGhlbWF0aWNhbFwiXSxcbiAgICAgICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICAgICAgW1widmVydEFkdllcIiwgXCJ2ZXJ0LWFkdi15XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWFwiLCBcInZlcnQtb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICAgICAgW1wid29yZFNwYWNpbmdcIiwgXCJ3b3JkLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcIndyaXRpbmdNb2RlXCIsIFwid3JpdGluZy1tb2RlXCJdLFxuICAgICAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgICAgIFtcInhIZWlnaHRcIiwgXCJ4LWhlaWdodFwiXVxuICAgICAgXSksXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICBhcmlhUHJvcGVydGllcyA9IHtcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXRhaWxzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1rZXlzaG9ydGN1dHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAwLFxuICAgICAgICBcImFyaWEtY2hlY2tlZFwiOiAwLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sZXZlbFwiOiAwLFxuICAgICAgICBcImFyaWEtbW9kYWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtcGxhY2Vob2xkZXJcIjogMCxcbiAgICAgICAgXCJhcmlhLXByZXNzZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlYWRvbmx5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNvcnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVldGV4dFwiOiAwLFxuICAgICAgICBcImFyaWEtYXRvbWljXCI6IDAsXG4gICAgICAgIFwiYXJpYS1idXN5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1saXZlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWxldmFudFwiOiAwLFxuICAgICAgICBcImFyaWEtZHJvcGVmZmVjdFwiOiAwLFxuICAgICAgICBcImFyaWEtZ3JhYmJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sY291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGluZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLWVycm9ybWVzc2FnZVwiOiAwLFxuICAgICAgICBcImFyaWEtZmxvd3RvXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1vd25zXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93Y291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2luZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZXRzaXplXCI6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fSxcbiAgICAgIHJBUklBJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9ICExLFxuICAgICAgd2FybmVkUHJvcGVydGllcyA9IHt9LFxuICAgICAgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLyxcbiAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vLFxuICAgICAgckFSSUEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGlzSmF2YVNjcmlwdFByb3RvY29sID1cbiAgICAgICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaSxcbiAgICAgIGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9IG51bGwsXG4gICAgICByZXN0b3JlVGFyZ2V0ID0gbnVsbCxcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IG51bGwsXG4gICAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9ICExLFxuICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMTtcbiAgICBpZiAoY2FuVXNlRE9NKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdGlvbnMkanNjb21wJDAgPSB7fTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMkanNjb21wJDAsIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBvcHRpb25zJGpzY29tcCQwLCBvcHRpb25zJGpzY29tcCQwKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG9wdGlvbnMkanNjb21wJDAsIG9wdGlvbnMkanNjb21wJDApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCA9ICExO1xuICAgICAgfVxuICAgIHZhciByb290ID0gbnVsbCxcbiAgICAgIHN0YXJ0VGV4dCA9IG51bGwsXG4gICAgICBmYWxsYmFja1RleHQgPSBudWxsLFxuICAgICAgRXZlbnRJbnRlcmZhY2UgPSB7XG4gICAgICAgIGV2ZW50UGhhc2U6IDAsXG4gICAgICAgIGJ1YmJsZXM6IDAsXG4gICAgICAgIGNhbmNlbGFibGU6IDAsXG4gICAgICAgIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICAgICAgICBpc1RydXN0ZWQ6IDBcbiAgICAgIH0sXG4gICAgICBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7IHZpZXc6IDAsIGRldGFpbDogMCB9KSxcbiAgICAgIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIGxhc3RNb3ZlbWVudFgsXG4gICAgICBsYXN0TW92ZW1lbnRZLFxuICAgICAgbGFzdE1vdXNlRXZlbnQsXG4gICAgICBNb3VzZUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIHNjcmVlblg6IDAsXG4gICAgICAgIHNjcmVlblk6IDAsXG4gICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgIGNsaWVudFk6IDAsXG4gICAgICAgIHBhZ2VYOiAwLFxuICAgICAgICBwYWdlWTogMCxcbiAgICAgICAgY3RybEtleTogMCxcbiAgICAgICAgc2hpZnRLZXk6IDAsXG4gICAgICAgIGFsdEtleTogMCxcbiAgICAgICAgbWV0YUtleTogMCxcbiAgICAgICAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAgICAgICBidXR0b246IDAsXG4gICAgICAgIGJ1dHRvbnM6IDAsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGV2ZW50LnJlbGF0ZWRUYXJnZXRcbiAgICAgICAgICAgID8gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnRcbiAgICAgICAgICAgICAgPyBldmVudC50b0VsZW1lbnRcbiAgICAgICAgICAgICAgOiBldmVudC5mcm9tRWxlbWVudFxuICAgICAgICAgICAgOiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlbWVudFg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChcIm1vdmVtZW50WFwiIGluIGV2ZW50KSByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgICAgIGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCAmJlxuICAgICAgICAgICAgKGxhc3RNb3VzZUV2ZW50ICYmIFwibW91c2Vtb3ZlXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICAgICAgPyAoKGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWCksXG4gICAgICAgICAgICAgICAgKGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWSkpXG4gICAgICAgICAgICAgIDogKGxhc3RNb3ZlbWVudFkgPSBsYXN0TW92ZW1lbnRYID0gMCksXG4gICAgICAgICAgICAobGFzdE1vdXNlRXZlbnQgPSBldmVudCkpO1xuICAgICAgICAgIHJldHVybiBsYXN0TW92ZW1lbnRYO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcIm1vdmVtZW50WVwiIGluIGV2ZW50ID8gZXZlbnQubW92ZW1lbnRZIDogbGFzdE1vdmVtZW50WTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNNb3VzZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoTW91c2VFdmVudEludGVyZmFjZSksXG4gICAgICBEcmFnRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHsgZGF0YVRyYW5zZmVyOiAwIH0pLFxuICAgICAgU3ludGhldGljRHJhZ0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRHJhZ0V2ZW50SW50ZXJmYWNlKSxcbiAgICAgIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHsgcmVsYXRlZFRhcmdldDogMCB9KSxcbiAgICAgIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChGb2N1c0V2ZW50SW50ZXJmYWNlKSxcbiAgICAgIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgICAgICBhbmltYXRpb25OYW1lOiAwLFxuICAgICAgICBlbGFwc2VkVGltZTogMCxcbiAgICAgICAgcHNldWRvRWxlbWVudDogMFxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gXCJjbGlwYm9hcmREYXRhXCIgaW4gZXZlbnRcbiAgICAgICAgICAgID8gZXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgICAgICAgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7IGRhdGE6IDAgfSksXG4gICAgICBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoXG4gICAgICAgIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2VcbiAgICAgICksXG4gICAgICBTeW50aGV0aWNJbnB1dEV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudCxcbiAgICAgIG5vcm1hbGl6ZUtleSA9IHtcbiAgICAgICAgRXNjOiBcIkVzY2FwZVwiLFxuICAgICAgICBTcGFjZWJhcjogXCIgXCIsXG4gICAgICAgIExlZnQ6IFwiQXJyb3dMZWZ0XCIsXG4gICAgICAgIFVwOiBcIkFycm93VXBcIixcbiAgICAgICAgUmlnaHQ6IFwiQXJyb3dSaWdodFwiLFxuICAgICAgICBEb3duOiBcIkFycm93RG93blwiLFxuICAgICAgICBEZWw6IFwiRGVsZXRlXCIsXG4gICAgICAgIFdpbjogXCJPU1wiLFxuICAgICAgICBNZW51OiBcIkNvbnRleHRNZW51XCIsXG4gICAgICAgIEFwcHM6IFwiQ29udGV4dE1lbnVcIixcbiAgICAgICAgU2Nyb2xsOiBcIlNjcm9sbExvY2tcIixcbiAgICAgICAgTW96UHJpbnRhYmxlS2V5OiBcIlVuaWRlbnRpZmllZFwiXG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICAgICAgIDg6IFwiQmFja3NwYWNlXCIsXG4gICAgICAgIDk6IFwiVGFiXCIsXG4gICAgICAgIDEyOiBcIkNsZWFyXCIsXG4gICAgICAgIDEzOiBcIkVudGVyXCIsXG4gICAgICAgIDE2OiBcIlNoaWZ0XCIsXG4gICAgICAgIDE3OiBcIkNvbnRyb2xcIixcbiAgICAgICAgMTg6IFwiQWx0XCIsXG4gICAgICAgIDE5OiBcIlBhdXNlXCIsXG4gICAgICAgIDIwOiBcIkNhcHNMb2NrXCIsXG4gICAgICAgIDI3OiBcIkVzY2FwZVwiLFxuICAgICAgICAzMjogXCIgXCIsXG4gICAgICAgIDMzOiBcIlBhZ2VVcFwiLFxuICAgICAgICAzNDogXCJQYWdlRG93blwiLFxuICAgICAgICAzNTogXCJFbmRcIixcbiAgICAgICAgMzY6IFwiSG9tZVwiLFxuICAgICAgICAzNzogXCJBcnJvd0xlZnRcIixcbiAgICAgICAgMzg6IFwiQXJyb3dVcFwiLFxuICAgICAgICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gICAgICAgIDQwOiBcIkFycm93RG93blwiLFxuICAgICAgICA0NTogXCJJbnNlcnRcIixcbiAgICAgICAgNDY6IFwiRGVsZXRlXCIsXG4gICAgICAgIDExMjogXCJGMVwiLFxuICAgICAgICAxMTM6IFwiRjJcIixcbiAgICAgICAgMTE0OiBcIkYzXCIsXG4gICAgICAgIDExNTogXCJGNFwiLFxuICAgICAgICAxMTY6IFwiRjVcIixcbiAgICAgICAgMTE3OiBcIkY2XCIsXG4gICAgICAgIDExODogXCJGN1wiLFxuICAgICAgICAxMTk6IFwiRjhcIixcbiAgICAgICAgMTIwOiBcIkY5XCIsXG4gICAgICAgIDEyMTogXCJGMTBcIixcbiAgICAgICAgMTIyOiBcIkYxMVwiLFxuICAgICAgICAxMjM6IFwiRjEyXCIsXG4gICAgICAgIDE0NDogXCJOdW1Mb2NrXCIsXG4gICAgICAgIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gICAgICAgIDIyNDogXCJNZXRhXCJcbiAgICAgIH0sXG4gICAgICBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgICAgICAgQWx0OiBcImFsdEtleVwiLFxuICAgICAgICBDb250cm9sOiBcImN0cmxLZXlcIixcbiAgICAgICAgTWV0YTogXCJtZXRhS2V5XCIsXG4gICAgICAgIFNoaWZ0OiBcInNoaWZ0S2V5XCJcbiAgICAgIH0sXG4gICAgICBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIGtleTogZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChcIlVuaWRlbnRpZmllZFwiICE9PSBrZXkpIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcImtleXByZXNzXCIgPT09IG5hdGl2ZUV2ZW50LnR5cGVcbiAgICAgICAgICAgID8gKChuYXRpdmVFdmVudCA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpKSxcbiAgICAgICAgICAgICAgMTMgPT09IG5hdGl2ZUV2ZW50ID8gXCJFbnRlclwiIDogU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudCkpXG4gICAgICAgICAgICA6IFwia2V5ZG93blwiID09PSBuYXRpdmVFdmVudC50eXBlIHx8IFwia2V5dXBcIiA9PT0gbmF0aXZlRXZlbnQudHlwZVxuICAgICAgICAgICAgICA/IHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBjb2RlOiAwLFxuICAgICAgICBsb2NhdGlvbjogMCxcbiAgICAgICAgY3RybEtleTogMCxcbiAgICAgICAgc2hpZnRLZXk6IDAsXG4gICAgICAgIGFsdEtleTogMCxcbiAgICAgICAgbWV0YUtleTogMCxcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBsb2NhbGU6IDAsXG4gICAgICAgIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgICAgICAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcImtleXByZXNzXCIgPT09IGV2ZW50LnR5cGUgPyBnZXRFdmVudENoYXJDb2RlKGV2ZW50KSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcImtleWRvd25cIiA9PT0gZXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICAgID8gZXZlbnQua2V5Q29kZVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB9LFxuICAgICAgICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5cHJlc3NcIiA9PT0gZXZlbnQudHlwZVxuICAgICAgICAgICAgPyBnZXRFdmVudENoYXJDb2RlKGV2ZW50KVxuICAgICAgICAgICAgOiBcImtleWRvd25cIiA9PT0gZXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICAgICAgPyBldmVudC5rZXlDb2RlXG4gICAgICAgICAgICAgIDogMDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSksXG4gICAgICBQb2ludGVyRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgICAgICAgcG9pbnRlcklkOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBwcmVzc3VyZTogMCxcbiAgICAgICAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICAgICAgICB0aWx0WDogMCxcbiAgICAgICAgdGlsdFk6IDAsXG4gICAgICAgIHR3aXN0OiAwLFxuICAgICAgICBwb2ludGVyVHlwZTogMCxcbiAgICAgICAgaXNQcmltYXJ5OiAwXG4gICAgICB9KSxcbiAgICAgIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSksXG4gICAgICBUb3VjaEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIHRvdWNoZXM6IDAsXG4gICAgICAgIHRhcmdldFRvdWNoZXM6IDAsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiAwLFxuICAgICAgICBhbHRLZXk6IDAsXG4gICAgICAgIG1ldGFLZXk6IDAsXG4gICAgICAgIGN0cmxLZXk6IDAsXG4gICAgICAgIHNoaWZ0S2V5OiAwLFxuICAgICAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgICAgICBwcm9wZXJ0eU5hbWU6IDAsXG4gICAgICAgIGVsYXBzZWRUaW1lOiAwLFxuICAgICAgICBwc2V1ZG9FbGVtZW50OiAwXG4gICAgICB9KSxcbiAgICAgIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSksXG4gICAgICBXaGVlbEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGVsdGFYXCIgaW4gZXZlbnRcbiAgICAgICAgICAgID8gZXZlbnQuZGVsdGFYXG4gICAgICAgICAgICA6IFwid2hlZWxEZWx0YVhcIiBpbiBldmVudFxuICAgICAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhWFxuICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgICAgID8gZXZlbnQuZGVsdGFZXG4gICAgICAgICAgICA6IFwid2hlZWxEZWx0YVlcIiBpbiBldmVudFxuICAgICAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhWVxuICAgICAgICAgICAgICA6IFwid2hlZWxEZWx0YVwiIGluIGV2ZW50XG4gICAgICAgICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsdGFaOiAwLFxuICAgICAgICBkZWx0YU1vZGU6IDBcbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljV2hlZWxFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgVG9nZ2xlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIG5ld1N0YXRlOiAwLFxuICAgICAgICBvbGRTdGF0ZTogMFxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNUb2dnbGVFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvZ2dsZUV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXSxcbiAgICAgIFNUQVJUX0tFWUNPREUgPSAyMjksXG4gICAgICBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmIFwiQ29tcG9zaXRpb25FdmVudFwiIGluIHdpbmRvdyxcbiAgICAgIGRvY3VtZW50TW9kZSA9IG51bGw7XG4gICAgY2FuVXNlRE9NICYmXG4gICAgICBcImRvY3VtZW50TW9kZVwiIGluIGRvY3VtZW50ICYmXG4gICAgICAoZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbiAgICB2YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPVxuICAgICAgICBjYW5Vc2VET00gJiYgXCJUZXh0RXZlbnRcIiBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSxcbiAgICAgIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID1cbiAgICAgICAgY2FuVXNlRE9NICYmXG4gICAgICAgICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fFxuICAgICAgICAgIChkb2N1bWVudE1vZGUgJiYgOCA8IGRvY3VtZW50TW9kZSAmJiAxMSA+PSBkb2N1bWVudE1vZGUpKSxcbiAgICAgIFNQQUNFQkFSX0NPREUgPSAzMixcbiAgICAgIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpLFxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9ICExLFxuICAgICAgaXNDb21wb3NpbmcgPSAhMSxcbiAgICAgIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICAgICAgIGNvbG9yOiAhMCxcbiAgICAgICAgZGF0ZTogITAsXG4gICAgICAgIGRhdGV0aW1lOiAhMCxcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiOiAhMCxcbiAgICAgICAgZW1haWw6ICEwLFxuICAgICAgICBtb250aDogITAsXG4gICAgICAgIG51bWJlcjogITAsXG4gICAgICAgIHBhc3N3b3JkOiAhMCxcbiAgICAgICAgcmFuZ2U6ICEwLFxuICAgICAgICBzZWFyY2g6ICEwLFxuICAgICAgICB0ZWw6ICEwLFxuICAgICAgICB0ZXh0OiAhMCxcbiAgICAgICAgdGltZTogITAsXG4gICAgICAgIHVybDogITAsXG4gICAgICAgIHdlZWs6ICEwXG4gICAgICB9LFxuICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbCxcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsLFxuICAgICAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gITE7XG4gICAgY2FuVXNlRE9NICYmXG4gICAgICAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkID1cbiAgICAgICAgaXNFdmVudFN1cHBvcnRlZChcImlucHV0XCIpICYmXG4gICAgICAgICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDkgPCBkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtcbiAgICB2YXIgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9XG4gICAgICAgIGNhblVzZURPTSAmJiBcImRvY3VtZW50TW9kZVwiIGluIGRvY3VtZW50ICYmIDExID49IGRvY3VtZW50LmRvY3VtZW50TW9kZSxcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsLFxuICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsLFxuICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGwsXG4gICAgICBtb3VzZURvd24gPSAhMSxcbiAgICAgIHZlbmRvclByZWZpeGVzID0ge1xuICAgICAgICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoXCJBbmltYXRpb25cIiwgXCJBbmltYXRpb25FbmRcIiksXG4gICAgICAgIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxcbiAgICAgICAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoXCJBbmltYXRpb25cIiwgXCJBbmltYXRpb25TdGFydFwiKSxcbiAgICAgICAgdHJhbnNpdGlvbnJ1bjogbWFrZVByZWZpeE1hcChcIlRyYW5zaXRpb25cIiwgXCJUcmFuc2l0aW9uUnVuXCIpLFxuICAgICAgICB0cmFuc2l0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblN0YXJ0XCIpLFxuICAgICAgICB0cmFuc2l0aW9uY2FuY2VsOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25DYW5jZWxcIiksXG4gICAgICAgIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvbkVuZFwiKVxuICAgICAgfSxcbiAgICAgIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9LFxuICAgICAgc3R5bGUgPSB7fTtcbiAgICBjYW5Vc2VET00gJiZcbiAgICAgICgoc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlKSxcbiAgICAgIFwiQW5pbWF0aW9uRXZlbnRcIiBpbiB3aW5kb3cgfHxcbiAgICAgICAgKGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uLFxuICAgICAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixcbiAgICAgICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXG4gICAgICBcIlRyYW5zaXRpb25FdmVudFwiIGluIHdpbmRvdyB8fFxuICAgICAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtcbiAgICB2YXIgQU5JTUFUSU9OX0VORCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwiYW5pbWF0aW9uZW5kXCIpLFxuICAgICAgQU5JTUFUSU9OX0lURVJBVElPTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLFxuICAgICAgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJhbmltYXRpb25zdGFydFwiKSxcbiAgICAgIFRSQU5TSVRJT05fUlVOID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJ0cmFuc2l0aW9ucnVuXCIpLFxuICAgICAgVFJBTlNJVElPTl9TVEFSVCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnN0YXJ0XCIpLFxuICAgICAgVFJBTlNJVElPTl9DQU5DRUwgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25jYW5jZWxcIiksXG4gICAgICBUUkFOU0lUSU9OX0VORCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbmVuZFwiKSxcbiAgICAgIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzID0gbmV3IE1hcCgpLFxuICAgICAgc2ltcGxlRXZlbnRQbHVnaW5FdmVudHMgPVxuICAgICAgICBcImFib3J0IGF1eENsaWNrIGJlZm9yZVRvZ2dsZSBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBnb3RQb2ludGVyQ2FwdHVyZSBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBsb3N0UG9pbnRlckNhcHR1cmUgbW91c2VEb3duIG1vdXNlTW92ZSBtb3VzZU91dCBtb3VzZU92ZXIgbW91c2VVcCBwYXN0ZSBwYXVzZSBwbGF5IHBsYXlpbmcgcG9pbnRlckNhbmNlbCBwb2ludGVyRG93biBwb2ludGVyTW92ZSBwb2ludGVyT3V0IHBvaW50ZXJPdmVyIHBvaW50ZXJVcCBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHJlc2l6ZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hTdGFydCB2b2x1bWVDaGFuZ2Ugc2Nyb2xsIHNjcm9sbEVuZCB0b2dnbGUgdG91Y2hNb3ZlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgT2Zmc2NyZWVuVmlzaWJsZSA9IDEsXG4gICAgICBPZmZzY3JlZW5EZXRhY2hlZCA9IDIsXG4gICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCA9IDQsXG4gICAgICBjb25jdXJyZW50UXVldWVzID0gW10sXG4gICAgICBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwLFxuICAgICAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gMCxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgcmVzb2x2ZUZhbWlseSA9IG51bGwsXG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbCxcbiAgICAgIE5vTW9kZSA9IDAsXG4gICAgICBDb25jdXJyZW50TW9kZSA9IDEsXG4gICAgICBQcm9maWxlTW9kZSA9IDIsXG4gICAgICBTdHJpY3RMZWdhY3lNb2RlID0gOCxcbiAgICAgIFN0cmljdEVmZmVjdHNNb2RlID0gMTYsXG4gICAgICBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSA9IDY0LFxuICAgICAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIHJlbmRlclN0YXJ0VGltZSA9IC0wLFxuICAgICAgY29tbWl0U3RhcnRUaW1lID0gLTAsXG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xLjEsXG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gLTAsXG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMSxcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExLFxuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gICAgICAgIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10sXG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKFxuICAgICAgZmliZXIsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkgfHxcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdKSk7XG4gICAgICBpZiAoMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplKSB7XG4gICAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lc1xuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcykpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICB9O1xuICAgIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCksXG4gICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKFxuICAgICAgZmliZXIsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgdmFyIHN0cmljdFJvb3QgPSBudWxsO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpYmVyOyBudWxsICE9PSBub2RlOyApXG4gICAgICAgIG5vZGUubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiYgKHN0cmljdFJvb3QgPSBub2RlKSxcbiAgICAgICAgICAobm9kZSA9IG5vZGUucmV0dXJuKTtcbiAgICAgIG51bGwgPT09IHN0cmljdFJvb3RcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKVxuICAgICAgICA6ICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICgobm9kZSA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCkpLFxuICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gbm9kZSAmJlxuICAgICAgICAgICAgKChub2RlID0gW10pLCBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIG5vZGUpKSxcbiAgICAgICAgICBub2RlLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSkge1xuICAgICAgICBpZiAoMCAhPT0gZmliZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF0sXG4gICAgICAgICAgICB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmlyc3RGaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS5cXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyB1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dFwiLFxuICAgICAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIHZhciBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmb3JrU3RhY2sgPSBbXSxcbiAgICAgIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUZvcmtDb3VudCA9IDAsXG4gICAgICBpZFN0YWNrID0gW10sXG4gICAgICBpZFN0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlQ29udGV4dElkID0gMSxcbiAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiLFxuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsLFxuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwsXG4gICAgICBpc0h5ZHJhdGluZyA9ICExLFxuICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSxcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCxcbiAgICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGwsXG4gICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEsXG4gICAgICBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIkh5ZHJhdGlvbiBNaXNtYXRjaCBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvIHVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKSxcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYFwiXG4gICAgICApLFxuICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBIGxpc3RlbmVyIHdhcyB1bmV4cGVjdGVkbHkgYXR0YWNoZWQgdG8gYSBcIm5vb3BcIiB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExLFxuICAgICAgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHZhciB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICAgICAgICBpc1JlbmRlcmluZyA9ICEwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmssIGluc3RhbmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWID0gY2FsbENvbXBvbmVudERpZE1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZE1vdW50KSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZSxcbiAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFViA9IGNhbGxDb21wb25lbnREaWRVcGRhdGVbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkVXBkYXRlKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlLCBlcnJvckluZm8pIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWID0gY2FsbENvbXBvbmVudERpZENhdGNoW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZENhdGNoKSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWID0gY2FsbENvbXBvbmVudFdpbGxVbm1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudFdpbGxVbm1vdW50KSxcbiAgICAgIGNhbGxDcmVhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcbiAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgICByZXR1cm4gKGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDcmVhdGVJbkRFViA9IGNhbGxDcmVhdGVbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ3JlYXRlKSxcbiAgICAgIGNhbGxEZXN0cm95ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxEZXN0cm95SW5ERVYgPVxuICAgICAgICBjYWxsRGVzdHJveVtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxEZXN0cm95KSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDAsXG4gICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dE1hcHM7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAoZGlkV2FybkFib3V0TWFwcyA9ICExKTtcbiAgICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nID0ge307XG4gICAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjaGlsZCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY2hpbGQgJiZcbiAgICAgICAgY2hpbGQuX3N0b3JlICYmXG4gICAgICAgICgoIWNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBjaGlsZC5rZXkpIHx8XG4gICAgICAgICAgMiA9PT0gY2hpbGQuX3N0b3JlLnZhbGlkYXRlZClcbiAgICAgICkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkLl9zdG9yZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlciksXG4gICAgICAgICAgY29tcG9uZW50S2V5ID0gY29tcG9uZW50TmFtZSB8fCBcIm51bGxcIjtcbiAgICAgICAgaWYgKCFvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSkge1xuICAgICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldID0gITA7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fb3duZXI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IFwiXCI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci50YWcgJiZcbiAgICAgICAgICAgIChjb21wb25lbnRLZXkgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSkgJiZcbiAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBjb21wb25lbnRLZXkgKyBcImAuXCIpO1xuICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gfHxcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRPd25lckFwcGVuZGl4ID0gXCJcIjtcbiAgICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gY2hpbGQgJiZcbiAgICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IG51bGwpLFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjaGlsZCkpXG4gICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkLm5hbWUgJiYgKGNvbXBvbmVudE5hbWUgPSBjaGlsZC5uYW1lKSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXJBcHBlbmRpeCA9XG4gICAgICAgICAgICAgICAgXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjb21wb25lbnROYW1lICsgXCIuXCIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVih3b3JrSW5Qcm9ncmVzcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLFxuICAgICAgICAgICAgICBjaGlsZE93bmVyQXBwZW5kaXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMCksXG4gICAgICBtb3VudENoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCExKSxcbiAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHNoZWxsQm91bmRhcnkgPSBudWxsLFxuICAgICAgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxLFxuICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMixcbiAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBOb0ZsYWdzID0gMCxcbiAgICAgIEhhc0VmZmVjdCA9IDEsXG4gICAgICBJbnNlcnRpb24gPSAyLFxuICAgICAgTGF5b3V0ID0gNCxcbiAgICAgIFBhc3NpdmUgPSA4LFxuICAgICAgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgPyBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICh0aGlzLnNpZ25hbCA9IHtcbiAgICAgICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQyID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIENhY2hlQ29udGV4dCA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyMjogbnVsbFxuICAgICAgfSxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsLFxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsLFxuICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiAmJlxuICAgICAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciByZW5kZXJMYW5lcyA9IDAsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMSxcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGdsb2JhbENsaWVudElkQ291bnRlciA9IDAsXG4gICAgICBSRV9SRU5ERVJfTElNSVQgPSAyNSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xLFxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICB2YXIgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGxhc3RFZmZlY3Q6IG51bGwsIGV2ZW50czogbnVsbCwgc3RvcmVzOiBudWxsLCBtZW1vQ2FjaGU6IG51bGwgfTtcbiAgICB9O1xuICAgIHZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSWQ6IHRocm93SW52YWxpZEhvb2tFcnJvclxuICAgIH07XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlTWVtb0NhY2hlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICB2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgdmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gb3duZXIgJiYgaXNSZW5kZXJpbmcgJiYgMSA9PT0gb3duZXIudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBvd25lci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gcmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCBuZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyByZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSB8fCBcIkEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKGNvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHMpXG4gICAgICAgICAgICA/IGdldE5lYXJlc3RNb3VudGVkRmliZXIoY29tcG9uZW50KSA9PT0gY29tcG9uZW50XG4gICAgICAgICAgICA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgY29tcG9uZW50TmFtZSA9IG51bGwsXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGwsXG4gICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3Mgc2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKSxcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbiAgICB2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgICAgICAgZGVoeWRyYXRlZDogbnVsbCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IG51bGwsXG4gICAgICAgIHJldHJ5TGFuZTogMFxuICAgICAgfSxcbiAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITEsXG4gICAgICB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyU2lnaWwgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsLFxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbCxcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMSxcbiAgICAgIFVwZGF0ZVN0YXRlID0gMCxcbiAgICAgIFJlcGxhY2VTdGF0ZSA9IDEsXG4gICAgICBGb3JjZVVwZGF0ZSA9IDIsXG4gICAgICBDYXB0dXJlVXBkYXRlID0gMyxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSAhMTtcbiAgICB2YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgICB2YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExLFxuICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSAhMSxcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSAhMSxcbiAgICAgIG5lZWRzRm9ybVJlc2V0ID0gITEsXG4gICAgICBQb3NzaWJseVdlYWtTZXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrU2V0ID8gV2Vha1NldCA6IFNldCxcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbCxcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExLFxuICAgICAgaG9zdFBhcmVudCA9IG51bGwsXG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMSxcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gbnVsbCxcbiAgICAgIHN1c3BlbnNleUNvbW1pdEZsYWcgPSA4MTkyO1xuICAgIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9ICExO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICB9IGNhdGNoIChlJDcpIHtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gITA7XG4gICAgfVxuICAgIHZhciBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAocmVzb3VyY2VUeXBlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCksXG4gICAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgICAgdm9pZCAwID09PSBjYWNoZUZvclR5cGUgJiZcbiAgICAgICAgICAoKGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpKSxcbiAgICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgICByZXR1cm4gY2FjaGVGb3JUeXBlO1xuICAgICAgfSxcbiAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gICAgICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLmNvbXBvbmVudFwiKTtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3NcIik7XG4gICAgICBzeW1ib2xGb3IoXCJzZWxlY3Rvci5yb2xlXCIpO1xuICAgICAgc3ltYm9sRm9yKFwic2VsZWN0b3IudGVzdF9pZFwiKTtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLnRleHRcIik7XG4gICAgfVxuICAgIHZhciBjb21taXRIb29rcyA9IFtdLFxuICAgICAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gICAgICBOb0NvbnRleHQgPSAwLFxuICAgICAgUmVuZGVyQ29udGV4dCA9IDIsXG4gICAgICBDb21taXRDb250ZXh0ID0gNCxcbiAgICAgIFJvb3RJblByb2dyZXNzID0gMCxcbiAgICAgIFJvb3RGYXRhbEVycm9yZWQgPSAxLFxuICAgICAgUm9vdEVycm9yZWQgPSAyLFxuICAgICAgUm9vdFN1c3BlbmRlZCA9IDMsXG4gICAgICBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNCxcbiAgICAgIFJvb3RDb21wbGV0ZWQgPSA1LFxuICAgICAgUm9vdERpZE5vdENvbXBsZXRlID0gNixcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwLFxuICAgICAgTm90U3VzcGVuZGVkID0gMCxcbiAgICAgIFN1c3BlbmRlZE9uRXJyb3IgPSAxLFxuICAgICAgU3VzcGVuZGVkT25EYXRhID0gMixcbiAgICAgIFN1c3BlbmRlZE9uSW1tZWRpYXRlID0gMyxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2UgPSA0LFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSA9IDUsXG4gICAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UgPSA2LFxuICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlID0gNyxcbiAgICAgIFN1c3BlbmRlZE9uSHlkcmF0aW9uID0gOCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMSxcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcyxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITEsXG4gICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMCxcbiAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5LFxuICAgICAgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCxcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGwsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwsXG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwLFxuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEsXG4gICAgICBJTU1FRElBVEVfQ09NTUlUID0gMCxcbiAgICAgIFNVU1BFTkRFRF9DT01NSVQgPSAxLFxuICAgICAgVEhST1RUTEVEX0NPTU1JVCA9IDIsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZmFrZUFjdENhbGxiYWNrTm9kZSQxID0ge30sXG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICExLFxuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITEsXG4gICAgICBpc0ZsdXNoaW5nV29yayA9ICExLFxuICAgICAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwLFxuICAgICAgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9O1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBzaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXSxcbiAgICAgICAgICBkb21FdmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudE5hbWUuc2xpY2UoMSk7XG4gICAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLCBcIm9uXCIgKyBldmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fRU5ELCBcIm9uQW5pbWF0aW9uRW5kXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fSVRFUkFUSU9OLCBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fU1RBUlQsIFwib25BbmltYXRpb25TdGFydFwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJkYmxjbGlja1wiLCBcIm9uRG91YmxlQ2xpY2tcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNpblwiLCBcIm9uRm9jdXNcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNvdXRcIiwgXCJvbkJsdXJcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fUlVOLCBcIm9uVHJhbnNpdGlvblJ1blwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9TVEFSVCwgXCJvblRyYW5zaXRpb25TdGFydFwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9DQU5DRUwsIFwib25UcmFuc2l0aW9uQ2FuY2VsXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0VORCwgXCJvblRyYW5zaXRpb25FbmRcIik7XG4gICAgfSkoKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Nb3VzZUVudGVyXCIsIFtcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Nb3VzZUxlYXZlXCIsIFtcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyRW50ZXJcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyTGVhdmVcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICBcImNoYW5nZSBjbGljayBmb2N1c2luIGZvY3Vzb3V0IGlucHV0IGtleWRvd24ga2V5dXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXG4gICAgICAgIFwiIFwiXG4gICAgICApXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uU2VsZWN0XCIsXG4gICAgICBcImZvY3Vzb3V0IGNvbnRleHRtZW51IGRyYWdlbmQgZm9jdXNpbiBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFxuICAgICAgICBcIiBcIlxuICAgICAgKVxuICAgICk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KFwib25CZWZvcmVJbnB1dFwiLCBbXG4gICAgICBcImNvbXBvc2l0aW9uZW5kXCIsXG4gICAgICBcImtleXByZXNzXCIsXG4gICAgICBcInRleHRJbnB1dFwiLFxuICAgICAgXCJwYXN0ZVwiXG4gICAgXSk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICAgICAgXCJvbkNvbXBvc2l0aW9uRW5kXCIsXG4gICAgICBcImNvbXBvc2l0aW9uZW5kIGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuICAgICAgXCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgICAgIFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIilcbiAgICApO1xuICAgIHZhciBtZWRpYUV2ZW50VHlwZXMgPVxuICAgICAgICBcImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2UgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgIG5vbkRlbGVnYXRlZEV2ZW50cyA9IG5ldyBTZXQoXG4gICAgICAgIFwiYmVmb3JldG9nZ2xlIGNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHNjcm9sbGVuZCB0b2dnbGVcIlxuICAgICAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAuY29uY2F0KG1lZGlhRXZlbnRUeXBlcylcbiAgICAgICksXG4gICAgICBsaXN0ZW5pbmdNYXJrZXIgPSBcIl9yZWFjdExpc3RlbmluZ1wiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gITEsXG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITEsXG4gICAgICBkaWRXYXJuUG9wb3ZlclRhcmdldE9iamVjdCA9ICExO1xuICAgIHZhciBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWUgPSB7fTtcbiAgICB2YXIgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9ICEwO1xuICAgIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nLFxuICAgICAgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nLFxuICAgICAgeGxpbmtOYW1lc3BhY2UgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgIHhtbE5hbWVzcGFjZSA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgICBFWFBFQ1RFRF9GT1JNX0FDVElPTl9VUkwgPVxuICAgICAgICBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBmb3JtIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuJylcIixcbiAgICAgIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgIFNVU1BFTlNFX1NUQVJUX0RBVEEgPSBcIiRcIixcbiAgICAgIFNVU1BFTlNFX0VORF9EQVRBID0gXCIvJFwiLFxuICAgICAgU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBID0gXCIkP1wiLFxuICAgICAgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSA9IFwiJCFcIixcbiAgICAgIEZPUk1fU1RBVEVfSVNfTUFUQ0hJTkcgPSBcIkYhXCIsXG4gICAgICBGT1JNX1NUQVRFX0lTX05PVF9NQVRDSElORyA9IFwiRlwiLFxuICAgICAgU1RZTEUgPSBcInN0eWxlXCIsXG4gICAgICBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmUgPSAwLFxuICAgICAgSG9zdENvbnRleHROYW1lc3BhY2VTdmcgPSAxLFxuICAgICAgSG9zdENvbnRleHROYW1lc3BhY2VNYXRoID0gMixcbiAgICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsLFxuICAgICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsLFxuICAgICAgd2FybmVkVW5rbm93blRhZ3MgPSB7IGRpYWxvZzogITAsIHdlYnZpZXc6ICEwIH0sXG4gICAgICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBudWxsLFxuICAgICAgc2NoZWR1bGVUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiB2b2lkIDAsXG4gICAgICBjYW5jZWxUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogdm9pZCAwLFxuICAgICAgbm9UaW1lb3V0ID0gLTEsXG4gICAgICBsb2NhbFByb21pc2UgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBQcm9taXNlID8gUHJvbWlzZSA6IHZvaWQgMCxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbG9jYWxQcm9taXNlXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFByb21pc2VcbiAgICAgICAgICAgICAgICAgIC5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHNjaGVkdWxlVGltZW91dCxcbiAgICAgIE5vdExvYWRlZCA9IDAsXG4gICAgICBMb2FkZWQgPSAxLFxuICAgICAgRXJyb3JlZCA9IDIsXG4gICAgICBTZXR0bGVkID0gMyxcbiAgICAgIEluc2VydGVkID0gNCxcbiAgICAgIHByZWxvYWRQcm9wc01hcCA9IG5ldyBNYXAoKSxcbiAgICAgIHByZWNvbm5lY3RzU2V0ID0gbmV3IFNldCgpLFxuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5kID0ge1xuICAgICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXNXYXNSZW5kZXJpbmcgPSBwcmV2aW91c0Rpc3BhdGNoZXIuZigpLFxuICAgICAgICAgIHdhc1JlbmRlcmluZyA9IGZsdXNoU3luY1dvcmskMSgpO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNXYXNSZW5kZXJpbmcgfHwgd2FzUmVuZGVyaW5nO1xuICAgICAgfSxcbiAgICAgIHI6IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICAgIHZhciBmb3JtSW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZm9ybSk7XG4gICAgICAgIG51bGwgIT09IGZvcm1JbnN0ICYmIDUgPT09IGZvcm1JbnN0LnRhZyAmJiBcImZvcm1cIiA9PT0gZm9ybUluc3QudHlwZVxuICAgICAgICAgID8gcmVxdWVzdEZvcm1SZXNldCQxKGZvcm1JbnN0KVxuICAgICAgICAgIDogcHJldmlvdXNEaXNwYXRjaGVyLnIoZm9ybSk7XG4gICAgICB9LFxuICAgICAgRDogZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gICAgICAgIHByZWNvbm5lY3RBcyhcImRucy1wcmVmZXRjaFwiLCBocmVmLCBudWxsKTtcbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiAoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICAgICAgICBwcmVjb25uZWN0QXMoXCJwcmVjb25uZWN0XCIsIGhyZWYsIGNyb3NzT3JpZ2luKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbiAoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmICYmIGFzKSB7XG4gICAgICAgICAgdmFyIHByZWxvYWRTZWxlY3RvciA9XG4gICAgICAgICAgICAnbGlua1tyZWw9XCJwcmVsb2FkXCJdW2FzPVwiJyArXG4gICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGFzKSArXG4gICAgICAgICAgICAnXCJdJztcbiAgICAgICAgICBcImltYWdlXCIgPT09IGFzXG4gICAgICAgICAgICA/IG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgICA/ICgocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAgICAgICAnW2ltYWdlc3Jjc2V0PVwiJyArXG4gICAgICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICdcIl0nKSxcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzICYmXG4gICAgICAgICAgICAgICAgICAocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAgICAgICAgICdbaW1hZ2VzaXplcz1cIicgK1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1hZ2VTaXplc1xuICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiXScpKVxuICAgICAgICAgICAgICA6IChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArXG4gICAgICAgICAgICAgICAgICAnXCJdJylcbiAgICAgICAgICAgIDogKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAgICAgICAgICdcIl0nKTtcbiAgICAgICAgICB2YXIga2V5ID0gcHJlbG9hZFNlbGVjdG9yO1xuICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICBrZXkgPSBnZXRTdHlsZUtleShocmVmKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIGtleSA9IGdldFNjcmlwdEtleShocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlbG9hZFByb3BzTWFwLmhhcyhrZXkpIHx8XG4gICAgICAgICAgICAoKGhyZWYgPSBhc3NpZ24oXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgIGhyZWY6XG4gICAgICAgICAgICAgICAgICBcImltYWdlXCIgPT09IGFzICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IGhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcHJlbG9hZFByb3BzTWFwLnNldChrZXksIGhyZWYpLFxuICAgICAgICAgICAgbnVsbCAhPT0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHByZWxvYWRTZWxlY3RvcikgfHxcbiAgICAgICAgICAgICAgKFwic3R5bGVcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSlcbiAgICAgICAgICAgICAgICApKSB8fFxuICAgICAgICAgICAgICAoXCJzY3JpcHRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSkpKSB8fFxuICAgICAgICAgICAgICAoKGFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGFzLCBcImxpbmtcIiwgaHJlZiksXG4gICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoYXMpLFxuICAgICAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoYXMpKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIubShocmVmLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgaHJlZikge1xuICAgICAgICAgIHZhciBhcyA9XG4gICAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIixcbiAgICAgICAgICAgIHByZWxvYWRTZWxlY3RvciA9XG4gICAgICAgICAgICAgICdsaW5rW3JlbD1cIm1vZHVsZXByZWxvYWRcIl1bYXM9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhhcykgK1xuICAgICAgICAgICAgICAnXCJdW2hyZWY9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArXG4gICAgICAgICAgICAgICdcIl0nLFxuICAgICAgICAgICAga2V5ID0gcHJlbG9hZFNlbGVjdG9yO1xuICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhdWRpb3dvcmtsZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwYWludHdvcmtsZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZXJ2aWNld29ya2VyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2hhcmVkd29ya2VyXCI6XG4gICAgICAgICAgICBjYXNlIFwid29ya2VyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIGtleSA9IGdldFNjcmlwdEtleShocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXByZWxvYWRQcm9wc01hcC5oYXMoa2V5KSAmJlxuICAgICAgICAgICAgKChocmVmID0gYXNzaWduKHsgcmVsOiBcIm1vZHVsZXByZWxvYWRcIiwgaHJlZjogaHJlZiB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICBwcmVsb2FkUHJvcHNNYXAuc2V0KGtleSwgaHJlZiksXG4gICAgICAgICAgICBudWxsID09PSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocHJlbG9hZFNlbGVjdG9yKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImF1ZGlvd29ya2xldFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGFpbnR3b3JrbGV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZXJ2aWNld29ya2VyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzaGFyZWR3b3JrZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIndvcmtlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhhcywgXCJsaW5rXCIsIGhyZWYpO1xuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShhcyk7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFg6IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgc3JjKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTY3JpcHRzLFxuICAgICAgICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KHNyYyksXG4gICAgICAgICAgICByZXNvdXJjZSA9IHNjcmlwdHMuZ2V0KGtleSk7XG4gICAgICAgICAgcmVzb3VyY2UgfHxcbiAgICAgICAgICAgICgocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHJlc291cmNlIHx8XG4gICAgICAgICAgICAgICgoc3JjID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSksXG4gICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUocmVzb3VyY2UpLFxuICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhyZXNvdXJjZSwgXCJsaW5rXCIsIHNyYyksXG4gICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChyZXNvdXJjZSkpLFxuICAgICAgICAgICAgKHJlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzY3JpcHRzLnNldChrZXksIHJlc291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbiAoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuUyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgaHJlZikge1xuICAgICAgICAgIHZhciBzdHlsZXMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTdHlsZXMsXG4gICAgICAgICAgICBrZXkgPSBnZXRTdHlsZUtleShocmVmKTtcbiAgICAgICAgICBwcmVjZWRlbmNlID0gcHJlY2VkZW5jZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBzdHlsZXMuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0geyBsb2FkaW5nOiBOb3RMb2FkZWQsIHByZWxvYWQ6IG51bGwgfTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gTG9hZGVkIHwgSW5zZXJ0ZWQ7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaHJlZiA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZWw6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGhyZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB2YXIgbGluayA9IChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpO1xuICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGxpbmspO1xuICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhsaW5rLCBcImxpbmtcIiwgaHJlZik7XG4gICAgICAgICAgICAgIGxpbmsuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgbGluay5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIGxpbmsub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgfD0gTG9hZGVkO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgfD0gRXJyb3JlZDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgfD0gSW5zZXJ0ZWQ7XG4gICAgICAgICAgICAgIGluc2VydFN0eWxlc2hlZXQocmVzb3VyY2UsIHByZWNlZGVuY2UsIG93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdHlsZXMuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLk0oc3JjLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgc3JjKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTY3JpcHRzLFxuICAgICAgICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KHNyYyksXG4gICAgICAgICAgICByZXNvdXJjZSA9IHNjcmlwdHMuZ2V0KGtleSk7XG4gICAgICAgICAgcmVzb3VyY2UgfHxcbiAgICAgICAgICAgICgocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHJlc291cmNlIHx8XG4gICAgICAgICAgICAgICgoc3JjID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCwgdHlwZTogXCJtb2R1bGVcIiB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSksXG4gICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUocmVzb3VyY2UpLFxuICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhyZXNvdXJjZSwgXCJsaW5rXCIsIHNyYyksXG4gICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChyZXNvdXJjZSkpLFxuICAgICAgICAgICAgKHJlc291cmNlID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzY3JpcHRzLnNldChrZXksIHJlc291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnbG9iYWxEb2N1bWVudCA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBkb2N1bWVudCA/IG51bGwgOiBkb2N1bWVudCxcbiAgICAgIHRhZ0NhY2hlcyA9IG51bGwsXG4gICAgICBzdXNwZW5kZWRTdGF0ZSA9IG51bGwsXG4gICAgICBMQVNUX1BSRUNFREVOQ0UgPSBudWxsLFxuICAgICAgcHJlY2VkZW5jZXNCeVJvb3QgPSBudWxsLFxuICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24gPSBOb3RQZW5kaW5nLFxuICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIF90aHJlYWRDb3VudDogMFxuICAgICAgfSxcbiAgICAgIGJhZGdlRm9ybWF0ID0gXCIlYyVzJWMgXCIsXG4gICAgICBiYWRnZVN0eWxlID1cbiAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgIHJlc2V0U3R5bGUgPSBcIlwiLFxuICAgICAgcGFkID0gXCIgXCIsXG4gICAgICBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG4gICAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSAhMTtcbiAgICB2YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbCxcbiAgICAgIHNjaGVkdWxlVXBkYXRlID0gbnVsbCxcbiAgICAgIHNldEVycm9ySGFuZGxlciA9IG51bGwsXG4gICAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuICAgIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoU2V0SW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwLCB2YWx1ZSkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aERlbGV0ZUltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKG9sZFBhdGggPSBjb3B5V2l0aFJlbmFtZShpZC5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldEltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCwgdmFsdWUpO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlSW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgbmV3UGF0aFxuICAgICAgKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gICAgfTtcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gICAgfTtcbiAgICB2YXIgX2VuYWJsZWQgPSAhMCxcbiAgICAgIHJldHVybl90YXJnZXRJbnN0ID0gbnVsbCxcbiAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSAhMSxcbiAgICAgIHF1ZXVlZEZvY3VzID0gbnVsbCxcbiAgICAgIHF1ZXVlZERyYWcgPSBudWxsLFxuICAgICAgcXVldWVkTW91c2UgPSBudWxsLFxuICAgICAgcXVldWVkUG9pbnRlcnMgPSBuZXcgTWFwKCksXG4gICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCksXG4gICAgICBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMgPSBbXSxcbiAgICAgIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyA9XG4gICAgICAgIFwibW91c2Vkb3duIG1vdXNldXAgdG91Y2hjYW5jZWwgdG91Y2hlbmQgdG91Y2hzdGFydCBhdXhjbGljayBkYmxjbGljayBwb2ludGVyY2FuY2VsIHBvaW50ZXJkb3duIHBvaW50ZXJ1cCBkcmFnZW5kIGRyYWdzdGFydCBkcm9wIGNvbXBvc2l0aW9uZW5kIGNvbXBvc2l0aW9uc3RhcnQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dCB0ZXh0SW5wdXQgY29weSBjdXQgcGFzdGUgY2xpY2sgY2hhbmdlIGNvbnRleHRtZW51IHJlc2V0XCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnJlbmRlciA9XG4gICAgICBmdW5jdGlvbiAoY2hpbGRyZW4sIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMikge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgICAgICAgaWYgKG51bGwgPT09IHJvb3QpIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBhbiB1bm1vdW50ZWQgcm9vdC5cIik7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMlxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBpc1ZhbGlkQ29udGFpbmVyKEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMilcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBwYXNzZWQgYSBjb250YWluZXIgdG8gdGhlIHNlY29uZCBhcmd1bWVudCBvZiByb290LnJlbmRlciguLi4pLiBZb3UgZG9uJ3QgbmVlZCB0byBwYXNzIGl0IGFnYWluIHNpbmNlIHlvdSBhbHJlYWR5IHBhc3NlZCBpdCB0byBjcmVhdGUgdGhlIHJvb3QuXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AyICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgcGFzc2VkIGEgc2Vjb25kIGFyZ3VtZW50IHRvIHJvb3QucmVuZGVyKC4uLikgYnV0IGl0IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AyID0gcm9vdC5jdXJyZW50O1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMik7XG4gICAgICAgIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AyLFxuICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bm1vdW50ID0gUmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50ID1cbiAgICAgIGZ1bmN0aW9uIChKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDMpIHtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMyA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgICAgICAgaWYgKG51bGwgIT09IEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMykge1xuICAgICAgICAgIHRoaXMuX2ludGVybmFsUm9vdCA9IG51bGw7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMy5jb250YWluZXJJbmZvO1xuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBdHRlbXB0ZWQgdG8gc3luY2hyb25vdXNseSB1bm1vdW50IGEgcm9vdCB3aGlsZSBSZWFjdCB3YXMgYWxyZWFkeSByZW5kZXJpbmcuIFJlYWN0IGNhbm5vdCBmaW5pc2ggdW5tb3VudGluZyB0aGUgcm9vdCB1bnRpbCB0aGUgY3VycmVudCByZW5kZXIgaGFzIGNvbXBsZXRlZCwgd2hpY2ggbWF5IGxlYWQgdG8gYSByYWNlIGNvbmRpdGlvbi5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVDb250YWluZXJTeW5jKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgICAgICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIFJlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUudW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb24gPSBmdW5jdGlvbiAoXG4gICAgICB0YXJnZXRcbiAgICApIHtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgIHRhcmdldCA9IHsgYmxvY2tlZE9uOiBudWxsLCB0YXJnZXQ6IHRhcmdldCwgcHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5IH07XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIGkgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoICYmXG4gICAgICAgICAgMCAhPT0gdXBkYXRlUHJpb3JpdHkgJiZcbiAgICAgICAgICB1cGRhdGVQcmlvcml0eSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eTtcbiAgICAgICAgICBpKytcbiAgICAgICAgKTtcbiAgICAgICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNwbGljZShpLCAwLCB0YXJnZXQpO1xuICAgICAgICAwID09PSBpICYmIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiA9IFJlYWN0LnZlcnNpb247XG4gICAgICBpZiAoXCIxOS4wLjBcIiAhPT0gaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdJbmNvbXBhdGlibGUgUmVhY3QgdmVyc2lvbnM6IFRoZSBcInJlYWN0XCIgYW5kIFwicmVhY3QtZG9tXCIgcGFja2FnZXMgbXVzdCBoYXZlIHRoZSBleGFjdCBzYW1lIHZlcnNpb24uIEluc3RlYWQgZ290OlxcbiAgLSByZWFjdDogICAgICAnICtcbiAgICAgICAgICAgIChpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiArXG4gICAgICAgICAgICAgIFwiXFxuICAtIHJlYWN0LWRvbTogIDE5LjAuMFxcbkxlYXJuIG1vcmU6IGh0dHBzOi8vcmVhY3QuZGV2L3dhcm5pbmdzL3ZlcnNpb24tbWlzbWF0Y2hcIilcbiAgICAgICAgKTtcbiAgICB9KSgpO1xuICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBNYXAgJiZcbiAgICAgIG51bGwgIT0gTWFwLnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQgJiZcbiAgICAgIG51bGwgIT0gU2V0LnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoKSB8fFxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LXBvbHlmaWxsc1wiXG4gICAgICApO1xuICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmZpbmRET01Ob2RlID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50T3JFbGVtZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50T3JFbGVtZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArXG4gICAgICAgICAgICBjb21wb25lbnRPckVsZW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudE9yRWxlbWVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgICAgIGNvbXBvbmVudE9yRWxlbWVudCA9XG4gICAgICAgIG51bGwgIT09IGNvbXBvbmVudE9yRWxlbWVudFxuICAgICAgICAgID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGNvbXBvbmVudE9yRWxlbWVudClcbiAgICAgICAgICA6IG51bGw7XG4gICAgICBjb21wb25lbnRPckVsZW1lbnQgPVxuICAgICAgICBudWxsID09PSBjb21wb25lbnRPckVsZW1lbnQgPyBudWxsIDogY29tcG9uZW50T3JFbGVtZW50LnN0YXRlTm9kZTtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfTtcbiAgICBpZiAoXG4gICAgICAhKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGludGVybmFscyA9IHtcbiAgICAgICAgICBidW5kbGVUeXBlOiAxLFxuICAgICAgICAgIHZlcnNpb246IFwiMTkuMC4wXCIsXG4gICAgICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogXCJyZWFjdC1kb21cIixcbiAgICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RTaGFyZWRJbnRlcm5hbHMsXG4gICAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgICAgIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG4gICAgICAgIH07XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZSA9IG92ZXJyaWRlSG9va1N0YXRlO1xuICAgICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoO1xuICAgICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoO1xuICAgICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wcyA9IG92ZXJyaWRlUHJvcHM7XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoO1xuICAgICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDtcbiAgICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlVXBkYXRlID0gc2NoZWR1bGVVcGRhdGU7XG4gICAgICAgIGludGVybmFscy5zZXRFcnJvckhhbmRsZXIgPSBzZXRFcnJvckhhbmRsZXI7XG4gICAgICAgIGludGVybmFscy5zZXRTdXNwZW5zZUhhbmRsZXIgPSBzZXRTdXNwZW5zZUhhbmRsZXI7XG4gICAgICAgIGludGVybmFscy5zY2hlZHVsZVJlZnJlc2ggPSBzY2hlZHVsZVJlZnJlc2g7XG4gICAgICAgIGludGVybmFscy5zY2hlZHVsZVJvb3QgPSBzY2hlZHVsZVJvb3Q7XG4gICAgICAgIGludGVybmFscy5zZXRSZWZyZXNoSGFuZGxlciA9IHNldFJlZnJlc2hIYW5kbGVyO1xuICAgICAgICBpbnRlcm5hbHMuZ2V0Q3VycmVudEZpYmVyID0gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHM7XG4gICAgICAgIGludGVybmFscy5nZXRMYW5lTGFiZWxNYXAgPSBnZXRMYW5lTGFiZWxNYXA7XG4gICAgICAgIGludGVybmFscy5pbmplY3RQcm9maWxpbmdIb29rcyA9IGluamVjdFByb2ZpbGluZ0hvb2tzO1xuICAgICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscyk7XG4gICAgICB9KSgpICYmXG4gICAgICBjYW5Vc2VET00gJiZcbiAgICAgIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmICYmXG4gICAgICAoKC0xIDwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpICYmXG4gICAgICAgIC0xID09PSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJFZGdlXCIpKSB8fFxuICAgICAgICAtMSA8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikpXG4gICAgKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkgJiZcbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgIFwiJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHNcIiArXG4gICAgICAgICAgICAoXCJmaWxlOlwiID09PSBwcm90b2NvbFxuICAgICAgICAgICAgICA/IFwiXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxXCJcbiAgICAgICAgICAgICAgOiBcIlwiKSxcbiAgICAgICAgICBcImZvbnQtd2VpZ2h0OmJvbGRcIlxuICAgICAgICApO1xuICAgIH1cbiAgICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiKTtcbiAgICAgIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKTtcbiAgICAgIHZhciBpc1N0cmljdE1vZGUgPSAhMSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IFwiXCIsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvciA9IGRlZmF1bHRPblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yID0gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG51bGw7XG4gICAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICAob3B0aW9ucy5oeWRyYXRlXG4gICAgICAgICAgPyBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiaHlkcmF0ZSB0aHJvdWdoIGNyZWF0ZVJvb3QgaXMgZGVwcmVjYXRlZC4gVXNlIFJlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPikgaW5zdGVhZC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICAgICAgICAgIG51bGwgIT09IG9wdGlvbnMgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcGFzc2VkIGEgSlNYIGVsZW1lbnQgdG8gY3JlYXRlUm9vdC4gWW91IHByb2JhYmx5IG1lYW50IHRvIGNhbGwgcm9vdC5yZW5kZXIgaW5zdGVhZC4gRXhhbXBsZSB1c2FnZTpcXG5cXG4gIGxldCByb290ID0gY3JlYXRlUm9vdChkb21Db250YWluZXIpO1xcbiAgcm9vdC5yZW5kZXIoPEFwcCAvPik7XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggJiZcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgICAgICAob25VbmNhdWdodEVycm9yID0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMub25DYXVnaHRFcnJvciAmJlxuICAgICAgICAgIChvbkNhdWdodEVycm9yID0gb3B0aW9ucy5vbkNhdWdodEVycm9yKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciAmJlxuICAgICAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzICYmXG4gICAgICAgICAgKHRyYW5zaXRpb25DYWxsYmFja3MgPSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MpKTtcbiAgICAgIG9wdGlvbnMgPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgMSxcbiAgICAgICAgITEsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBvcHRpb25zLmN1cnJlbnQ7XG4gICAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhcbiAgICAgICAgOCA9PT0gY29udGFpbmVyLm5vZGVUeXBlID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0RE9NUm9vdChvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIpO1xuICAgICAgd2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpO1xuICAgICAgdm9pZCAwID09PSBpbml0aWFsQ2hpbGRyZW4gJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIk11c3QgcHJvdmlkZSBpbml0aWFsIGNoaWxkcmVuIGFzIHNlY29uZCBhcmd1bWVudCB0byBoeWRyYXRlUm9vdC4gRXhhbXBsZSB1c2FnZTogaHlkcmF0ZVJvb3QoZG9tQ29udGFpbmVyLCA8QXBwIC8+KVwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaXNTdHJpY3RNb2RlID0gITEsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIlwiLFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MgPSBudWxsLFxuICAgICAgICBmb3JtU3RhdGUgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiZcbiAgICAgICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggJiZcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgICAgICAob25VbmNhdWdodEVycm9yID0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMub25DYXVnaHRFcnJvciAmJlxuICAgICAgICAgIChvbkNhdWdodEVycm9yID0gb3B0aW9ucy5vbkNhdWdodEVycm9yKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciAmJlxuICAgICAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzICYmXG4gICAgICAgICAgKHRyYW5zaXRpb25DYWxsYmFja3MgPSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMuZm9ybVN0YXRlICYmIChmb3JtU3RhdGUgPSBvcHRpb25zLmZvcm1TdGF0ZSkpO1xuICAgICAgaW5pdGlhbENoaWxkcmVuID0gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIDEsXG4gICAgICAgICEwLFxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIG51bGwgIT0gb3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgb3B0aW9ucyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgaXNTdHJpY3RNb2RlID0gcmVxdWVzdFVwZGF0ZUxhbmUob3B0aW9ucyk7XG4gICAgICBpZGVudGlmaWVyUHJlZml4ID0gY3JlYXRlVXBkYXRlKGlzU3RyaWN0TW9kZSk7XG4gICAgICBpZGVudGlmaWVyUHJlZml4LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGVucXVldWVVcGRhdGUob3B0aW9ucywgaWRlbnRpZmllclByZWZpeCwgaXNTdHJpY3RNb2RlKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gaXNTdHJpY3RNb2RlO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5pdGlhbENoaWxkcmVuLCBpc1N0cmljdE1vZGUpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBpbml0aWFsQ2hpbGRyZW4uY3VycmVudDtcbiAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbml0aWFsQ2hpbGRyZW4pO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4wLjBcIjtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIGtleVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgICAga2V5LmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgICAgICBrZXk6IG51bGwgPT0ga2V5ID8gbnVsbCA6IFwiXCIgKyBrZXksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBpbnB1dCkge1xuICAgICAgaWYgKFwiZm9udFwiID09PSBhcykgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KVxuICAgICAgICByZXR1cm4gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gaW5wdXQgPyBpbnB1dCA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgICAgIHJldHVybiBudWxsID09PSB0aGluZ1xuICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgOiB2b2lkIDAgPT09IHRoaW5nXG4gICAgICAgICAgPyBcImB1bmRlZmluZWRgXCJcbiAgICAgICAgICA6IFwiXCIgPT09IHRoaW5nXG4gICAgICAgICAgICA/IFwiYW4gZW1wdHkgc3RyaW5nXCJcbiAgICAgICAgICAgIDogJ3NvbWV0aGluZyB3aXRoIHR5cGUgXCInICsgdHlwZW9mIHRoaW5nICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcodGhpbmcpIHtcbiAgICAgIHJldHVybiBudWxsID09PSB0aGluZ1xuICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgOiB2b2lkIDAgPT09IHRoaW5nXG4gICAgICAgICAgPyBcImB1bmRlZmluZWRgXCJcbiAgICAgICAgICA6IFwiXCIgPT09IHRoaW5nXG4gICAgICAgICAgICA/IFwiYW4gZW1wdHkgc3RyaW5nXCJcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoaW5nXG4gICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodGhpbmcpXG4gICAgICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRoaW5nXG4gICAgICAgICAgICAgICAgPyBcImBcIiArIHRoaW5nICsgXCJgXCJcbiAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiB0aGluZyArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBJbnRlcm5hbHMgPSB7XG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBmOiBub29wLFxuICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZm9ybSBlbGVtZW50LiByZXF1ZXN0Rm9ybVJlc2V0IG11c3QgYmUgcGFzc2VkIGEgZm9ybSB0aGF0IHdhcyByZW5kZXJlZCBieSBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIEQ6IG5vb3AsXG4gICAgICAgICAgQzogbm9vcCxcbiAgICAgICAgICBMOiBub29wLFxuICAgICAgICAgIG06IG5vb3AsXG4gICAgICAgICAgWDogbm9vcCxcbiAgICAgICAgICBTOiBub29wLFxuICAgICAgICAgIE06IG5vb3BcbiAgICAgICAgfSxcbiAgICAgICAgcDogMCxcbiAgICAgICAgZmluZERPTU5vZGU6IG51bGxcbiAgICAgIH0sXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcbiAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgTWFwICYmXG4gICAgICBudWxsICE9IE1hcC5wcm90b3R5cGUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0ICYmXG4gICAgICBudWxsICE9IFNldC5wcm90b3R5cGUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCkgfHxcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxsc1wiXG4gICAgICApO1xuICAgIGV4cG9ydHMuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgICAgIEludGVybmFscztcbiAgICBleHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gICAgICB2YXIga2V5ID1cbiAgICAgICAgMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgaWYgKFxuICAgICAgICAhY29udGFpbmVyIHx8XG4gICAgICAgICgxICE9PSBjb250YWluZXIubm9kZVR5cGUgJiZcbiAgICAgICAgICA5ICE9PSBjb250YWluZXIubm9kZVR5cGUgJiZcbiAgICAgICAgICAxMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlKVxuICAgICAgKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoU3luYyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZpb3VzVHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzVXBkYXRlUHJpb3JpdHkgPSBJbnRlcm5hbHMucDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgKEludGVybmFscy5wID0gMiksIGZuKSlcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldmlvdXNUcmFuc2l0aW9uKSxcbiAgICAgICAgICAoSW50ZXJuYWxzLnAgPSBwcmV2aW91c1VwZGF0ZVByaW9yaXR5KSxcbiAgICAgICAgICBJbnRlcm5hbHMuZC5mKCkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBSZWFjdCBjYW5ub3QgZmx1c2ggd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgY2FsbCB0byBhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suXCJcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWNvbm5lY3QgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZlxuICAgICAgICA/IG51bGwgIT0gb3B0aW9ucyAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVjb25uZWN0KCk6IEV4cGVjdGVkIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgKHNlY29uZCkgdG8gYmUgYW4gb2JqZWN0IGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBUaGUgb25seSBzdXBwb3J0ZWQgb3B0aW9uIGF0IHRoaXMgdGltZSBpcyBgY3Jvc3NPcmlnaW5gIHdoaWNoIGFjY2VwdHMgYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBudWxsICE9IG9wdGlvbnMgJiZcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBjcm9zc09yaWdpbmAgb3B0aW9uIChzZWNvbmQgYXJndW1lbnQpIHRvIGJlIGEgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBUcnkgcmVtb3ZpbmcgdGhpcyBvcHRpb24gb3IgcGFzc2luZyBhIHN0cmluZyB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMuY3Jvc3NPcmlnaW4pXG4gICAgICAgICAgICApXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKVxuICAgICAgICAgICk7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAob3B0aW9uc1xuICAgICAgICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5jcm9zc09yaWdpbiksXG4gICAgICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgIDogdm9pZCAwKSlcbiAgICAgICAgICA6IChvcHRpb25zID0gbnVsbCksXG4gICAgICAgIEludGVybmFscy5kLkMoaHJlZiwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcmVmZXRjaEROUyA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHwgIWhyZWYpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZilcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KFwiY3Jvc3NPcmlnaW5cIilcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlZmV0Y2hETlMoKTogRXhwZWN0ZWQgb25seSBvbmUgYXJndW1lbnQsIGBocmVmYCwgYnV0IGVuY291bnRlcmVkICVzIGFzIGEgc2Vjb25kIGFyZ3VtZW50IGluc3RlYWQuIFRoaXMgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSBvcHRpb25zIGFuZCBpcyBjdXJyZW50bHkgZGlzYWxsb3dlZC4gSXQgbG9va3MgbGlrZSB0aGUgeW91IGFyZSBhdHRlbXB0aW5nIHRvIHNldCBhIGNyb3NzT3JpZ2luIHByb3BlcnR5IGZvciB0aGlzIEROUyBsb29rdXAgaGludC4gQnJvd3NlcnMgZG8gbm90IHBlcmZvcm0gRE5TIHF1ZXJpZXMgdXNpbmcgQ09SUyBhbmQgc2V0dGluZyB0aGlzIGF0dHJpYnV0ZSBvbiB0aGUgcmVzb3VyY2UgaGludCBoYXMgbm8gZWZmZWN0LiBUcnkgY2FsbGluZyBSZWFjdERPTS5wcmVmZXRjaEROUygpIHdpdGgganVzdCBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQsIGBocmVmYC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlZmV0Y2hETlMoKTogRXhwZWN0ZWQgb25seSBvbmUgYXJndW1lbnQsIGBocmVmYCwgYnV0IGVuY291bnRlcmVkICVzIGFzIGEgc2Vjb25kIGFyZ3VtZW50IGluc3RlYWQuIFRoaXMgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSBvcHRpb25zIGFuZCBpcyBjdXJyZW50bHkgZGlzYWxsb3dlZC4gVHJ5IGNhbGxpbmcgUmVhY3RET00ucHJlZmV0Y2hETlMoKSB3aXRoIGp1c3QgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50LCBgaHJlZmAuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgSW50ZXJuYWxzLmQuRChocmVmKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlaW5pdCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmXG4gICAgICAgID8gbnVsbCA9PSBvcHRpb25zIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgcmVzb3VyY2UgdG8gYmUgcHJlaW5pdGlhbGl6ZWQgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBcInN0eWxlXCIgIT09IG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAgIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdSZWFjdERPTS5wcmVpbml0KCk6IEV4cGVjdGVkIHRoZSBgYXNgIHByb3BlcnR5IGluIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgKHNlY29uZCkgdG8gY29udGFpbiBhIHZhbGlkIHZhbHVlIGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgcmVzb3VyY2UgdG8gYmUgcHJlaW5pdGlhbGl6ZWQgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFZhbGlkIHZhbHVlcyBmb3IgYGFzYCBhcmUgXCJzdHlsZVwiIGFuZCBcInNjcmlwdFwiLicsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMuYXMpXG4gICAgICAgICAgICApXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYGhyZWZgIGFyZ3VtZW50IChmaXJzdCkgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKVxuICAgICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIG9wdGlvbnMgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXNcbiAgICAgICkge1xuICAgICAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgICAgIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgb3B0aW9ucy5jcm9zc09yaWdpbiksXG4gICAgICAgICAgaW50ZWdyaXR5ID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHkgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICA/IG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgXCJzdHlsZVwiID09PSBhc1xuICAgICAgICAgID8gSW50ZXJuYWxzLmQuUyhcbiAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5wcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBpbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBcInNjcmlwdFwiID09PSBhcyAmJlxuICAgICAgICAgICAgSW50ZXJuYWxzLmQuWChocmVmLCB7XG4gICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgaW50ZWdyaXR5OiBpbnRlZ3JpdHksXG4gICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5wcmVpbml0TW9kdWxlID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlbmNvdW50ZXJlZCA9IFwiXCI7XG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikgfHxcbiAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgXCIgVGhlIGBocmVmYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgK1xuICAgICAgICAgIFwiLlwiKTtcbiAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucyAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICA/IChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zKSArXG4gICAgICAgICAgICBcIi5cIilcbiAgICAgICAgOiBvcHRpb25zICYmXG4gICAgICAgICAgXCJhc1wiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICBcInNjcmlwdFwiICE9PSBvcHRpb25zLmFzICYmXG4gICAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYGFzYCBvcHRpb24gZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMuYXMpICtcbiAgICAgICAgICAgIFwiLlwiKTtcbiAgICAgIGlmIChlbmNvdW50ZXJlZClcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnByZWluaXRNb2R1bGUoKTogRXhwZWN0ZWQgdXAgdG8gdHdvIGFyZ3VtZW50cywgYSBub24tZW1wdHkgYGhyZWZgIHN0cmluZyBhbmQsIG9wdGlvbmFsbHksIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCBhIHZhbGlkIGBhc2AgcHJvcGVydHkuJXNcIixcbiAgICAgICAgICBlbmNvdW50ZXJlZFxuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICgoZW5jb3VudGVyZWQgPVxuICAgICAgICAgICAgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyA/IG9wdGlvbnMuYXMgOiBcInNjcmlwdFwiKSxcbiAgICAgICAgICBlbmNvdW50ZXJlZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIChlbmNvdW50ZXJlZCA9XG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKGVuY291bnRlcmVkKSksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1JlYWN0RE9NLnByZWluaXRNb2R1bGUoKTogQ3VycmVudGx5IHRoZSBvbmx5IHN1cHBvcnRlZCBcImFzXCIgdHlwZSBmb3IgdGhpcyBmdW5jdGlvbiBpcyBcInNjcmlwdFwiIGJ1dCByZWNlaXZlZCBcIiVzXCIgaW5zdGVhZC4gVGhpcyB3YXJuaW5nIHdhcyBnZW5lcmF0ZWQgZm9yIGBocmVmYCBcIiVzXCIuIEluIHRoZSBmdXR1cmUgb3RoZXIgbW9kdWxlIHR5cGVzIHdpbGwgYmUgc3VwcG9ydGVkLCBhbGlnbmluZyB3aXRoIHRoZSBpbXBvcnQtYXR0cmlidXRlcyBwcm9wb3NhbC4gTGVhcm4gbW9yZSBoZXJlOiAoaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaW1wb3J0LWF0dHJpYnV0ZXMpJyxcbiAgICAgICAgICAgICAgICBlbmNvdW50ZXJlZCxcbiAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZilcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PSBvcHRpb25zLmFzIHx8IFwic2NyaXB0XCIgPT09IG9wdGlvbnMuYXMpXG4gICAgICAgICAgICAoZW5jb3VudGVyZWQgPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgICAgICBvcHRpb25zLmFzLFxuICAgICAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgSW50ZXJuYWxzLmQuTShocmVmLCB7XG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGVuY291bnRlcmVkLFxuICAgICAgICAgICAgICAgIGludGVncml0eTpcbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIG5vbmNlOlxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgbnVsbCA9PSBvcHRpb25zICYmIEludGVybmFscy5kLk0oaHJlZik7XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWxvYWQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGVuY291bnRlcmVkID0gXCJcIjtcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSArXG4gICAgICAgICAgXCIuXCIpO1xuICAgICAgbnVsbCA9PSBvcHRpb25zIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgID8gKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICtcbiAgICAgICAgICAgIFwiLlwiKVxuICAgICAgICA6IChcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyAmJiBvcHRpb25zLmFzKSB8fFxuICAgICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBhc2Agb3B0aW9uIGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMuYXMpICtcbiAgICAgICAgICAgIFwiLlwiKTtcbiAgICAgIGVuY291bnRlcmVkICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ1JlYWN0RE9NLnByZWxvYWQoKTogRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cywgYSBub24tZW1wdHkgYGhyZWZgIHN0cmluZyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIGFuIGBhc2AgcHJvcGVydHkgdmFsaWQgZm9yIGEgYDxsaW5rIHJlbD1cInByZWxvYWRcIiBhcz1cIi4uLlwiIC8+YCB0YWcuJXMnLFxuICAgICAgICAgIGVuY291bnRlcmVkXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmXG4gICAgICAgIG51bGwgIT09IG9wdGlvbnMgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXNcbiAgICAgICkge1xuICAgICAgICBlbmNvdW50ZXJlZCA9IG9wdGlvbnMuYXM7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgZW5jb3VudGVyZWQsXG4gICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICApO1xuICAgICAgICBJbnRlcm5hbHMuZC5MKGhyZWYsIGVuY291bnRlcmVkLCB7XG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgIGludGVncml0eTpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMudHlwZSA/IG9wdGlvbnMudHlwZSA6IHZvaWQgMCxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICA/IG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICByZWZlcnJlclBvbGljeTpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICBpbWFnZVNyY1NldDpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICBpbWFnZVNpemVzOlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW1hZ2VTaXplc1xuICAgICAgICAgICAgICA/IG9wdGlvbnMuaW1hZ2VTaXplc1xuICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICBtZWRpYTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubWVkaWEgPyBvcHRpb25zLm1lZGlhIDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5wcmVsb2FkTW9kdWxlID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlbmNvdW50ZXJlZCA9IFwiXCI7XG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikgfHxcbiAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgXCIgVGhlIGBocmVmYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgK1xuICAgICAgICAgIFwiLlwiKTtcbiAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucyAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICA/IChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zKSArXG4gICAgICAgICAgICBcIi5cIilcbiAgICAgICAgOiBvcHRpb25zICYmXG4gICAgICAgICAgXCJhc1wiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5hcyAmJlxuICAgICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBhc2Agb3B0aW9uIGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMuYXMpICtcbiAgICAgICAgICAgIFwiLlwiKTtcbiAgICAgIGVuY291bnRlcmVkICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ1JlYWN0RE9NLnByZWxvYWRNb2R1bGUoKTogRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cywgYSBub24tZW1wdHkgYGhyZWZgIHN0cmluZyBhbmQsIG9wdGlvbmFsbHksIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IHZhbGlkIGZvciBhIGA8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCIgYXM9XCIuLi5cIiAvPmAgdGFnLiVzJyxcbiAgICAgICAgICBlbmNvdW50ZXJlZFxuICAgICAgICApO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgKG9wdGlvbnNcbiAgICAgICAgICA/ICgoZW5jb3VudGVyZWQgPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgICAgICBvcHRpb25zLmFzLFxuICAgICAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIEludGVybmFscy5kLm0oaHJlZiwge1xuICAgICAgICAgICAgICBhczpcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyAmJiBcInNjcmlwdFwiICE9PSBvcHRpb25zLmFzXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuYXNcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogZW5jb3VudGVyZWQsXG4gICAgICAgICAgICAgIGludGVncml0eTpcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA6IEludGVybmFscy5kLm0oaHJlZikpO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZXF1ZXN0Rm9ybVJlc2V0ID0gZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgIEludGVybmFscy5kLnIoZm9ybSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhKSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluayk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUZvcm1TdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4wLjBcIjtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1jbGllbnQucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tY2xpZW50LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBjb29raWUtbmFtZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqIFRoaXMgcmVmZXJzIG91dCB0byB0aGUgb2Jzb2xldGVkIGRlZmluaXRpb24gb2YgdG9rZW4gaW4gUkZDIDI2MTYgc2VjIDIuMlxuICogd2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRva2VuIGRlZmluaXRpb24gaW4gUkZDIDcyMzAgYXBwZW5kaXggQi5cbiAqXG4gKiBjb29raWUtbmFtZSAgICAgICA9IHRva2VuXG4gKiB0b2tlbiAgICAgICAgICAgICA9IDEqdGNoYXJcbiAqIHRjaGFyICAgICAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgXCIqXCIgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgXCJgXCIgLyBcInxcIiAvIFwiflwiIC8gRElHSVQgLyBBTFBIQVxuICpcbiAqIE5vdGU6IEFsbG93aW5nIG1vcmUgY2hhcmFjdGVycyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvY29va2llL2lzc3Vlcy8xOTFcbiAqIEFsbG93IHNhbWUgcmFuZ2UgYXMgY29va2llIHZhbHVlLCBleGNlcHQgYD1gLCB3aGljaCBkZWxpbWl0cyBlbmQgb2YgbmFtZS5cbiAqL1xuY29uc3QgY29va2llTmFtZVJlZ0V4cCA9IC9eW1xcdTAwMjEtXFx1MDAzQVxcdTAwM0NcXHUwMDNFLVxcdTAwN0VdKyQvO1xuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggY29va2llLXZhbHVlIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxuICpcbiAqIGNvb2tpZS12YWx1ZSAgICAgID0gKmNvb2tpZS1vY3RldCAvICggRFFVT1RFICpjb29raWUtb2N0ZXQgRFFVT1RFIClcbiAqIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAqICAgICAgICAgICAgICAgICAgICAgOyBVUy1BU0NJSSBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBDVExzLFxuICogICAgICAgICAgICAgICAgICAgICA7IHdoaXRlc3BhY2UgRFFVT1RFLCBjb21tYSwgc2VtaWNvbG9uLFxuICogICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcbiAqXG4gKiBBbGxvd2luZyBtb3JlIGNoYXJhY3RlcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvY29va2llL2lzc3Vlcy8xOTFcbiAqIENvbW1hLCBiYWNrc2xhc2gsIGFuZCBEUVVPVEUgYXJlIG5vdCBwYXJ0IG9mIHRoZSBwYXJzaW5nIGFsZ29yaXRobS5cbiAqL1xuY29uc3QgY29va2llVmFsdWVSZWdFeHAgPSAvXltcXHUwMDIxLVxcdTAwM0FcXHUwMDNDLVxcdTAwN0VdKiQvO1xuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggZG9tYWluLXZhbHVlIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxuICpcbiAqIGRvbWFpbi12YWx1ZSAgICAgID0gPHN1YmRvbWFpbj5cbiAqICAgICAgICAgICAgICAgICAgICAgOyBkZWZpbmVkIGluIFtSRkMxMDM0XSwgU2VjdGlvbiAzLjUsIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgZW5oYW5jZWQgYnkgW1JGQzExMjNdLCBTZWN0aW9uIDIuMVxuICogPHN1YmRvbWFpbj4gICAgICAgPSA8bGFiZWw+IHwgPHN1YmRvbWFpbj4gXCIuXCIgPGxhYmVsPlxuICogPGxhYmVsPiAgICAgICAgICAgPSA8bGV0LWRpZz4gWyBbIDxsZGgtc3RyPiBdIDxsZXQtZGlnPiBdXG4gKiAgICAgICAgICAgICAgICAgICAgIExhYmVscyBtdXN0IGJlIDYzIGNoYXJhY3RlcnMgb3IgbGVzcy5cbiAqICAgICAgICAgICAgICAgICAgICAgJ2xldC1kaWcnIG5vdCAnbGV0dGVyJyBpbiB0aGUgZmlyc3QgY2hhciwgcGVyIFJGQzExMjNcbiAqIDxsZGgtc3RyPiAgICAgICAgID0gPGxldC1kaWctaHlwPiB8IDxsZXQtZGlnLWh5cD4gPGxkaC1zdHI+XG4gKiA8bGV0LWRpZy1oeXA+ICAgICA9IDxsZXQtZGlnPiB8IFwiLVwiXG4gKiA8bGV0LWRpZz4gICAgICAgICA9IDxsZXR0ZXI+IHwgPGRpZ2l0PlxuICogPGxldHRlcj4gICAgICAgICAgPSBhbnkgb25lIG9mIHRoZSA1MiBhbHBoYWJldGljIGNoYXJhY3RlcnMgQSB0aHJvdWdoIFogaW5cbiAqICAgICAgICAgICAgICAgICAgICAgdXBwZXIgY2FzZSBhbmQgYSB0aHJvdWdoIHogaW4gbG93ZXIgY2FzZVxuICogPGRpZ2l0PiAgICAgICAgICAgPSBhbnkgb25lIG9mIHRoZSB0ZW4gZGlnaXRzIDAgdGhyb3VnaCA5XG4gKlxuICogS2VlcCBzdXBwb3J0IGZvciBsZWFkaW5nIGRvdDogaHR0cHM6Ly9naXRodWIuY29tL2pzaHR0cC9jb29raWUvaXNzdWVzLzE3M1xuICpcbiAqID4gKE5vdGUgdGhhdCBhIGxlYWRpbmcgJXgyRSAoXCIuXCIpLCBpZiBwcmVzZW50LCBpcyBpZ25vcmVkIGV2ZW4gdGhvdWdoIHRoYXRcbiAqIGNoYXJhY3RlciBpcyBub3QgcGVybWl0dGVkLCBidXQgYSB0cmFpbGluZyAleDJFIChcIi5cIiksIGlmIHByZXNlbnQsIHdpbGxcbiAqIGNhdXNlIHRoZSB1c2VyIGFnZW50IHRvIGlnbm9yZSB0aGUgYXR0cmlidXRlLilcbiAqL1xuY29uc3QgZG9tYWluVmFsdWVSZWdFeHAgPSAvXihbLl0/W2EtejAtOV0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykoWy5dW2EtejAtOV0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pO1xuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggcGF0aC12YWx1ZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cbiAqIENIQVIgICAgICAgICAgICAgID0gJXgwMS03RlxuICogICAgICAgICAgICAgICAgICAgICA7IGRlZmluZWQgaW4gUkZDIDUyMzQgYXBwZW5kaXggQi4xXG4gKi9cbmNvbnN0IHBhdGhWYWx1ZVJlZ0V4cCA9IC9eW1xcdTAwMjAtXFx1MDAzQVxcdTAwM0QtXFx1MDA3RV0qJC87XG5jb25zdCBfX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IE51bGxPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBDID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gQztcbn0pKCk7XG4vKipcbiAqIFBhcnNlIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gY29va2llIGhlYWRlciBzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqIFRoZSBvYmplY3QgaGFzIHRoZSB2YXJpb3VzIGNvb2tpZXMgYXMga2V5cyhuYW1lcykgPT4gdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBOdWxsT2JqZWN0KCk7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICAvLyBSRkMgNjI2NSBzZWMgNC4xLjEsIFJGQyAyNjE2IDIuMiBkZWZpbmVzIGEgY29va2llIG5hbWUgY29uc2lzdHMgb2Ygb25lIGNoYXIgbWluaW11bSwgcGx1cyAnPScuXG4gICAgaWYgKGxlbiA8IDIpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgY29uc3QgZGVjID0gb3B0aW9ucz8uZGVjb2RlIHx8IGRlY29kZTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgZXFJZHggPSBzdHIuaW5kZXhPZihcIj1cIiwgaW5kZXgpO1xuICAgICAgICBpZiAoZXFJZHggPT09IC0xKVxuICAgICAgICAgICAgYnJlYWs7IC8vIE5vIG1vcmUgY29va2llIHBhaXJzLlxuICAgICAgICBjb25zdCBjb2xvbklkeCA9IHN0ci5pbmRleE9mKFwiO1wiLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGVuZElkeCA9IGNvbG9uSWR4ID09PSAtMSA/IGxlbiA6IGNvbG9uSWR4O1xuICAgICAgICBpZiAoZXFJZHggPiBlbmRJZHgpIHtcbiAgICAgICAgICAgIC8vIGJhY2t0cmFjayBvbiBwcmlvciBzZW1pY29sb25cbiAgICAgICAgICAgIGluZGV4ID0gc3RyLmxhc3RJbmRleE9mKFwiO1wiLCBlcUlkeCAtIDEpICsgMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGluZGV4LCBlcUlkeCk7XG4gICAgICAgIGNvbnN0IGtleUVuZElkeCA9IGVuZEluZGV4KHN0ciwgZXFJZHgsIGtleVN0YXJ0SWR4KTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0SWR4LCBrZXlFbmRJZHgpO1xuICAgICAgICAvLyBvbmx5IGFzc2lnbiBvbmNlXG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgdmFsU3RhcnRJZHggPSBzdGFydEluZGV4KHN0ciwgZXFJZHggKyAxLCBlbmRJZHgpO1xuICAgICAgICAgICAgbGV0IHZhbEVuZElkeCA9IGVuZEluZGV4KHN0ciwgZW5kSWR4LCB2YWxTdGFydElkeCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlYyhzdHIuc2xpY2UodmFsU3RhcnRJZHgsIHZhbEVuZElkeCkpO1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGVuZElkeCArIDE7XG4gICAgfSB3aGlsZSAoaW5kZXggPCBsZW4pO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBzdGFydEluZGV4KHN0ciwgaW5kZXgsIG1heCkge1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNvZGUgIT09IDB4MjAgLyogICAqLyAmJiBjb2RlICE9PSAweDA5IC8qIFxcdCAqLylcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9IHdoaWxlICgrK2luZGV4IDwgbWF4KTtcbiAgICByZXR1cm4gbWF4O1xufVxuZnVuY3Rpb24gZW5kSW5kZXgoc3RyLCBpbmRleCwgbWluKSB7XG4gICAgd2hpbGUgKGluZGV4ID4gbWluKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdCgtLWluZGV4KTtcbiAgICAgICAgaWYgKGNvZGUgIT09IDB4MjAgLyogICAqLyAmJiBjb2RlICE9PSAweDA5IC8qIFxcdCAqLylcbiAgICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICAgIHJldHVybiBtaW47XG59XG4vKipcbiAqIFNlcmlhbGl6ZSBkYXRhIGludG8gYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFNlcmlhbGl6ZSBhIG5hbWUgdmFsdWUgcGFpciBpbnRvIGEgY29va2llIHN0cmluZyBzdWl0YWJsZSBmb3JcbiAqIGh0dHAgaGVhZGVycy4gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3Qgc3BlY2lmaWVzIGNvb2tpZSBwYXJhbWV0ZXJzLlxuICpcbiAqIHNlcmlhbGl6ZSgnZm9vJywgJ2JhcicsIHsgaHR0cE9ubHk6IHRydWUgfSlcbiAqICAgPT4gXCJmb289YmFyOyBodHRwT25seVwiXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShuYW1lLCB2YWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmMgPSBvcHRpb25zPy5lbmNvZGUgfHwgZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIGlmICghY29va2llTmFtZVJlZ0V4cC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGFyZ3VtZW50IG5hbWUgaXMgaW52YWxpZDogJHtuYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGVuYyh2YWwpO1xuICAgIGlmICghY29va2llVmFsdWVSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYXJndW1lbnQgdmFsIGlzIGludmFsaWQ6ICR7dmFsfWApO1xuICAgIH1cbiAgICBsZXQgc3RyID0gbmFtZSArIFwiPVwiICsgdmFsdWU7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIGlmIChvcHRpb25zLm1heEFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLm1heEFnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBtYXhBZ2UgaXMgaW52YWxpZDogJHtvcHRpb25zLm1heEFnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IE1heC1BZ2U9XCIgKyBvcHRpb25zLm1heEFnZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgIGlmICghZG9tYWluVmFsdWVSZWdFeHAudGVzdChvcHRpb25zLmRvbWFpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBkb21haW4gaXMgaW52YWxpZDogJHtvcHRpb25zLmRvbWFpbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IERvbWFpbj1cIiArIG9wdGlvbnMuZG9tYWluO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgIGlmICghcGF0aFZhbHVlUmVnRXhwLnRlc3Qob3B0aW9ucy5wYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgb3B0aW9uIHBhdGggaXMgaW52YWxpZDogJHtvcHRpb25zLnBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBQYXRoPVwiICsgb3B0aW9ucy5wYXRoO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5leHBpcmVzKSB7XG4gICAgICAgIGlmICghaXNEYXRlKG9wdGlvbnMuZXhwaXJlcykgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5leHBpcmVzLnZhbHVlT2YoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBleHBpcmVzIGlzIGludmFsaWQ6ICR7b3B0aW9ucy5leHBpcmVzfWApO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBcIjsgRXhwaXJlcz1cIiArIG9wdGlvbnMuZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5odHRwT25seSkge1xuICAgICAgICBzdHIgKz0gXCI7IEh0dHBPbmx5XCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlY3VyZSkge1xuICAgICAgICBzdHIgKz0gXCI7IFNlY3VyZVwiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXJ0aXRpb25lZCkge1xuICAgICAgICBzdHIgKz0gXCI7IFBhcnRpdGlvbmVkXCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5ID0gdHlwZW9mIG9wdGlvbnMucHJpb3JpdHkgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gb3B0aW9ucy5wcmlvcml0eS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSBcImxvd1wiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgUHJpb3JpdHk9TG93XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBQcmlvcml0eT1NZWRpdW1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoaWdoXCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBQcmlvcml0eT1IaWdoXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBwcmlvcml0eSBpcyBpbnZhbGlkOiAke29wdGlvbnMucHJpb3JpdHl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2FtZVNpdGUpIHtcbiAgICAgICAgY29uc3Qgc2FtZVNpdGUgPSB0eXBlb2Ygb3B0aW9ucy5zYW1lU2l0ZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBvcHRpb25zLnNhbWVTaXRlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogb3B0aW9ucy5zYW1lU2l0ZTtcbiAgICAgICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgY2FzZSBcInN0cmljdFwiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9U3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGF4XCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1MYXhcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1Ob25lXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkOiAke29wdGlvbnMuc2FtZVNpdGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogVVJMLWRlY29kZSBzdHJpbmcgdmFsdWUuIE9wdGltaXplZCB0byBza2lwIG5hdGl2ZSBjYWxsIHdoZW4gbm8gJS5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiVcIikgPT09IC0xKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZSBpZiB2YWx1ZSBpcyBhIERhdGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICByZXR1cm4gX190b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fSxcbiAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgITEsIHNvdXJjZSwgc2VsZik7XG4gICAgfTtcbiAgICBleHBvcnRzLmpzeHMgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCAhMCwgc291cmNlLCBzZWxmKTtcbiAgICB9O1xuICB9KSgpO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXNcIixcbiAgICAgICAgICAgIGluZm9bMF0sXG4gICAgICAgICAgICBpbmZvWzFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICAocHVibGljSW5zdGFuY2UuZGlzcGxheU5hbWUgfHwgcHVibGljSW5zdGFuY2UubmFtZSkpIHx8XG4gICAgICAgIFwiUmVhY3RDbGFzc1wiO1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBwdWJsaWNJbnN0YW5jZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFRoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCBjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuXCIsXG4gICAgICAgICAgY2FsbGVyTmFtZSxcbiAgICAgICAgICBwdWJsaWNJbnN0YW5jZVxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMlxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHxcbiAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5nZXRNb2R1bGVJZCkpXG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgcHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgISghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSkpLCB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHJvdG90eXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKHByb3RvdHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gICAgICBuZXdLZXkgPSBSZWFjdEVsZW1lbnQoXG4gICAgICAgIG9sZEVsZW1lbnQudHlwZSxcbiAgICAgICAgbmV3S2V5LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgb2xkRWxlbWVudC5fb3duZXIsXG4gICAgICAgIG9sZEVsZW1lbnQucHJvcHNcbiAgICAgICk7XG4gICAgICBuZXdLZXkuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgoaSA9IGdldEl0ZXJhdG9yRm4obm9kZSkpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgJiZcbiAgICAgICAgICAgIGkgIT09IG5vZGUuZW50cmllcyAmJlxuICAgICAgICAgICAgKChpID0gaS5jYWxsKG5vZGUpKSwgaSAhPT0gbm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKDsgIShub2RlID0gaS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUudmFsdWUpICYmXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkobm9kZS52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iamVjdCAmJlxuICAgICAgICBudWxsICE9PSBvYmplY3QgJiZcbiAgICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBlbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAhZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgIG51bGwgPT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgKChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSAxKSxcbiAgICAgICAgKHBhcmVudFR5cGUgPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpKSxcbiAgICAgICAgIW93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSlcbiAgICAgICkge1xuICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbcGFyZW50VHlwZV0gPSAhMDtcbiAgICAgICAgdmFyIGNoaWxkT3duZXIgPSBcIlwiO1xuICAgICAgICBlbGVtZW50ICYmXG4gICAgICAgICAgbnVsbCAhPSBlbGVtZW50Ll9vd25lciAmJlxuICAgICAgICAgIGVsZW1lbnQuX293bmVyICE9PSBnZXRPd25lcigpICYmXG4gICAgICAgICAgKChjaGlsZE93bmVyID0gbnVsbCksXG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLnRhZ1xuICAgICAgICAgICAgPyAoY2hpbGRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSlcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLm5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXIgPSBlbGVtZW50Ll9vd25lci5uYW1lKSxcbiAgICAgICAgICAoY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2hpbGRPd25lciArIFwiLlwiKSk7XG4gICAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSk7XG4gICAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayAmJiAoc3RhY2sgKz0gcHJldkdldEN1cnJlbnRTdGFjaygpIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICBjaGlsZE93bmVyXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBcIlwiLFxuICAgICAgICBvd25lciA9IGdldE93bmVyKCk7XG4gICAgICBvd25lciAmJlxuICAgICAgICAob3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkpICYmXG4gICAgICAgIChpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lciArIFwiYC5cIik7XG4gICAgICBpbmZvIHx8XG4gICAgICAgICgocGFyZW50VHlwZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKSkgJiZcbiAgICAgICAgICAoaW5mbyA9XG4gICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50VHlwZSArIFwiPi5cIikpO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgICAgIHZhciBlc2NhcGVyTG9va3VwID0geyBcIj1cIjogXCI9MFwiLCBcIjpcIjogXCI9MlwiIH07XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIiRcIiArXG4gICAgICAgIGtleS5yZXBsYWNlKC9bPTpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJlxuICAgICAgICBudWxsICE9PSBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT0gZWxlbWVudC5rZXlcbiAgICAgICAgPyAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSksIGVzY2FwZShcIlwiICsgZWxlbWVudC5rZXkpKVxuICAgICAgICA6IGluZGV4LnRvU3RyaW5nKDM2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiByZXNvbHZlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKVxuICAgICAgICAgICAgICA6ICgodGhlbmFibGUuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICgodGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgKHRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICgodGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUucmVhc29uID0gZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZSB8fCBcImJvb2xlYW5cIiA9PT0gdHlwZSkgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdmFyIGludm9rZUNhbGxiYWNrID0gITE7XG4gICAgICBpZiAobnVsbCA9PT0gY2hpbGRyZW4pIGludm9rZUNhbGxiYWNrID0gITA7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayA9IGNoaWxkcmVuLl9pbml0KSxcbiAgICAgICAgICAgICAgICAgIG1hcEludG9BcnJheShcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2hpbGRyZW4uX3BheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgICAgICBpbnZva2VDYWxsYmFjayA9IGNoaWxkcmVuO1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKGludm9rZUNhbGxiYWNrKTtcbiAgICAgICAgdmFyIGNoaWxkS2V5ID1cbiAgICAgICAgICBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiArIGdldEVsZW1lbnRLZXkoaW52b2tlQ2FsbGJhY2ssIDApIDogbmFtZVNvRmFyO1xuICAgICAgICBpc0FycmF5SW1wbChjYWxsYmFjaylcbiAgICAgICAgICA/ICgoZXNjYXBlZFByZWZpeCA9IFwiXCIpLFxuICAgICAgICAgICAgbnVsbCAhPSBjaGlsZEtleSAmJlxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9XG4gICAgICAgICAgICAgICAgY2hpbGRLZXkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgXCIkJi9cIikgKyBcIi9cIiksXG4gICAgICAgICAgICBtYXBJbnRvQXJyYXkoY2FsbGJhY2ssIGFycmF5LCBlc2NhcGVkUHJlZml4LCBcIlwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDogbnVsbCAhPSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKGlzVmFsaWRFbGVtZW50KGNhbGxiYWNrKSAmJlxuICAgICAgICAgICAgICAobnVsbCAhPSBjYWxsYmFjay5rZXkgJiZcbiAgICAgICAgICAgICAgICAoKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KSB8fFxuICAgICAgICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjYWxsYmFjay5rZXkpKSxcbiAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXggPSBjbG9uZUFuZFJlcGxhY2VLZXkoXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCArXG4gICAgICAgICAgICAgICAgICAobnVsbCA9PSBjYWxsYmFjay5rZXkgfHxcbiAgICAgICAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayAmJiBpbnZva2VDYWxsYmFjay5rZXkgPT09IGNhbGxiYWNrLmtleSlcbiAgICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgIDogKFwiXCIgKyBjYWxsYmFjay5rZXkpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJCYvXCJcbiAgICAgICAgICAgICAgICAgICAgICApICsgXCIvXCIpICtcbiAgICAgICAgICAgICAgICAgIGNoaWxkS2V5XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcIlwiICE9PSBuYW1lU29GYXIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9IGludm9rZUNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQoaW52b2tlQ2FsbGJhY2spICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PSBpbnZva2VDYWxsYmFjay5rZXkgJiZcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjay5fc3RvcmUgJiZcbiAgICAgICAgICAgICAgICAhaW52b2tlQ2FsbGJhY2suX3N0b3JlLnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4Ll9zdG9yZS52YWxpZGF0ZWQgPSAyKSxcbiAgICAgICAgICAgICAgKGNhbGxiYWNrID0gZXNjYXBlZFByZWZpeCkpLFxuICAgICAgICAgICAgYXJyYXkucHVzaChjYWxsYmFjaykpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGludm9rZUNhbGxiYWNrID0gMDtcbiAgICAgIGNoaWxkS2V5ID0gXCJcIiA9PT0gbmFtZVNvRmFyID8gXCIuXCIgOiBuYW1lU29GYXIgKyBcIjpcIjtcbiAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgKG5hbWVTb0ZhciA9IGNoaWxkcmVuW2ldKSxcbiAgICAgICAgICAgICh0eXBlID0gY2hpbGRLZXkgKyBnZXRFbGVtZW50S2V5KG5hbWVTb0ZhciwgaSkpLFxuICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICs9IG1hcEludG9BcnJheShcbiAgICAgICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICkpO1xuICAgICAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbikpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpKSlcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpID09PSBjaGlsZHJlbi5lbnRyaWVzICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKSxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gaS5jYWxsKGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICEobmFtZVNvRmFyID0gY2hpbGRyZW4ubmV4dCgpKS5kb25lO1xuXG4gICAgICAgIClcbiAgICAgICAgICAobmFtZVNvRmFyID0gbmFtZVNvRmFyLnZhbHVlKSxcbiAgICAgICAgICAgICh0eXBlID0gY2hpbGRLZXkgKyBnZXRFbGVtZW50S2V5KG5hbWVTb0ZhciwgaSsrKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmIChcIm9iamVjdFwiID09PSB0eXBlKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZHJlbi50aGVuKVxuICAgICAgICAgIHJldHVybiBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICByZXNvbHZlVGhlbmFibGUoY2hpbGRyZW4pLFxuICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBhcnJheSA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gYXJyYXlcbiAgICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICAgIDogYXJyYXkpICtcbiAgICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gICAgICBpZiAobnVsbCA9PSBjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgXCJcIiwgXCJcIiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICAgICAgaWYgKC0xID09PSBwYXlsb2FkLl9zdGF0dXMpIHtcbiAgICAgICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICAgIGN0b3IgPSBjdG9yKCk7XG4gICAgICAgIGN0b3IudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgICAgICAgIChwYXlsb2FkLl9zdGF0dXMgPSAxKSwgKHBheWxvYWQuX3Jlc3VsdCA9IG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDIpLCAocGF5bG9hZC5fcmVzdWx0ID0gZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgLTEgPT09IHBheWxvYWQuX3N0YXR1cyAmJlxuICAgICAgICAgICgocGF5bG9hZC5fc3RhdHVzID0gMCksIChwYXlsb2FkLl9yZXN1bHQgPSBjdG9yKSk7XG4gICAgICB9XG4gICAgICBpZiAoMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChjdG9yID0gcGF5bG9hZC5fcmVzdWx0KSxcbiAgICAgICAgICB2b2lkIDAgPT09IGN0b3IgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD9cIixcbiAgICAgICAgICAgICAgY3RvclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBcImRlZmF1bHRcIiBpbiBjdG9yIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImxhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcG9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLFxuICAgICAgICAgICAgICBjdG9yXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGN0b3IuZGVmYXVsdFxuICAgICAgICApO1xuICAgICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIG51bGwgPT09IGRpc3BhdGNoZXIgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIGVucXVldWVUYXNrKHRhc2spIHtcbiAgICAgIGlmIChudWxsID09PSBlbnF1ZXVlVGFza0ltcGwpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoXCJyZXF1aXJlXCIgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgICBlbnF1ZXVlVGFza0ltcGwgPSAobW9kdWxlICYmIG1vZHVsZVtyZXF1aXJlU3RyaW5nXSkuY2FsbChcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgICAgIFwidGltZXJzXCJcbiAgICAgICAgICApLnNldEltbWVkaWF0ZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgITEgPT09IGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICgoZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSAhMCksXG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sIHNvIGVucXVldWluZyB0YXNrcyB2aWEgYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLikgd2lsbCBmYWlsLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzIGlmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2Uodm9pZCAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gZW5xdWV1ZVRhc2tJbXBsKHRhc2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgICByZXR1cm4gMSA8IGVycm9ycy5sZW5ndGggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQWdncmVnYXRlRXJyb3JcbiAgICAgICAgPyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKVxuICAgICAgICA6IGVycm9yc1swXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCkge1xuICAgICAgcHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEJlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuIFwiXG4gICAgICAgICk7XG4gICAgICBhY3RTY29wZURlcHRoID0gcHJldkFjdFNjb3BlRGVwdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gcXVldWUpXG4gICAgICAgIGlmICgwICE9PSBxdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID0gbnVsbDtcbiAgICAgIDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoXG4gICAgICAgID8gKChxdWV1ZSA9IGFnZ3JlZ2F0ZUVycm9ycyhSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMpKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgIHJlamVjdChxdWV1ZSkpXG4gICAgICAgIDogcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQWN0UXVldWUocXVldWUpIHtcbiAgICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgICBpc0ZsdXNoaW5nID0gITA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSA9ICExO1xuICAgICAgICAgICAgICB2YXIgY29udGludWF0aW9uID0gY2FsbGJhY2soITEpO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY29udGludWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBxdWV1ZS5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY29udGludWF0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBxdWV1ZS5zcGxpY2UoMCwgaSArIDEpLCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNGbHVzaGluZyA9ICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge30sXG4gICAgICBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgZW1wdHlPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGVcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJ0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIlxuICAgICAgICApO1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICB9O1xuICAgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBbXG4gICAgICAgICAgXCJpc01vdW50ZWRcIixcbiAgICAgICAgICBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXG4gICAgICAgIF0sXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogW1xuICAgICAgICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgICAgICAgXCJSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLlwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmbk5hbWU7XG4gICAgZm9yIChmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpXG4gICAgICBkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpICYmXG4gICAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbiAgICBhc3NpZ24oZGVwcmVjYXRlZEFQSXMsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG4gICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gICAgICAgIEg6IG51bGwsXG4gICAgICAgIEE6IG51bGwsXG4gICAgICAgIFQ6IG51bGwsXG4gICAgICAgIFM6IG51bGwsXG4gICAgICAgIGFjdFF1ZXVlOiBudWxsLFxuICAgICAgICBpc0JhdGNoaW5nTGVnYWN5OiAhMSxcbiAgICAgICAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6ICExLFxuICAgICAgICBkaWRVc2VQcm9taXNlOiAhMSxcbiAgICAgICAgdGhyb3duRXJyb3JzOiBbXSxcbiAgICAgICAgZ2V0Q3VycmVudFN0YWNrOiBudWxsXG4gICAgICB9LFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLFxuICAgICAgZGlkV2FybkFib3V0T2xkSlNYUnVudGltZTtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSAhMSxcbiAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZyxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSAhMSxcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG51bGwsXG4gICAgICBhY3RTY29wZURlcHRoID0gMCxcbiAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gITEsXG4gICAgICBpc0ZsdXNoaW5nID0gITEsXG4gICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlbnF1ZXVlVGFzaztcbiAgICBleHBvcnRzLkNoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICAgIG1hcENoaWxkcmVuKFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JFYWNoQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSxcbiAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICB9KSB8fCBbXVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICBleHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgZXhwb3J0cy5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5hY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwcmV2QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSxcbiAgICAgICAgcHJldkFjdFNjb3BlRGVwdGggPSBhY3RTY29wZURlcHRoO1xuICAgICAgYWN0U2NvcGVEZXB0aCsrO1xuICAgICAgdmFyIHF1ZXVlID0gKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID1cbiAgICAgICAgICBudWxsICE9PSBwcmV2QWN0UXVldWUgPyBwcmV2QWN0UXVldWUgOiBbXSksXG4gICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICExO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAocG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCksXG4gICAgICAgICAgKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHJlc3VsdCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVzdWx0ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlc3VsdC50aGVuXG4gICAgICApIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gcmVzdWx0O1xuICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Ob0F3YWl0QWN0ID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuIFRoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCBpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgc2NvcGVzLiBZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7XCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgPSAhMDtcbiAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwcmV2QWN0U2NvcGVEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvciQyKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yJDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhyb3duRXJyb3IgPSBhZ2dyZWdhdGVFcnJvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoX3Rocm93bkVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/ICgoZXJyb3IgPSBhZ2dyZWdhdGVFcnJvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpKVxuICAgICAgICAgICAgICAgICAgOiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXR1cm5WYWx1ZSRqc2NvbXAkMCA9IHJlc3VsdDtcbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGggJiZcbiAgICAgICAgKGZsdXNoQWN0UXVldWUocXVldWUpLFxuICAgICAgICAwICE9PSBxdWV1ZS5sZW5ndGggJiZcbiAgICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Ob0F3YWl0QWN0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQSBjb21wb25lbnQgc3VzcGVuZGVkIGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnV0IHRoZSBgYWN0YCBjYWxsIHdhcyBub3QgYXdhaXRlZC4gV2hlbiB0ZXN0aW5nIFJlYWN0IGNvbXBvbmVudHMgdGhhdCBkZXBlbmQgb24gYXN5bmNocm9ub3VzIGRhdGEsIHlvdSBtdXN0IGF3YWl0IHRoZSByZXN1bHQ6XFxuXFxuYXdhaXQgYWN0KCgpID0+IC4uLilcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID0gbnVsbCkpO1xuICAgICAgaWYgKDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKChjYWxsYmFjayA9IGFnZ3JlZ2F0ZUVycm9ycyhSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMpKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgIGNhbGxiYWNrKVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgIDAgPT09IHByZXZBY3RTY29wZURlcHRoXG4gICAgICAgICAgICA/ICgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBxdWV1ZSksXG4gICAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsID09PSBlbGVtZW50IHx8IHZvaWQgMCA9PT0gZWxlbWVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICtcbiAgICAgICAgICAgIGVsZW1lbnQgK1xuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyksXG4gICAgICAgIGtleSA9IGVsZW1lbnQua2V5LFxuICAgICAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgaWYgKG51bGwgIT0gY29uZmlnKSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJyZWZcIikgJiZcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIFwicmVmXCJcbiAgICAgICAgICAgICkuZ2V0KSAmJlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmlzUmVhY3RXYXJuaW5nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHZvaWQgMCAhPT0gY29uZmlnLnJlZjtcbiAgICAgICAgfVxuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiYgKG93bmVyID0gZ2V0T3duZXIoKSk7XG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpIHx8XG4gICAgICAgICAgICBcImtleVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NlbGZcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgICAgIFwiX19zb3VyY2VcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgICAgIChcInJlZlwiID09PSBwcm9wTmFtZSAmJiB2b2lkIDAgPT09IGNvbmZpZy5yZWYpIHx8XG4gICAgICAgICAgICAocHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICgxID09PSBwcm9wTmFtZSkgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIGVsc2UgaWYgKDEgPCBwcm9wTmFtZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBBcnJheShwcm9wTmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcE5hbWU7IGkrKylcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCB2b2lkIDAsIHZvaWQgMCwgb3duZXIsIHByb3BzKTtcbiAgICAgIGZvciAoa2V5ID0gMjsga2V5IDwgYXJndW1lbnRzLmxlbmd0aDsga2V5KyspXG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1trZXldLCBwcm9wcy50eXBlKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBDb25zdW1lcjogbnVsbFxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5Qcm92aWRlciA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5Db25zdW1lciA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlNVTUVSX1RZUEUsXG4gICAgICAgIF9jb250ZXh0OiBkZWZhdWx0VmFsdWVcbiAgICAgIH07XG4gICAgICBkZWZhdWx0VmFsdWUuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgICBkZWZhdWx0VmFsdWUuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKVxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGkgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBpICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIGlmIChudWxsID09PSB0eXBlKSB2YXIgdHlwZVN0cmluZyA9IFwibnVsbFwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgID8gKHR5cGVTdHJpbmcgPSBcImFycmF5XCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyAoKHR5cGVTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAoaSA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAodHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIixcbiAgICAgICAgICB0eXBlU3RyaW5nLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTmFtZTtcbiAgICAgIGkgPSB7fTtcbiAgICAgIHR5cGVTdHJpbmcgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT0gY29uZmlnKVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIChkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lIHx8XG4gICAgICAgICAgIShcIl9fc2VsZlwiIGluIGNvbmZpZykgfHxcbiAgICAgICAgICBcImtleVwiIGluIGNvbmZpZyB8fFxuICAgICAgICAgICgoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIllvdXIgYXBwIChvciBvbmUgb2YgaXRzIGRlcGVuZGVuY2llcykgaXMgdXNpbmcgYW4gb3V0ZGF0ZWQgSlNYIHRyYW5zZm9ybS4gVXBkYXRlIHRvIHRoZSBtb2Rlcm4gSlNYIHRyYW5zZm9ybSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlOiBodHRwczovL3JlYWN0LmRldi9saW5rL25ldy1qc3gtdHJhbnNmb3JtXCJcbiAgICAgICAgICApKSxcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAodHlwZVN0cmluZyA9IFwiXCIgKyBjb25maWcua2V5KSksXG4gICAgICAgIGNvbmZpZykpXG4gICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgICAgIFwiX19zZWxmXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc291cmNlXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICAoaVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IGNoaWxkcmVuTGVuZ3RoKSBpLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBlbHNlIGlmICgxIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKSwgX2kgPSAwO1xuICAgICAgICAgIF9pIDwgY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgICAgX2krK1xuICAgICAgICApXG4gICAgICAgICAgY2hpbGRBcnJheVtfaV0gPSBhcmd1bWVudHNbX2kgKyAyXTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgICBpLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluICgoY2hpbGRyZW5MZW5ndGggPSB0eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkcmVuTGVuZ3RoKSlcbiAgICAgICAgICB2b2lkIDAgPT09IGlbcHJvcE5hbWVdICYmIChpW3Byb3BOYW1lXSA9IGNoaWxkcmVuTGVuZ3RoW3Byb3BOYW1lXSk7XG4gICAgICB0eXBlU3RyaW5nICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIGksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIHR5cGVTdHJpbmcsIHZvaWQgMCwgdm9pZCAwLCBnZXRPd25lcigpLCBpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlZk9iamVjdCA9IHsgY3VycmVudDogbnVsbCB9O1xuICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgIHJldHVybiByZWZPYmplY3Q7XG4gICAgfTtcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgICBudWxsICE9IHJlbmRlciAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRVxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSkuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy5cIixcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyID8gXCJudWxsXCIgOiB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAwICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAyICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXNcIixcbiAgICAgICAgICAgICAgMSA9PT0gcmVuZGVyLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gXCJEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/XCJcbiAgICAgICAgICAgICAgICA6IFwiQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgbnVsbCAhPSByZW5kZXIgJiZcbiAgICAgICAgbnVsbCAhPSByZW5kZXIuZGVmYXVsdFByb3BzICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgZGVmYXVsdFByb3BzLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50P1wiXG4gICAgICAgICk7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IHJlbmRlciB9LFxuICAgICAgICBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgcmVuZGVyLm5hbWUgfHxcbiAgICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXIsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudFR5cGU7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG4gICAgZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBjdG9yIH0sXG4gICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLm1lbW8gPSBmdW5jdGlvbiAodHlwZSwgY29tcGFyZSkge1xuICAgICAgaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCByZWNlaXZlZDogJXNcIixcbiAgICAgICAgICBudWxsID09PSB0eXBlID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZVxuICAgICAgICApO1xuICAgICAgY29tcGFyZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29tcGFyZTogdm9pZCAwID09PSBjb21wYXJlID8gbnVsbCA6IGNvbXBhcmVcbiAgICAgIH07XG4gICAgICB2YXIgb3duTmFtZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wYXJlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgdHlwZS5uYW1lIHx8XG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc2NvcGUoKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihub29wLCByZXBvcnRHbG9iYWxFcnJvcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgKChzY29wZSA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgMTAgPCBzY29wZSAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FjaGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZSA9IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZSh1c2FibGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VBY3Rpb25TdGF0ZShcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgIHBlcm1hbGlua1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ29udGV4dCA9IGZ1bmN0aW9uIChDb250ZXh0KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICBDb250ZXh0LiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBidWdzLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSWQoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlTWVtbyA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVmID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVN0YXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSBmdW5jdGlvbiAoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VUcmFuc2l0aW9uKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICAgICAgaWYgKGlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExO1xuICAgICAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLFxuICAgICAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUYXNrKSBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgICAgICAoaXNQZXJmb3JtaW5nV29yayA9ICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBoYXNNb3JlV29ya1xuICAgICAgICAgICAgPyBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpXG4gICAgICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxLFxuICAgICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgICAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgICAgICAoaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlKSxcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHBhcmVudCksXG4gICAgICAgICAgICAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgICAgICBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgYTogZm9yIChcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDEsXG4gICAgICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICAgICAgcmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGVmdClcbiAgICAgICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCkpXG4gICAgICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSBsZWZ0SW5kZXgpKTtcbiAgICAgICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICAgICAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gdGltZXIuY2FsbGJhY2spIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgICAgICh0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZSksXG4gICAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZClcbiAgICAgICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbCA/ICExIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICAgIHRpbWVyUXVldWUgPSBbXSxcbiAgICAgIHRhc2tJZENvdW50ZXIgPSAxLFxuICAgICAgY3VycmVudFRhc2sgPSBudWxsLFxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICExLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsU2V0SW1tZWRpYXRlID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGwsXG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xLFxuICAgICAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gICAgICBzdGFydFRpbWUgPSAtMTtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gICAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIGV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IChmcmFtZUludGVydmFsID0gMCA8IGZwcyA/IE1hdGguZmxvb3IoMWUzIC8gZnBzKSA6IDUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuZGVsYXkpLFxuICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgICAgID8gY3VycmVudFRpbWUgKyBvcHRpb25zXG4gICAgICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgICAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gNWUzO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICAgICAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IG9wdGlvbnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgICAgIHB1c2godGltZXJRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgICAgICAoaXNIb3N0VGltZW91dFNjaGVkdWxlZFxuICAgICAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgb3B0aW9ucyAtIGN1cnJlbnRUaW1lKSkpXG4gICAgICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gICAgICByZXR1cm4gcHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmF1bHRQYXJzZU9wdGlvbnMgPSB7XG4gIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgbWFwOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmICEhc3RyLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc2V0Q29va2llVmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcblxuICB2YXIgbmFtZVZhbHVlUGFpclN0ciA9IHBhcnRzLnNoaWZ0KCk7XG4gIHZhciBwYXJzZWQgPSBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cik7XG4gIHZhciBuYW1lID0gcGFyc2VkLm5hbWU7XG4gIHZhciB2YWx1ZSA9IHBhcnNlZC52YWx1ZTtcblxuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlOyAvLyBkZWNvZGUgY29va2llIHZhbHVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArXG4gICAgICAgIHZhbHVlICtcbiAgICAgICAgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuXG4gIHZhciBjb29raWUgPSB7XG4gICAgbmFtZTogbmFtZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gIH07XG5cbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICBjb29raWUubWF4QWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgY29va2llLnNlY3VyZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzYW1lc2l0ZVwiKSB7XG4gICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJwYXJ0aXRpb25lZFwiKSB7XG4gICAgICBjb29raWUucGFydGl0aW9uZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29raWVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvb2tpZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpIHtcbiAgLy8gUGFyc2VzIG5hbWUtdmFsdWUtcGFpciBhY2NvcmRpbmcgdG8gcmZjNjI2NWJpcyBkcmFmdFxuXG4gIHZhciBuYW1lID0gXCJcIjtcbiAgdmFyIHZhbHVlID0gXCJcIjtcbiAgdmFyIG5hbWVWYWx1ZUFyciA9IG5hbWVWYWx1ZVBhaXJTdHIuc3BsaXQoXCI9XCIpO1xuICBpZiAobmFtZVZhbHVlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICBuYW1lID0gbmFtZVZhbHVlQXJyLnNoaWZ0KCk7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVBcnIuam9pbihcIj1cIik7IC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0ID0sIGpvaW5lZCBieSBhIFwiPVwiIGlmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIHBhcnRcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJTdHI7XG4gIH1cblxuICByZXR1cm4geyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghaW5wdXQpIHtcbiAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXQuaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gZm9yIGZldGNoIHJlc3BvbnNlcyAtIHRoZXkgY29tYmluZSBoZWFkZXJzIG9mIHRoZSBzYW1lIHR5cGUgaW4gdGhlIGhlYWRlcnMgYXJyYXksXG4gICAgICAvLyBidXQgZ2V0U2V0Q29va2llIHJldHVybnMgYW4gdW5jb21iaW5lZCBhcnJheVxuICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSgpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl0pIHtcbiAgICAgIC8vIGZhc3QtcGF0aCBmb3Igbm9kZS5qcyAod2hpY2ggYXV0b21hdGljYWxseSBub3JtYWxpemVzIGhlYWRlciBuYW1lcyB0byBsb3dlci1jYXNlXG4gICAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzbG93LXBhdGggZm9yIG90aGVyIGVudmlyb25tZW50cyAtIHNlZSAjMjVcbiAgICAgIHZhciBzY2ggPVxuICAgICAgICBpbnB1dC5oZWFkZXJzW1xuICAgICAgICAgIE9iamVjdC5rZXlzKGlucHV0LmhlYWRlcnMpLmZpbmQoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgICB9KVxuICAgICAgICBdO1xuICAgICAgLy8gd2FybiBpZiBjYWxsZWQgb24gYSByZXF1ZXN0LWxpa2Ugb2JqZWN0IHdpdGggYSBjb29raWUgaGVhZGVyIHJhdGhlciB0aGFuIGEgc2V0LWNvb2tpZSBoZWFkZXIgLSBzZWUgIzM0LCAzNlxuICAgICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIldhcm5pbmc6IHNldC1jb29raWUtcGFyc2VyIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbiBhIHJlcXVlc3Qgb2JqZWN0LiBJdCBpcyBkZXNpZ25lZCB0byBwYXJzZSBTZXQtQ29va2llIGhlYWRlcnMgZnJvbSByZXNwb25zZXMsIG5vdCBDb29raWUgaGVhZGVycyBmcm9tIHJlcXVlc3RzLiBTZXQgdGhlIG9wdGlvbiB7c2lsZW50OiB0cnVlfSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0ID0gc2NoO1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb29raWVzID0ge307XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5yZWR1Y2UoZnVuY3Rpb24gKGNvb2tpZXMsIHN0cikge1xuICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICBjb29raWVzW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICAgIHJldHVybiBjb29raWVzO1xuICAgIH0sIGNvb2tpZXMpO1xuICB9XG59XG5cbi8qXG4gIFNldC1Db29raWUgaGVhZGVyIGZpZWxkLXZhbHVlcyBhcmUgc29tZXRpbWVzIGNvbW1hIGpvaW5lZCBpbiBvbmUgc3RyaW5nLiBUaGlzIHNwbGl0cyB0aGVtIHdpdGhvdXQgY2hva2luZyBvbiBjb21tYXNcbiAgdGhhdCBhcmUgd2l0aGluIGEgc2luZ2xlIHNldC1jb29raWUgZmllbGQtdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIEV4cGlyZXMgcG9ydGlvbi5cblxuICBUaGlzIGlzIHVuY29tbW9uLCBidXQgZXhwbGljaXRseSBhbGxvd2VkIC0gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tNC4yXG4gIE5vZGUuanMgZG9lcyB0aGlzIGZvciBldmVyeSBoZWFkZXIgKmV4Y2VwdCogc2V0LWNvb2tpZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9kNWUzNjNiNzdlYmFmMWNhZjY3Y2Q3NTI4MjI0YjY1MWM4NjgxNWMxL2xpYi9faHR0cF9pbmNvbWluZy5qcyNMMTI4XG4gIFJlYWN0IE5hdGl2ZSdzIGZldGNoIGRvZXMgdGhpcyBmb3IgKmV2ZXJ5KiBoZWFkZXIsIGluY2x1ZGluZyBzZXQtY29va2llLlxuXG4gIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2oyb2JqYy9jb21taXQvMTY4MjBmZGJjOGY3NmNhMGMzMzQ3MjgxMGNlMGNiMDNkMjBlZmUyNVxuICBDcmVkaXRzIHRvOiBodHRwczovL2dpdGh1Yi5jb20vdG9tYmFsbCBmb3Igb3JpZ2luYWwgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJ1c2FydCBmb3IgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuKi9cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb29raWVzU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcblxuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgLy8gJywnIGlzIGEgY29va2llIHNlcGFyYXRvciBpZiB3ZSBoYXZlIGxhdGVyIGZpcnN0ICc9Jywgbm90ICc7JyBvciAnLCdcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAvLyB3ZSBmb3VuZCBjb29raWVzIHNlcGFyYXRvclxuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguc2Nzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5zY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cywgRnJhZ21lbnQgYXMgX0ZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgJy4vaW5kZXguc2Nzcyc7XG5pbXBvcnQgeyBMaW5rLCBSb3V0ZXMsIFJvdXRlIH0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcbmltcG9ydCBBYm91dFBhZ2UgZnJvbSBcIi4vcGFnZXMvQWJvdXRQYWdlL0Fib3V0UGFnZVwiO1xuaW1wb3J0IE1haW5QYWdlIGZyb20gXCIuL3BhZ2VzL01haW5QYWdlL01haW5QYWdlXCI7XG52YXIgQXBwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoX2pzeChfRnJhZ21lbnQsIHsgY2hpbGRyZW46IF9qc3hzKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtfanN4KExpbmssIHsgdG86ICcvJywgY2hpbGRyZW46IFwiXFx1MDQxM1xcdTA0M0JcXHUwNDMwXFx1MDQzMlxcdTA0M0RcXHUwNDMwXFx1MDQ0RiBcIiB9KSwgX2pzeChMaW5rLCB7IHRvOiAnL2Fib3V0JywgY2hpbGRyZW46IFwiXFx1MDQxRSBcXHUwNDQxXFx1MDQ0MlxcdTA0NDBcXHUwNDMwXFx1MDQzRFxcdTA0MzhcXHUwNDQ2XFx1MDQzNVwiIH0pLCBfanN4cyhSb3V0ZXMsIHsgY2hpbGRyZW46IFtfanN4KFJvdXRlLCB7IHBhdGg6ICcvYWJvdXQnLCBlbGVtZW50OiBfanN4KEFib3V0UGFnZSwge30pIH0pLCBfanN4KFJvdXRlLCB7IHBhdGg6ICcvJywgZWxlbWVudDogX2pzeChNYWluUGFnZSwge30pIH0pXSB9KV0gfSkgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEFwcDtcbiIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQWJvdXRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNoaWxkcmVuOiBcIkFib3V0IFBhZ2UhXCIgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEFib3V0UGFnZTtcbiIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTWFpblBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIHsgY2hpbGRyZW46IFwiTWFpblBhZ2UhXCIgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IE1haW5QYWdlO1xuIiwiLyoqXG4gKiByZWFjdC1yb3V0ZXIgdjcuMS4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuLy8gbGliL3JvdXRlci9oaXN0b3J5LnRzXG52YXIgQWN0aW9uID0gLyogQF9fUFVSRV9fICovICgoQWN0aW9uMikgPT4ge1xuICBBY3Rpb24yW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgQWN0aW9uMltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgQWN0aW9uMltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbiAgcmV0dXJuIEFjdGlvbjI7XG59KShBY3Rpb24gfHwge30pO1xudmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLCBpbml0aWFsSW5kZXgsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzO1xuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKFxuICAgIChlbnRyeSwgaW5kZXgyKSA9PiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXgyID09PSAwID8gXCJkZWZhdWx0XCIgOiB2b2lkIDBcbiAgICApXG4gICk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoXG4gICAgaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXhcbiAgKTtcbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUgPSBudWxsLCBrZXkpIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZjIodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYyLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZjIodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdzIubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3cyLCB0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCJcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdzIubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93MiwgdG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdzIuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdzIubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xufVxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi50eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG8sXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogdG8gJiYgdG8ua2V5IHx8IGtleSB8fCBjcmVhdGVLZXkoKVxuICB9O1xuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCJcbn0pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZjIsIHZhbGlkYXRlTG9jYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgeyB3aW5kb3c6IHdpbmRvdzIgPSBkb2N1bWVudC5kZWZhdWx0VmlldywgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cyLmhpc3Rvcnk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyAuLi5nbG9iYWxIaXN0b3J5LnN0YXRlLCBpZHg6IGluZGV4IH0sIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZTIodG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdzIubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdzIubG9jYXRpb24ub3JpZ2luIDogd2luZG93Mi5sb2NhdGlvbi5ocmVmO1xuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIGJhc2UsXG4gICAgICBgTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6ICR7aHJlZn1gXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFVSTChocmVmLCBiYXNlKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cyLnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZjIod2luZG93MiwgdG8pO1xuICAgIH0sXG4gICAgY3JlYXRlVVJMLFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgdXJsID0gY3JlYXRlVVJMKHRvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICAgICAgaGFzaDogdXJsLmhhc2hcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgIGdvKG4pIHtcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbi8vIGxpYi9yb3V0ZXIvdXRpbHMudHNcbnZhciBpbW11dGFibGVSb3V0ZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCJcbl0pO1xuZnVuY3Rpb24gaXNJbmRleFJvdXRlKHJvdXRlKSB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBwYXJlbnRQYXRoID0gW10sIG1hbmlmZXN0ID0ge30pIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBTdHJpbmcoaW5kZXgpXTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFtYW5pZmVzdFtpZF0sXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzYFxuICAgICk7XG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gaW5kZXhSb3V0ZTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGUgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlKSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICB0cmVlUGF0aCxcbiAgICAgICAgICBtYW5pZmVzdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSA9IFwiL1wiKSB7XG4gIHJldHVybiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSwgYWxsb3dQYXJ0aWFsKSB7XG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGRlY29kZWQgPSBkZWNvZGVQYXRoKHBhdGhuYW1lKTtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgZGVjb2RlZCxcbiAgICAgIGFsbG93UGFydGlhbFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtYXRjaCwgbG9hZGVyRGF0YSkge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSxcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZVxuICB9O1xufVxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzID0gW10sIHBhcmVudHNNZXRhID0gW10sIHBhcmVudFBhdGggPSBcIlwiKSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAocm91dGUsIGluZGV4LCByZWxhdGl2ZVBhdGgpID0+IHtcbiAgICBsZXQgbWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoID09PSB2b2lkIDAgPyByb3V0ZS5wYXRoIHx8IFwiXCIgOiByZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksXG4gICAgICAgIGBBYnNvbHV0ZSByb3V0ZSBwYXRoIFwiJHttZXRhLnJlbGF0aXZlUGF0aH1cIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICFyb3V0ZS5wYXRoPy5pbmNsdWRlcyhcIj9cIikpIHtcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBleHBsb2RlZCBvZiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyb3V0ZS5wYXRoKSkge1xuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcbiAgbGV0IHJlcXVpcmVkID0gZmlyc3QucmVwbGFjZSgvXFw/JC8sIFwiXCIpO1xuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXN1bHQucHVzaChcbiAgICAuLi5yZXN0RXhwbG9kZWQubWFwKFxuICAgICAgKHN1YnBhdGgpID0+IHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lm1hcChcbiAgICAoZXhwbG9kZWQpID0+IHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KFxuICAgIChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgIGEucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgKVxuICApO1xufVxudmFyIHBhcmFtUmUgPSAvXjpbXFx3LV0rJC87XG52YXIgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG52YXIgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbnZhciBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG52YXIgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG52YXIgc3BsYXRQZW5hbHR5ID0gLTI7XG52YXIgaXNTcGxhdCA9IChzKSA9PiBzID09PSBcIipcIjtcbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcigocykgPT4gIWlzU3BsYXQocykpLnJlZHVjZShcbiAgICAoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgIGluaXRpYWxTY29yZVxuICApO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgPyAoXG4gICAgLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgKSA6IChcbiAgICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSkge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuICAgIGlmICghbWF0Y2ggJiYgZW5kICYmIGFsbG93UGFydGlhbCAmJiAhcm91dGVzTWV0YVtyb3V0ZXNNZXRhLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4KSB7XG4gICAgICBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLFxuICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGVcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChvcmlnaW5hbFBhdGgsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG4gIGNvbnN0IHN0cmluZ2lmeSA9IChwKSA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbXNbc3Rhcl0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zID0gY29tcGlsZWRQYXJhbXMucmVkdWNlKFxuICAgIChtZW1vMiwgeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWwgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aCkucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICAgIGlmIChpc09wdGlvbmFsICYmICF2YWx1ZSkge1xuICAgICAgICBtZW1vMltwYXJhbU5hbWVdID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9ICh2YWx1ZSB8fCBcIlwiKS5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW8yO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLCBlbmQgPSB0cnVlKSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKS5yZXBsYWNlKC9bXFxcXC4qK14ke318KClbXFxdXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKFxuICAgIC9cXC86KFtcXHctXSspKFxcPyk/L2csXG4gICAgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgcGFyYW1zLnB1c2goeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbCB9KTtcbiAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICB9XG4gICk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lOiBcIipcIiB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjtcbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCJcXFxcLyokXCI7XG4gIH0gZWxzZSBpZiAocGF0aCAhPT0gXCJcIiAmJiBwYXRoICE9PSBcIi9cIikge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICB9XG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB2b2lkIDAgOiBcImlcIik7XG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBhdGgodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCIvXCIpLm1hcCgodikgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL1xcLy9nLCBcIiUyRlwiKSkuam9pbihcIi9cIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSBVUkwgcGF0aCBcIiR7dmFsdWV9XCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpID8gYmFzZW5hbWUubGVuZ3RoIC0gMSA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICBwYXRoXG4gICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmA7XG59XG5mdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PiBpbmRleCA9PT0gMCB8fCBtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKFxuICAgIChtYXRjaCwgaWR4KSA9PiBpZHggPT09IHBhdGhNYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID0gKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG52YXIgam9pblBhdGhzID0gKHBhdGhzKSA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcbnZhciBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZSkgPT4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbnZhciBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoKSA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG52YXIgbm9ybWFsaXplSGFzaCA9IChoYXNoKSA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbnZhciBEYXRhV2l0aFJlc3BvbnNlSW5pdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGF0YTIsIGluaXQpIHtcbiAgICB0aGlzLnR5cGUgPSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTI7XG4gICAgdGhpcy5pbml0ID0gaW5pdCB8fCBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gZGF0YShkYXRhMiwgaW5pdCkge1xuICByZXR1cm4gbmV3IERhdGFXaXRoUmVzcG9uc2VJbml0KFxuICAgIGRhdGEyLFxuICAgIHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXRcbiAgKTtcbn1cbnZhciByZWRpcmVjdCA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LCBoZWFkZXJzIH0pO1xufTtcbnZhciByZWRpcmVjdERvY3VtZW50ID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciByZXBsYWNlID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVwbGFjZVwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgRXJyb3JSZXNwb25zZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIsIGludGVybmFsID0gZmFsc2UpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMi50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGEyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikge1xuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XG59XG5cbi8vIGxpYi9yb3V0ZXIvcm91dGVyLnRzXG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXG4gIFwiUE9TVFwiLFxuICBcIlBVVFwiLFxuICBcIlBBVENIXCIsXG4gIFwiREVMRVRFXCJcbl07XG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1xuICBcIkdFVFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuXTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbnZhciByZWRpcmVjdFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG52YXIgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwNywgMzA4XSk7XG52YXIgSURMRV9OQVZJR0FUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdm9pZCAwLFxuICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgZm9ybURhdGE6IHZvaWQgMCxcbiAganNvbjogdm9pZCAwLFxuICB0ZXh0OiB2b2lkIDBcbn07XG52YXIgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdm9pZCAwLFxuICByZXNldDogdm9pZCAwLFxuICBsb2NhdGlvbjogdm9pZCAwXG59O1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gKHJvdXRlKSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpXG59KTtcbnZhciBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG52YXIgUmVzZXRMb2FkZXJEYXRhU3ltYm9sID0gU3ltYm9sKFwiUmVzZXRMb2FkZXJEYXRhXCIpO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGNvbnN0IGlzQnJvd3NlcjIgPSB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICBpbml0LnJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVN0cmF0ZWd5SW1wbCA9IGluaXQuZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3k7XG4gIGxldCBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbkltcGwgPSBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uO1xuICBsZXQgZnV0dXJlID0ge1xuICAgIC4uLmluaXQuZnV0dXJlXG4gIH07XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICBsZXQgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gbnVsbDtcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiA9IG51bGw7XG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwgJiYgIXBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCkge1xuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH1cbiAgaWYgKGluaXRpYWxNYXRjaGVzICYmICFpbml0Lmh5ZHJhdGlvbkRhdGEpIHtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgaW5pdGlhbE1hdGNoZXMsXG4gICAgICBkYXRhUm91dGVzLFxuICAgICAgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlKSB7XG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGxldCBpbml0aWFsaXplZDtcbiAgaWYgKCFpbml0aWFsTWF0Y2hlcykge1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBbXTtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgbnVsbCxcbiAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICApO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgaW5pdGlhbE1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpKSB7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpKSB7XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGxldCBsb2FkZXJEYXRhID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgOiBudWxsO1xuICAgIGxldCBlcnJvcnMgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIDogbnVsbDtcbiAgICBpZiAoZXJyb3JzKSB7XG4gICAgICBsZXQgaWR4ID0gaW5pdGlhbE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgICAobSkgPT4gZXJyb3JzW20ucm91dGUuaWRdICE9PSB2b2lkIDBcbiAgICAgICk7XG4gICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLnNsaWNlKDAsIGlkeCArIDEpLmV2ZXJ5KChtKSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkoXG4gICAgICAgIChtKSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlcjtcbiAgbGV0IHN0YXRlID0ge1xuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBtYXRjaGVzOiBpbml0aWFsTWF0Y2hlcyxcbiAgICBpbml0aWFsaXplZCxcbiAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgaWYgd2Ugd2VyZSBTU1InZFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgIGxvYWRlckRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmFjdGlvbkRhdGEgfHwgbnVsbCxcbiAgICBlcnJvcnM6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIHx8IGluaXRpYWxFcnJvcnMsXG4gICAgZmV0Y2hlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgbGV0IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgbGV0IHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBudWxsO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oXG4gICAgICAoeyBhY3Rpb246IGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBkZWx0YSB9KSA9PiB7XG4gICAgICAgIGlmICh1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUoKTtcbiAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gcHJvZHVjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbmF2aWdhdGluZyBvdXRzaWRlIHRoZSByb3V0ZXIgdmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyByb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBjcmVhdGVIYXNoUm91dGVyIGFuZCB0aGUgdXNlciBtYW51YWxseSBjaGFuZ2VzIHRoZSBVUkwuXCJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb2NlZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICByZXNldDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZXh0SGlzdG9yeVVwZGF0ZVByb21pc2UudGhlbigoKSA9PiBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChpc0Jyb3dzZXIyKSB7XG4gICAgICByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICBsZXQgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMgPSAoKSA9PiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICByb3V0ZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHJvdXRlcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oXCJQT1BcIiAvKiBQb3AgKi8sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIGluaXRpYWxIeWRyYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGUsIG9wdHMgPSB7fSkge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZVxuICAgIH07XG4gICAgbGV0IHVubW91bnRlZEZldGNoZXJzID0gW107XG4gICAgbGV0IG1vdW50ZWRGZXRjaGVycyA9IFtdO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdW5tb3VudGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCFzdGF0ZS5mZXRjaGVycy5oYXMoa2V5KSAmJiAhZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgWy4uLnN1YnNjcmliZXJzXS5mb3JFYWNoKFxuICAgICAgKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoc3RhdGUsIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzOiB1bm1vdW50ZWRGZXRjaGVycyxcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzOiBvcHRzLnZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgICAgfSlcbiAgICApO1xuICAgIHVubW91bnRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBtb3VudGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBuZXdTdGF0ZSwgeyBmbHVzaFN5bmMgfSA9IHt9KSB7XG4gICAgbGV0IGlzQWN0aW9uUmVsb2FkID0gc3RhdGUuYWN0aW9uRGF0YSAhPSBudWxsICYmIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG4gICAgbGV0IGFjdGlvbkRhdGE7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGEgPyBtZXJnZUxvYWRlckRhdGEoXG4gICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgbmV3U3RhdGUubG9hZGVyRGF0YSxcbiAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sXG4gICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICApIDogc3RhdGUubG9hZGVyRGF0YTtcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQT1BcIiAvKiBQb3AgKi8pIHtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUFVTSFwiIC8qIFB1c2ggKi8pIHtcbiAgICAgIGluaXQuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBPUFwiIC8qIFBvcCAqLykge1xuICAgICAgbGV0IHByaW9yUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAocHJpb3JQYXRocyAmJiBwcmlvclBhdGhzLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChhcHBsaWVkVmlld1RyYW5zaXRpb25zLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCkge1xuICAgICAgbGV0IHRvUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAodG9QYXRocykge1xuICAgICAgICB0b1BhdGhzLmFkZChsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1BhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xvY2F0aW9uLnBhdGhuYW1lXSk7XG4gICAgICAgIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuc2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCB0b1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAvLyBtYXRjaGVzLCBlcnJvcnMsIGZldGNoZXJzIGdvIHRocm91Z2ggYXMtaXNcbiAgICAgICAgYWN0aW9uRGF0YSxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICAgKSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBibG9ja2Vyc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gICAgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQ/LnJlc29sdmUoKTtcbiAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkID0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICB0byxcbiAgICAgIG9wdHM/LmZyb21Sb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG4gICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcbiAgICBuZXh0TG9jYXRpb24gPSB7XG4gICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAuLi5pbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24obmV4dExvY2F0aW9uKVxuICAgIH07XG4gICAgbGV0IHVzZXJSZXBsYWNlID0gb3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCA/IG9wdHMucmVwbGFjZSA6IHZvaWQgMDtcbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgaWYgKHVzZXJSZXBsYWNlID09PSB0cnVlKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkge1xuICAgIH0gZWxzZSBpZiAoc3VibWlzc2lvbiAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICB9XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgOiB2b2lkIDA7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSk7XG4gICAgaWYgKGJsb2NrZXJLZXkpIHtcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB2b2lkIDAsXG4gICAgICAgICAgICByZXNldDogdm9pZCAwLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IG9wdHMgJiYgb3B0cy52aWV3VHJhbnNpdGlvbixcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaWYgKCFwZW5kaW5nUmV2YWxpZGF0aW9uRGZkKSB7XG4gICAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICB9XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7IHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCIgfSk7XG4gICAgbGV0IHByb21pc2UgPSBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkLnByb21pc2U7XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBzdGFydE5hdmlnYXRpb24oXG4gICAgICBwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLFxuICAgICAge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24sXG4gICAgICAgIC8vIFByb3h5IHRocm91Z2ggYW55IHJlbmRpbmcgdmlldyB0cmFuc2l0aW9uXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID09PSB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKG1hdGNoZXMsIHJvdXRlc1RvVXNlLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcbiAgICB9XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgeyBlcnJvciwgbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQWN0aW9uUmVzdWx0O1xuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gW1xuICAgICAgICBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkLFxuICAgICAgICB7IHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLywgZXJyb3I6IG9wdHMucGVuZGluZ0Vycm9yIH1cbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGhhbmRsZUFjdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG9wdHMuc3VibWlzc2lvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgICB7IHJlcGxhY2U6IG9wdHMucmVwbGFjZSwgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgICAgICBsZXQgW3JvdXRlSWQsIHJlc3VsdF0gPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSAmJiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpICYmIHJlc3VsdC5lcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgICAgICBtYXRjaGVzOiBhY3Rpb25SZXN1bHQubWF0Y2hlcyxcbiAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICAgIFtyb3V0ZUlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXRjaGVzID0gYWN0aW9uUmVzdWx0Lm1hdGNoZXMgfHwgbWF0Y2hlcztcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbik7XG4gICAgICBmbHVzaFN5bmMgPSBmYWxzZTtcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgICBpbml0Lmhpc3RvcnksXG4gICAgICAgIHJlcXVlc3QudXJsLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHNob3J0Q2lyY3VpdGVkLFxuICAgICAgbWF0Y2hlczogdXBkYXRlZE1hdGNoZXMsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgb3B0cyAmJiBvcHRzLmluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzIHx8IG1hdGNoZXMsXG4gICAgICAuLi5nZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcywgaXNGb2dPZldhciwgb3B0cyA9IHt9KSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7IG5hdmlnYXRpb24gfSwgeyBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlIH0pO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIGJvdW5kYXJ5SWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGRpc2NvdmVyUmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBsZXQgeyBub3RGb3VuZE1hdGNoZXMsIGVycm9yLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIFthY3Rpb25NYXRjaF0sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlMjtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2UyID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uMiA9IG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24oXG4gICAgICAgICAgcmVzdWx0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIiksXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmVwbGFjZTIgPSBsb2NhdGlvbjIgPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFthY3Rpb25NYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgaXNGb2dPZldhciwgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZTIsIGluaXRpYWxIeWRyYXRpb24sIGZsdXNoU3luYywgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSA9ICFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gJiYgIWluaXRpYWxIeWRyYXRpb247XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KTtcbiAgICAgICAgdXBkYXRlU3RhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICAgICAgICAuLi5hY3Rpb25EYXRhICE9PSB2b2lkIDAgPyB7IGFjdGlvbkRhdGEgfSA6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmbHVzaFN5bmNcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW2JvdW5kYXJ5SWRdOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHsgZXJyb3IsIG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgICApO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVyczIgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciB9IDogbnVsbCxcbiAgICAgICAgICAuLi5nZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpLFxuICAgICAgICAgIC4uLnVwZGF0ZWRGZXRjaGVyczIgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge31cbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgIGxldCB1cGRhdGVzID0ge307XG4gICAgICBpZiAoIWlzRm9nT2ZXYXIpIHtcbiAgICAgICAgdXBkYXRlcy5uYXZpZ2F0aW9uID0gbG9hZGluZ05hdmlnYXRpb247XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XG4gICAgICAgIGlmIChhY3Rpb25EYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB1cGRhdGVzLmFjdGlvbkRhdGEgPSBhY3Rpb25EYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVzLmZldGNoZXJzID0gZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzKHJldmFsaWRhdGluZ0ZldGNoZXJzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVN0YXRlKHVwZGF0ZXMsIHsgZmx1c2hTeW5jIH0pO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChyZi5rZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChmKSA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgcmVxdWVzdFxuICAgICk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGxvYWRlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0Mi5yZXN1bHQsIHRydWUsIHtcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGZldGNoZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdDIua2V5KTtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0Mi5yZXN1bHQsIHRydWUsIHtcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0LFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgICk7XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMgPSB7IC4uLnN0YXRlLmVycm9ycywgLi4uZXJyb3JzIH07XG4gICAgfVxuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPSB1cGRhdGVkRmV0Y2hlcnMgfHwgZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge31cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBpZiAocGVuZGluZ0FjdGlvblJlc3VsdCAmJiAhaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycykge1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoMihrZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpIHtcbiAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBocmVmLFxuICAgICAgcm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbm9ybWFsaXplZFBhdGggfSksXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IGhhbmRsZUZldGNoZXJBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgZmx1c2hTeW5jLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGF3YWl0IGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAgICBrZXksXG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGZsdXNoU3luYyxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG0pIHtcbiAgICAgIGlmICghbS5yb3V0ZS5hY3Rpb24gJiYgIW0ucm91dGUubGF6eSkge1xuICAgICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICAgIHJvdXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNGb2dPZldhciAmJiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgICBwYXRoLFxuICAgICAgICBmZXRjaFJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGRpc2NvdmVyUmVzdWx0LmVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IHBhdGggfSksXG4gICAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0TWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gocmVxdWVzdE1hdGNoZXMsIHBhdGgpO1xuICAgICAgICBpZiAoZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobWF0Y2gpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIHN0YXRlLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgW21hdGNoXSxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCBhY3Rpb25SZXN1bHQsIGZhbHNlLCB7XG4gICAgICAgICAgICBmZXRjaGVyU3VibWlzc2lvbjogc3VibWlzc2lvbixcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBmYWxzZSxcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgW21hdGNoLnJvdXRlLmlkLCBhY3Rpb25SZXN1bHRdXG4gICAgKTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyMiA/IGV4aXN0aW5nRmV0Y2hlcjIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICApO1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHIpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgIHJlZGlyZWN0Mi5yZXN1bHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB7IHByZXZlbnRTY3JvbGxSZXNldCB9XG4gICAgICApO1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB2b2lkIDAsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICApLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShcbiAgICAgIGtleSxcbiAgICAgIGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKSxcbiAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICApO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHN0YXRlLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgW21hdGNoXSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBrZXlcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgcmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCByZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0MiwgaXNOYXZpZ2F0aW9uLCB7XG4gICAgc3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgfSA9IHt9KSB7XG4gICAgaWYgKHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSkge1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgIGludmFyaWFudChsb2NhdGlvbiwgXCJFeHBlY3RlZCBhIExvY2F0aW9uIGhlYWRlciBvbiB0aGUgcmVkaXJlY3QgUmVzcG9uc2VcIik7XG4gICAgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaXNCcm93c2VyMikge1xuICAgICAgbGV0IGlzRG9jdW1lbnRSZWxvYWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UyKSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5hc3NpZ24obG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSA9IHJlcGxhY2UyID09PSB0cnVlIHx8IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVwbGFjZVwiKSA/IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi8gOiBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiAhZmV0Y2hlclN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24pO1xuICAgIH1cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3QyLnJlc3BvbnNlLnN0YXR1cykgJiYgYWN0aXZlU3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKGFjdGl2ZVN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdE5hdmlnYXRpb25UeXBlLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAuLi5hY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgICAgIGZvcm1BY3Rpb246IGxvY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZXNlIGZsYWdzIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwcmV2ZW50U2Nyb2xsUmVzZXQgfHwgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb24sXG4gICAgICAgIC8vIFNlbmQgZmV0Y2hlciBzdWJtaXNzaW9ucyB0aHJvdWdoIGZvciBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneSh0eXBlLCBzdGF0ZTIsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXkpIHtcbiAgICBsZXQgcmVzdWx0cztcbiAgICBsZXQgZGF0YVJlc3VsdHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgICBkYXRhU3RyYXRlZ3lJbXBsLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdGF0ZTIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1hdGNoZXNUb0xvYWQuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICBkYXRhUmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICAgIH1cbiAgICBmb3IgKGxldCBbcm91dGVJZCwgcmVzdWx0XSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHRzKSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICBkYXRhUmVzdWx0c1tyb3V0ZUlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi8sXG4gICAgICAgICAgcmVzcG9uc2U6IG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KFxuICAgICAgICAgIHJlc3VsdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlMiwgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICBsZXQgbG9hZGVyUmVzdWx0c1Byb21pc2UgPSBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIHN0YXRlMixcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0c1Byb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2ggJiYgZi5jb250cm9sbGVyKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgIHN0YXRlMixcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICAgIFtmLm1hdGNoXSxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIGYua2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tmLm1hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgICByZXR1cm4geyBbZi5rZXldOiByZXN1bHQgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIFtmLmtleV06IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogZi5wYXRoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IGF3YWl0IGxvYWRlclJlc3VsdHNQcm9taXNlO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IChhd2FpdCBmZXRjaGVyUmVzdWx0c1Byb21pc2UpLnJlZHVjZShcbiAgICAgIChhY2MsIHIpID0+IE9iamVjdC5hc3NpZ24oYWNjLCByKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0sXG4gICAgICB7IGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSkpIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5kZWxldGUoa2V5KTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcXVldWVGZXRjaGVyRm9yRGVsZXRpb24oa2V5KSB7XG4gICAgbGV0IGNvdW50ID0gKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApIC0gMTtcbiAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCBjb3VudCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHVwZGF0ZWRGZXRjaGVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoZG9uZUtleXMpO1xuICAgIHJldHVybiB1cGRhdGVkRmV0Y2hlcnM7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5LCBmbikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5KSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleSwgbmV3QmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGludmFyaWFudChcbiAgICAgIGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLFxuICAgICAgYEludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiAke2Jsb2NrZXIuc3RhdGV9IC0+ICR7bmV3QmxvY2tlci5zdGF0ZX1gXG4gICAgKTtcbiAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICBibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uXG4gIH0pIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xuICAgIGxldCBbYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KTtcbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQocGF0aG5hbWUpIHtcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZSB9KTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgcmV0dXJuIHsgbm90Rm91bmRNYXRjaGVzOiBtYXRjaGVzLCByb3V0ZSwgZXJyb3IgfTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihwb3NpdGlvbnMsIGdldFBvc2l0aW9uLCBnZXRLZXkpIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5Mikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ga2V5IHx8IGxvY2F0aW9uLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uLmtleTtcbiAgfVxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMltrZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9uczIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgcGF0aG5hbWUpIHtcbiAgICBpZiAocGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgbGV0IGZvZ01hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIG1hdGNoZXM6IGZvZ01hdGNoZXMgfHwgW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtYXRjaGVzWzBdLnBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7IGFjdGl2ZTogdHJ1ZSwgbWF0Y2hlczogcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhY3RpdmU6IGZhbHNlLCBtYXRjaGVzOiBudWxsIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgcGF0aG5hbWUsIHNpZ25hbCkge1xuICAgIGlmICghcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlcyB9O1xuICAgIH1cbiAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcbiAgICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgICAgbGV0IGxvY2FsTWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCh7XG4gICAgICAgICAgcGF0aDogcGF0aG5hbWUsXG4gICAgICAgICAgbWF0Y2hlczogcGFydGlhbE1hdGNoZXMsXG4gICAgICAgICAgcGF0Y2g6IChyb3V0ZUlkLCBjaGlsZHJlbikgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgICBwYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICAgICAgbG9jYWxNYW5pZmVzdCxcbiAgICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBlLCBwYXJ0aWFsTWF0Y2hlcyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGlzTm9uSE1SICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImFib3J0ZWRcIiB9O1xuICAgICAgfVxuICAgICAgbGV0IG5ld01hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgcGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICAgIGlmIChuZXdNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzOiBuZXdNYXRjaGVzIH07XG4gICAgICB9XG4gICAgICBsZXQgbmV3UGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoIW5ld1BhcnRpYWxNYXRjaGVzIHx8IHBhcnRpYWxNYXRjaGVzLmxlbmd0aCA9PT0gbmV3UGFydGlhbE1hdGNoZXMubGVuZ3RoICYmIHBhcnRpYWxNYXRjaGVzLmV2ZXJ5KFxuICAgICAgICAobSwgaSkgPT4gbS5yb3V0ZS5pZCA9PT0gbmV3UGFydGlhbE1hdGNoZXNbaV0ucm91dGUuaWRcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXM6IG51bGwgfTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxNYXRjaGVzID0gbmV3UGFydGlhbE1hdGNoZXM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9pbnRlcm5hbFNldFJvdXRlcyhuZXdSb3V0ZXMpIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICBuZXdSb3V0ZXMsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgdm9pZCAwLFxuICAgICAgbWFuaWZlc3RcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHBhdGNoUm91dGVzKHJvdXRlSWQsIGNoaWxkcmVuKSB7XG4gICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgcm91dGVJZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICApO1xuICAgIGlmIChpc05vbkhNUikge1xuICAgICAgZGF0YVJvdXRlcyA9IFsuLi5kYXRhUm91dGVzXTtcbiAgICAgIHVwZGF0ZVN0YXRlKHt9KTtcbiAgICB9XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXG4gICAgLy8gaGFzaC1hd2FyZSBVUkxzIGluIERPTSBwYXRoc1xuICAgIGNyZWF0ZUhyZWY6ICh0bykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG8pID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBxdWV1ZUZldGNoZXJGb3JEZWxldGlvbixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBwYXRjaFJvdXRlcyxcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzXG4gIH07XG4gIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzMiA9IG9wdHM/Lm1hcFJvdXRlUHJvcGVydGllcyB8fCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHJlcXVlc3QsIHtcbiAgICByZXF1ZXN0Q29udGV4dCxcbiAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICBkYXRhU3RyYXRlZ3lcbiAgfSA9IHt9KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA9PT0gdHJ1ZSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7IGxvY2F0aW9uLCBiYXNlbmFtZSwgLi4ucmVzdWx0IH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCB7XG4gICAgcm91dGVJZCxcbiAgICByZXF1ZXN0Q29udGV4dCxcbiAgICBkYXRhU3RyYXRlZ3lcbiAgfSA9IHt9KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIiAmJiBtZXRob2QgIT09IFwiT1BUSU9OU1wiKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkID8gbWF0Y2hlcy5maW5kKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAocm91dGVJZCAmJiAhbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAzLCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXRjaFxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB2b2lkIDA7XG4gICAgaWYgKGVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgcm91dGVNYXRjaCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgIGxldCByZXN1bHQyID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgICAgcm91dGVNYXRjaCAhPSBudWxsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICByb3V0ZU1hdGNoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNEYXRhU3RyYXRlZ3lSZXN1bHQoZSkgJiYgaXNSZXNwb25zZShlLnJlc3VsdCkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChyZXF1ZXN0LCBtYXRjaGVzLCBhY3Rpb25NYXRjaCwgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IGFjdGlvbk1hdGNoIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dDIgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb250ZXh0MixcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsID8gcmVzdWx0LnN0YXR1c0NvZGUgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5yZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgIGxvYWRlclJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4ucmVzdWx0LnN0YXR1c0NvZGUgPyB7IHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlIH0gOiB7fSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge31cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sb2FkZXIgJiYgIXJvdXRlTWF0Y2g/LnJvdXRlLmxhenkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogcm91dGVNYXRjaD8ucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgcGVuZGluZ0FjdGlvblJlc3VsdFswXSkgOiBtYXRjaGVzO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0ucm91dGUubG9hZGVyIHx8IG0ucm91dGUubGF6eVxuICAgICk7XG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbS5yb3V0ZS5pZF06IG51bGwgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICBcImxvYWRlclwiLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBtYXRjaGVzLFxuICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneVxuICAgICk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHRydWUsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZ1xuICAgICk7XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQoXG4gICAgICBtYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+IG1hdGNoLnJvdXRlLmlkKVxuICAgICk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKCFleGVjdXRlZExvYWRlcnMuaGFzKG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgICBjb250ZXh0LmxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1hdGNoZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kodHlwZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpIHtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3ksXG4gICAgICB0eXBlLFxuICAgICAgbnVsbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG51bGwsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgICk7XG4gICAgbGV0IGRhdGFSZXN1bHRzID0ge307XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBtYXRjaGVzLm1hcChhc3luYyAobWF0Y2gpID0+IHtcbiAgICAgICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgICBpZiAoaXNSZWRpcmVjdERhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB0aHJvdyBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRhdGFSZXN1bHRzW21hdGNoLnJvdXRlLmlkXSA9IGF3YWl0IGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQocmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3Iocm91dGVzLCBjb250ZXh0LCBlcnJvcikge1xuICBsZXQgbmV3Q29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yXG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cbmZ1bmN0aW9uIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zaWduYWwucmVhc29uICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyByZXF1ZXN0LnNpZ25hbC5yZWFzb247XG4gIH1cbiAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkIHdpdGhvdXQgYW4gXFxgQWJvcnRTaWduYWwucmVhc29uXFxgOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHZvaWQgMCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHRvLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb250ZXh0dWFsTWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gZnJvbVJvdXRlSWQpIHtcbiAgICAgICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8gPyB0byA6IFwiLlwiLFxuICAgIGdldFJlc29sdmVUb01hdGNoZXMoY29udGV4dHVhbE1hdGNoZXMpLFxuICAgIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgKTtcbiAgaWYgKHRvID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBwYXRoLmhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICB9XG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2gpIHtcbiAgICBsZXQgbmFrZWRJbmRleCA9IGhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaCk7XG4gICAgaWYgKGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgIW5ha2VkSW5kZXgpIHtcbiAgICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgICB9IGVsc2UgaWYgKCFhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmIG5ha2VkSW5kZXgpIHtcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIGluZGV4VmFsdWVzLmZpbHRlcigodikgPT4gdikuZm9yRWFjaCgodikgPT4gcGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHYpKTtcbiAgICAgIGxldCBxcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBxcyA/IGA/JHtxc31gIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGlzRmV0Y2hlciwgcGF0aCwgb3B0cykge1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImludmFsaWQtYm9keVwiIH0pXG4gIH0pO1xuICBsZXQgcmF3Rm9ybU1ldGhvZCA9IG9wdHMuZm9ybU1ldGhvZCB8fCBcImdldFwiO1xuICBsZXQgZm9ybU1ldGhvZCA9IHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcbiAgaWYgKG9wdHMuYm9keSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IG9wdHMuYm9keSA6IG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8IG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IChcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgW25hbWUsIHZhbHVlXSkgPT4gYCR7YWNjfSR7bmFtZX09JHt2YWx1ZX1cbmAsXG4gICAgICAgICAgXCJcIlxuICAgICAgICApXG4gICAgICApIDogU3RyaW5nKG9wdHMuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICAgICAganNvbjogdm9pZCAwLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uob3B0cy5ib2R5KSA6IG9wdHMuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KFxuICAgIHR5cGVvZiBGb3JtRGF0YSA9PT0gXCJmdW5jdGlvblwiLFxuICAgIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCJcbiAgKTtcbiAgbGV0IHNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwXG4gIH07XG4gIGlmIChpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4geyBwYXRoLCBzdWJtaXNzaW9uIH07XG4gIH1cbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcbiAgcmV0dXJuIHsgcGF0aDogY3JlYXRlUGF0aChwYXJzZWRQYXRoKSwgc3VibWlzc2lvbiB9O1xufVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCwgaW5jbHVkZUJvdW5kYXJ5ID0gZmFsc2UpIHtcbiAgbGV0IGluZGV4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGluY2x1ZGVCb3VuZGFyeSA/IGluZGV4ICsgMSA6IGluZGV4KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpbml0aWFsSHlkcmF0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhIDogdm9pZCAwO1xuICBsZXQgY3VycmVudFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0YXRlLmxvY2F0aW9uKTtcbiAgbGV0IG5leHRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChsb2NhdGlvbik7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzO1xuICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShcbiAgICAgIG1hdGNoZXMsXG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZS5lcnJvcnMpWzBdLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pKSB7XG4gICAgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICBtYXRjaGVzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFswXVxuICAgICk7XG4gIH1cbiAgbGV0IGFjdGlvblN0YXR1cyA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLnN0YXR1c0NvZGUgOiB2b2lkIDA7XG4gIGxldCBzaG91bGRTa2lwUmV2YWxpZGF0aW9uID0gYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cyA+PSA0MDA7XG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCB7IHJvdXRlIH0gPSBtYXRjaDtcbiAgICBpZiAocm91dGUubGF6eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuIHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKHJvdXRlLCBzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5lcnJvcnMpO1xuICAgIH1cbiAgICBpZiAoaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCB7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG5leHRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICBhY3Rpb25TdGF0dXMsXG4gICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogKFxuICAgICAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHwgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHwgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoIHx8IGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpXG4gICAgICApXG4gICAgfSk7XG4gIH0pO1xuICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcnMgPSBbXTtcbiAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChmLCBrZXkpID0+IHtcbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiB8fCAhbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpIHx8IGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuICAgIGlmICghZmV0Y2hlck1hdGNoZXMpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBudWxsLFxuICAgICAgICBtYXRjaDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5oYXMoa2V5KSkge1xuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmRlbGV0ZShrZXkpO1xuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgIT09IFwiaWRsZVwiICYmIGZldGNoZXIuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gaXNSZXZhbGlkYXRpb25SZXF1aXJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCB7XG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbc3RhdGUubWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgYWN0aW9uU3RhdHVzLFxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogaXNSZXZhbGlkYXRpb25SZXF1aXJlZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuZnVuY3Rpb24gc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24ocm91dGUsIGxvYWRlckRhdGEsIGVycm9ycykge1xuICBpZiAocm91dGUubGF6eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghcm91dGUubG9hZGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBoYXNEYXRhID0gbG9hZGVyRGF0YSAhPSBudWxsICYmIGxvYWRlckRhdGFbcm91dGUuaWRdICE9PSB2b2lkIDA7XG4gIGxldCBoYXNFcnJvciA9IGVycm9ycyAhPSBudWxsICYmIGVycm9yc1tyb3V0ZS5pZF0gIT09IHZvaWQgMDtcbiAgaWYgKCFoYXNEYXRhICYmIGhhc0Vycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2Ygcm91dGUubG9hZGVyID09PSBcImZ1bmN0aW9uXCIgJiYgcm91dGUubG9hZGVyLmh5ZHJhdGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gIWhhc0RhdGEgJiYgIWhhc0Vycm9yO1xufVxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoY3VycmVudExvYWRlckRhdGEsIGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGlzTmV3ID0gKFxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8IC8vIFthLCBiXSAtPiBbYSwgY11cbiAgICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkXG4gICk7XG4gIGxldCBpc01pc3NpbmdEYXRhID0gIWN1cnJlbnRMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KG1hdGNoLnJvdXRlLmlkKTtcbiAgcmV0dXJuIGlzTmV3IHx8IGlzTWlzc2luZ0RhdGE7XG59XG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIGN1cnJlbnRQYXRoICE9IG51bGwgJiYgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGxvYWRlck1hdGNoLCBhcmcpIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIHBhdGNoUm91dGVzSW1wbChyb3V0ZUlkLCBjaGlsZHJlbiwgcm91dGVzVG9Vc2UsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyKSB7XG4gIGxldCBjaGlsZHJlblRvUGF0Y2g7XG4gIGlmIChyb3V0ZUlkKSB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUsXG4gICAgICBgTm8gcm91dGUgZm91bmQgdG8gcGF0Y2ggY2hpbGRyZW4gaW50bzogcm91dGVJZCA9ICR7cm91dGVJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZS5jaGlsZHJlbjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZXNUb1VzZTtcbiAgfVxuICBsZXQgdW5pcXVlQ2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoXG4gICAgKG5ld1JvdXRlKSA9PiAhY2hpbGRyZW5Ub1BhdGNoLnNvbWUoXG4gICAgICAoZXhpc3RpbmdSb3V0ZSkgPT4gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpXG4gICAgKVxuICApO1xuICBsZXQgbmV3Um91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICB1bmlxdWVDaGlsZHJlbixcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIFtyb3V0ZUlkIHx8IFwiX1wiLCBcInBhdGNoXCIsIFN0cmluZyhjaGlsZHJlblRvUGF0Y2g/Lmxlbmd0aCB8fCBcIjBcIildLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGNoaWxkcmVuVG9QYXRjaC5wdXNoKC4uLm5ld1JvdXRlcyk7XG59XG5mdW5jdGlvbiBpc1NhbWVSb3V0ZShuZXdSb3V0ZSwgZXhpc3RpbmdSb3V0ZSkge1xuICBpZiAoXCJpZFwiIGluIG5ld1JvdXRlICYmIFwiaWRcIiBpbiBleGlzdGluZ1JvdXRlICYmIG5ld1JvdXRlLmlkID09PSBleGlzdGluZ1JvdXRlLmlkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEobmV3Um91dGUuaW5kZXggPT09IGV4aXN0aW5nUm91dGUuaW5kZXggJiYgbmV3Um91dGUucGF0aCA9PT0gZXhpc3RpbmdSb3V0ZS5wYXRoICYmIG5ld1JvdXRlLmNhc2VTZW5zaXRpdmUgPT09IGV4aXN0aW5nUm91dGUuY2FzZVNlbnNpdGl2ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCghbmV3Um91dGUuY2hpbGRyZW4gfHwgbmV3Um91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiAoIWV4aXN0aW5nUm91dGUuY2hpbGRyZW4gfHwgZXhpc3RpbmdSb3V0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG5ld1JvdXRlLmNoaWxkcmVuLmV2ZXJ5KFxuICAgIChhQ2hpbGQsIGkpID0+IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4/LnNvbWUoKGJDaGlsZCkgPT4gaXNTYW1lUm91dGUoYUNoaWxkLCBiQ2hpbGQpKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShyb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QpIHtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBsYXp5Um91dGUgPSBhd2FpdCByb3V0ZS5sYXp5KCk7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdm9pZCAwICYmIC8vIFRoaXMgcHJvcGVydHkgaXNuJ3Qgc3RhdGljIHNpbmNlIGl0IHNob3VsZCBhbHdheXMgYmUgdXBkYXRlZCBiYXNlZFxuICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXG4gICAgbGF6eVJvdXRlUHJvcGVydHkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuICAgIHdhcm5pbmcoXG4gICAgICAhaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkLFxuICAgICAgYFJvdXRlIFwiJHtyb3V0ZVRvVXBkYXRlLmlkfVwiIGhhcyBhIHN0YXRpYyBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgZGVmaW5lZCBidXQgaXRzIGxhenkgZnVuY3Rpb24gaXMgYWxzbyByZXR1cm5pbmcgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIHdpbGwgYmUgaWdub3JlZC5gXG4gICAgKTtcbiAgICBpZiAoIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCAmJiAhaW1tdXRhYmxlUm91dGVLZXlzLmhhcyhsYXp5Um91dGVQcm9wZXJ0eSkpIHtcbiAgICAgIHJvdXRlVXBkYXRlc1tsYXp5Um91dGVQcm9wZXJ0eV0gPSBsYXp5Um91dGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwge1xuICAgIC8vIFRvIGtlZXAgdGhpbmdzIGZyYW1ld29yayBhZ25vc3RpYywgd2UgdXNlIHRoZSBwcm92aWRlZCBgbWFwUm91dGVQcm9wZXJ0aWVzYFxuICAgIC8vIGZ1bmN0aW9uIHRvIHNldCB0aGUgZnJhbWV3b3JrLWF3YXJlIHByb3BlcnRpZXMgKGBlbGVtZW50YC9gaGFzRXJyb3JCb3VuZGFyeWApXG4gICAgLy8gc2luY2UgdGhlIGxvZ2ljIHdpbGwgZGlmZmVyIGJldHdlZW4gZnJhbWV3b3Jrcy5cbiAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlVG9VcGRhdGUpLFxuICAgIGxhenk6IHZvaWQgMFxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3koe1xuICBtYXRjaGVzXG59KSB7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gbWF0Y2hlcy5maWx0ZXIoKG0pID0+IG0uc2hvdWxkTG9hZCk7XG4gIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlc1RvTG9hZC5tYXAoKG0pID0+IG0ucmVzb2x2ZSgpKSk7XG4gIHJldHVybiByZXN1bHRzLnJlZHVjZShcbiAgICAoYWNjLCByZXN1bHQsIGkpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttYXRjaGVzVG9Mb2FkW2ldLnJvdXRlLmlkXTogcmVzdWx0IH0pLFxuICAgIHt9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5SW1wbChkYXRhU3RyYXRlZ3lJbXBsLCB0eXBlLCBzdGF0ZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgZmV0Y2hlcktleSwgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIsIHJlcXVlc3RDb250ZXh0KSB7XG4gIGxldCBsb2FkUm91dGVEZWZpbml0aW9uc1Byb21pc2VzID0gbWF0Y2hlcy5tYXAoXG4gICAgKG0pID0+IG0ucm91dGUubGF6eSA/IGxvYWRMYXp5Um91dGVNb2R1bGUobS5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QpIDogdm9pZCAwXG4gICk7XG4gIGxldCBkc01hdGNoZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gsIGkpID0+IHtcbiAgICBsZXQgbG9hZFJvdXRlUHJvbWlzZSA9IGxvYWRSb3V0ZURlZmluaXRpb25zUHJvbWlzZXNbaV07XG4gICAgbGV0IHNob3VsZExvYWQgPSBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IG1hdGNoLnJvdXRlLmlkKTtcbiAgICBsZXQgcmVzb2x2ZSA9IGFzeW5jIChoYW5kbGVyT3ZlcnJpZGUpID0+IHtcbiAgICAgIGlmIChoYW5kbGVyT3ZlcnJpZGUgJiYgcmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIgJiYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbWF0Y2gucm91dGUubG9hZGVyKSkge1xuICAgICAgICBzaG91bGRMb2FkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRMb2FkID8gY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICB0eXBlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbG9hZFJvdXRlUHJvbWlzZSxcbiAgICAgICAgaGFuZGxlck92ZXJyaWRlLFxuICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIHJlc3VsdDogdm9pZCAwIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgc2hvdWxkTG9hZCxcbiAgICAgIHJlc29sdmVcbiAgICB9O1xuICB9KTtcbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBkYXRhU3RyYXRlZ3lJbXBsKHtcbiAgICBtYXRjaGVzOiBkc01hdGNoZXMsXG4gICAgcmVxdWVzdCxcbiAgICBwYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgIGZldGNoZXJLZXksXG4gICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcbiAgfSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZFJvdXRlRGVmaW5pdGlvbnNQcm9taXNlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbG9hZFJvdXRlUHJvbWlzZSwgaGFuZGxlck92ZXJyaWRlLCBzdGF0aWNDb250ZXh0KSB7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDtcbiAgbGV0IHJ1bkhhbmRsZXIgPSAoaGFuZGxlcikgPT4ge1xuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgbGV0IGFjdHVhbEhhbmRsZXIgPSAoY3R4KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW5ub3QgY2FsbCB0aGUgaGFuZGxlciBmb3IgYSByb3V0ZSB3aGljaCBkZWZpbmVzIGEgYm9vbGVhbiBcIiR7dHlwZX1cIiBbcm91dGVJZDogJHttYXRjaC5yb3V0ZS5pZH1dYFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVyKFxuICAgICAgICB7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgICBjb250ZXh0OiBzdGF0aWNDb250ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmN0eCAhPT0gdm9pZCAwID8gW2N0eF0gOiBbXVxuICAgICAgKTtcbiAgICB9O1xuICAgIGxldCBoYW5kbGVyUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdmFsID0gYXdhaXQgKGhhbmRsZXJPdmVycmlkZSA/IGhhbmRsZXJPdmVycmlkZSgoY3R4KSA9PiBhY3R1YWxIYW5kbGVyKGN0eCkpIDogYWN0dWFsSGFuZGxlcigpKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdDogdmFsIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtoYW5kbGVyUHJvbWlzZSwgYWJvcnRQcm9taXNlXSk7XG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICBpZiAobG9hZFJvdXRlUHJvbWlzZSkge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IFt2YWx1ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbG9hZFJvdXRlUHJvbWlzZVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGhhbmRsZXJFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgaGFuZGxlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgbG9hZFJvdXRlUHJvbWlzZTtcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIHJlc3VsdDogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLywgcmVzdWx0OiBlIH07XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9uUmVqZWN0KSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChkYXRhU3RyYXRlZ3lSZXN1bHQpIHtcbiAgbGV0IHsgcmVzdWx0LCB0eXBlIH0gPSBkYXRhU3RyYXRlZ3lSZXN1bHQ7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgZGF0YTI7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhMiA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEyID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBlIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YTIpLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiBkYXRhMixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChyZXN1bHQuZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHJlc3VsdC5pbml0Py5zdGF0dXMgfHwgNTAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlc3VsdC5kYXRhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgZXJyb3I6IHJlc3VsdCxcbiAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5pbml0Py5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCBkYXRhOiByZXN1bHQgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QsIHJvdXRlSWQsIG1hdGNoZXMsIGJhc2VuYW1lKSB7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGludmFyaWFudChcbiAgICBsb2NhdGlvbixcbiAgICBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCJcbiAgKTtcbiAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDFcbiAgICApO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIHRyaW1tZWRNYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgY3VycmVudFVybCwgYmFzZW5hbWUpIHtcbiAgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIGxldCBub3JtYWxpemVkTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbm9ybWFsaXplZExvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIG5vcm1hbGl6ZWRMb2NhdGlvbikgOiBuZXcgVVJMKG5vcm1hbGl6ZWRMb2NhdGlvbik7XG4gICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgIGlmICh1cmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBpc1NhbWVCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsIH07XG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogZm9ybUVuY1R5cGUgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJiBzdWJtaXNzaW9uLmZvcm1EYXRhKSB7XG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBpc1N0YXRpY0hhbmRsZXIgPSBmYWxzZSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPSBmYWxzZSkge1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdm9pZCAwO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaWRdO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICBpZiAocGVuZGluZ0Vycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgZXJyb3IgPSBwZW5kaW5nRXJyb3I7XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIGlmIChza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xuICAgICAgICBlcnJvcnNbaWRdID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1N0YXRpY0hhbmRsZXIpIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSBSZXNldExvYWRlckRhdGFTeW1ib2w7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBlcnJvcnMgPSB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0Vycm9yIH07XG4gICAgbG9hZGVyRGF0YVtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMpIHtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgIG1hdGNoZXMsXG4gICAgcmVzdWx0cyxcbiAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICk7XG4gIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgbGV0IHsga2V5LCBtYXRjaCwgY29udHJvbGxlciB9ID0gcmY7XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2tleV07XG4gICAgaW52YXJpYW50KHJlc3VsdCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaD8ucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgIC4uLmVycm9ycyxcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBsb2FkZXJEYXRhLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBPYmplY3QuZW50cmllcyhuZXdMb2FkZXJEYXRhKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBSZXNldExvYWRlckRhdGFTeW1ib2wpLnJlZHVjZSgobWVyZ2VkLCBbaywgdl0pID0+IHtcbiAgICBtZXJnZWRba10gPSB2O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmICghbmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICBpZiAoIXBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgLy8gQ2xlYXIgb3V0IHByaW9yIGFjdGlvbkRhdGEgb24gZXJyb3JzXG4gICAgYWN0aW9uRGF0YToge31cbiAgfSA6IHtcbiAgICBhY3Rpb25EYXRhOiB7XG4gICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgcm91dGVJZCkge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZCA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZCgocikgPT4gci5pbmRleCB8fCAhci5wYXRoIHx8IHIucGF0aCA9PT0gXCIvXCIpIHx8IHtcbiAgICBpZDogYF9fc2hpbS1lcnJvci1yb3V0ZV9fYFxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHBhdGhuYW1lQmFzZTogXCJcIixcbiAgICAgICAgcm91dGVcbiAgICAgIH1cbiAgICBdLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywge1xuICBwYXRobmFtZSxcbiAgcm91dGVJZCxcbiAgbWV0aG9kLFxuICB0eXBlLFxuICBtZXNzYWdlXG59ID0ge30pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBZb3UgbWFkZSBhICR7bWV0aG9kfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnZhbGlkLWJvZHlcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmFibGUgdG8gZW5jb2RlIHN1Ym1pc3Npb24gYm9keVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGFuIFxcYGFjdGlvblxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICBzdGF0dXMgfHwgNTAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhyZXN1bHRzKTtcbiAgZm9yIChsZXQgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgW2tleSwgcmVzdWx0XSA9IGVudHJpZXNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHsga2V5LCByZXN1bHQgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XG4gIHJldHVybiBjcmVhdGVQYXRoKHsgLi4ucGFyc2VkUGF0aCwgaGFzaDogXCJcIiB9KTtcbn1cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYSwgYikge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gcmVzdWx0ICYmIFwicmVzdWx0XCIgaW4gcmVzdWx0ICYmIChyZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIgLyogZGF0YSAqLyB8fCByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi87XG59XG5mdW5jdGlvbiBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCAmJiBcInR5cGVcIiBpbiB2YWx1ZSAmJiBcImRhdGFcIiBpbiB2YWx1ZSAmJiBcImluaXRcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0U3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXNDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuc3RhdHVzKSAmJiByZXN1bHQuaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBzZWFyY2ggPSB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIHRleHQsIGZvcm1EYXRhLCBqc29uIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhMikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IGRhdGEyXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVlcbiAgICApO1xuICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcbiAgICAgICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnNldChrLCBuZXcgU2V0KHYgfHwgW10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlICgke2Vycm9yfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9jb21wb25lbnRzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvY29udGV4dC50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgRGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbnZhciBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xudmFyIFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcblZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbnZhciBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4pO1xuRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xudmFyIEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Bd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbnZhciBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xudmFyIFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxuICBpc0RhdGFSb3V0ZTogZmFsc2Vcbn0pO1xuUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xudmFyIFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG5cbi8vIGxpYi9ob29rcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciBFTkFCTEVfREVWX1dBUk5JTkdTID0gdHJ1ZTtcbmZ1bmN0aW9uIHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvcjogbmF2aWdhdG9yMiB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvcjIuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBkZWNvZGVQYXRoKHBhdGhuYW1lKSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxudmFyIG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gO1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgUmVhY3QyLnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQgeyBpc0RhdGFSb3V0ZSB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlVW5zdGFibGUoKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvcjogbmF2aWdhdG9yMiB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yMi5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvcjIucmVwbGFjZSA6IG5hdmlnYXRvcjIucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcjIsXG4gICAgICByb3V0ZVBhdGhuYW1lc0pzb24sXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgZGF0YVJvdXRlckNvbnRleHRcbiAgICBdXG4gICk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbnZhciBPdXRsZXRDb250ZXh0ID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gcmVzb2x2ZVRvKFxuICAgICAgdG8sXG4gICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IG5hdmlnYXRvcjogbmF2aWdhdG9yMiB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqP1wiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBcIiR7cGFyZW50UGF0aG5hbWV9XCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPikgYnV0IHRoZSBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIHJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cblxuUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IGAke3BhcmVudFBhdGh9LypgfVwiPi5gXG4gICAgKTtcbiAgfVxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgdGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChwYXJlbnRQYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgbGV0IHBhcmVudFNlZ21lbnRzID0gcGFyZW50UGF0aG5hbWVCYXNlLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgbGV0IHNlZ21lbnRzID0gcGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IFwiL1wiICsgc2VnbWVudHMuc2xpY2UocGFyZW50U2VnbWVudHMubGVuZ3RoKS5qb2luKFwiL1wiKTtcbiAgfVxuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgeyBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUgfSk7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHZvaWQgMCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB2b2lkIDAgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmxhenkgIT09IHZvaWQgMCxcbiAgICAgIGBNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKFxuICAgIG1hdGNoZXMgJiYgbWF0Y2hlcy5tYXAoXG4gICAgICAobWF0Y2gpID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtcbiAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICBuYXZpZ2F0b3IyLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZVxuICAgICAgICBdKSxcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtcbiAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICBuYXZpZ2F0b3IyLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yMi5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXG4gICAgICAgIF0pXG4gICAgICB9KVxuICAgICksXG4gICAgcGFyZW50TWF0Y2hlcyxcbiAgICBkYXRhUm91dGVyU3RhdGUsXG4gICAgZnV0dXJlXG4gICk7XG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ubG9jYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdmlnYXRpb25UeXBlOiBcIlBPUFwiIC8qIFBvcCAqL1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyZWRNYXRjaGVzXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICBsZXQgZXJyb3IgPSB1c2VSb3V0ZUVycm9yKCk7XG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gYCR7ZXJyb3Iuc3RhdHVzfSAke2Vycm9yLnN0YXR1c1RleHR9YCA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMC41cmVtXCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBjb2RlU3R5bGVzID0geyBwYWRkaW5nOiBcIjJweCA0cHhcIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIixcbiAgICAgIGVycm9yXG4gICAgKTtcbiAgICBkZXZJbmZvID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9XCIpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5IHByb3ZpZGluZyB5b3VyIG93biBcIiwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBjb2RlU3R5bGVzIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgeyBzdHlsZTogY29kZVN0eWxlcyB9LCBcImVycm9yRWxlbWVudFwiKSwgXCIgcHJvcCBvbiB5b3VyIHJvdXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiVW5leHBlY3RlZCBBcHBsaWNhdGlvbiBFcnJvciFcIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImgzXCIsIHsgc3R5bGU6IHsgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0gfSwgbWVzc2FnZSksIHN0YWNrID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgc3R5bGU6IHByZVN0eWxlcyB9LCBzdGFjaykgOiBudWxsLCBkZXZJbmZvKTtcbn1cbnZhciBkZWZhdWx0RXJyb3JFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KERlZmF1bHRFcnJvckNvbXBvbmVudCwgbnVsbCk7XG52YXIgUmVuZGVyRXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QyLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvclxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvbiAhPT0gXCJpZGxlXCIgJiYgcHJvcHMucmV2YWxpZGF0aW9uID09PSBcImlkbGVcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yICE9PSB2b2lkIDAgPyBwcm9wcy5lcnJvciA6IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgIT09IHZvaWQgMCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XG4gICAgICB9XG4gICAgKSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59O1xuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZSh7IHJvdXRlQ29udGV4dCwgbWF0Y2gsIGNoaWxkcmVuIH0pIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm91dGVDb250ZXh0IH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMgPSBbXSwgZGF0YVJvdXRlclN0YXRlID0gbnVsbCwgZnV0dXJlID0gbnVsbCkge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgaWYgKCFkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSBpZiAocGFyZW50TWF0Y2hlcy5sZW5ndGggPT09IDAgJiYgIWRhdGFSb3V0ZXJTdGF0ZS5pbml0aWFsaXplZCAmJiBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcbiAgbGV0IGVycm9ycyA9IGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCAmJiBlcnJvcnM/LlttLnJvdXRlLmlkXSAhPT0gdm9pZCAwXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBlcnJvckluZGV4ID49IDAsXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgZXJyb3JzXG4gICAgICApLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG4gIGxldCByZW5kZXJGYWxsYmFjayA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tJbmRleCA9IC0xO1xuICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtYXRjaCA9IHJlbmRlcmVkTWF0Y2hlc1tpXTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICBmYWxsYmFja0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnM6IGVycm9yczIgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPSBtYXRjaC5yb3V0ZS5sb2FkZXIgJiYgIWxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2gucm91dGUuaWQpICYmICghZXJyb3JzMiB8fCBlcnJvcnMyW21hdGNoLnJvdXRlLmlkXSA9PT0gdm9pZCAwKTtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBlcnJvckVsZW1lbnQgPSBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgZGVmYXVsdEVycm9yRWxlbWVudDtcbiAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xuICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA8IDAgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICB3YXJuaW5nT25jZShcbiAgICAgICAgICAgIFwicm91dGUtZmFsbGJhY2tcIixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJObyBgSHlkcmF0ZUZhbGxiYWNrYCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlciBkdXJpbmcgaW5pdGlhbCBoeWRyYXRpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0luZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlczIgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZXJyb3JFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcbiAgICAgICAgY2hpbGRyZW4gPSBoeWRyYXRlRmFsbGJhY2tFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQobWF0Y2gucm91dGUuQ29tcG9uZW50LCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuZWxlbWVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IG91dGxldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJlbmRlcmVkUm91dGUsXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMyLFxuICAgICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUmVuZGVyRXJyb3JCb3VuZGFyeSxcbiAgICAgIHtcbiAgICAgICAgbG9jYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9uLFxuICAgICAgICBjb21wb25lbnQ6IGVycm9yRWxlbWVudCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHsgb3V0bGV0OiBudWxsLCBtYXRjaGVzOiBtYXRjaGVzMiwgaXNEYXRhUm91dGU6IHRydWUgfVxuICAgICAgfVxuICAgICkgOiBnZXRDaGlsZHJlbigpO1xuICB9LCBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHJvdXRlO1xufVxuZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKTtcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgaW52YXJpYW50KFxuICAgIHRoaXNSb3V0ZS5yb3V0ZS5pZCxcbiAgICBgJHtob29rTmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcbiAgcmV0dXJuIHRoaXNSb3V0ZS5yb3V0ZS5pZDtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlSWQoKSB7XG4gIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChcInVzZVJvdXRlSWRcIiAvKiBVc2VSb3V0ZUlkICovKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZU5hdmlnYXRpb25cIiAvKiBVc2VOYXZpZ2F0aW9uICovKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VSZXZhbGlkYXRvclwiIC8qIFVzZVJldmFsaWRhdG9yICovKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUmV2YWxpZGF0b3JcIiAvKiBVc2VSZXZhbGlkYXRvciAqLyk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYXN5bmMgcmV2YWxpZGF0ZSgpIHtcbiAgICAgICAgYXdhaXQgZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUoKTtcbiAgICAgIH0sXG4gICAgICBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfSksXG4gICAgW2RhdGFSb3V0ZXJDb250ZXh0LnJvdXRlciwgc3RhdGUucmV2YWxpZGF0aW9uXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHsgbWF0Y2hlcywgbG9hZGVyRGF0YSB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIFwidXNlTWF0Y2hlc1wiIC8qIFVzZU1hdGNoZXMgKi9cbiAgKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksXG4gICAgW21hdGNoZXMsIGxvYWRlckRhdGFdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlUm91dGVMb2FkZXJEYXRhKHJvdXRlSWQpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVMb2FkZXJEYXRhXCIgLyogVXNlUm91dGVMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VBY3Rpb25EYXRhXCIgLyogVXNlQWN0aW9uRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gIGxldCBlcnJvciA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBpZiAoZXJyb3IgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdDIudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9kYXRhO1xufVxuZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZXJyb3I7XG59XG52YXIgYmxvY2tlcklkID0gMDtcbmZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgbGV0IHsgcm91dGVyLCBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VCbG9ja2VyXCIgLyogVXNlQmxvY2tlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUJsb2NrZXJcIiAvKiBVc2VCbG9ja2VyICovKTtcbiAgbGV0IFtibG9ja2VyS2V5LCBzZXRCbG9ja2VyS2V5XSA9IFJlYWN0Mi51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAoYXJnKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuICAgICAgbGV0IHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSA9IGFyZztcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayh7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdXG4gICk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVN0YWJsZSgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHJvdXRlci5uYXZpZ2F0ZSh0bywgeyBmcm9tUm91dGVJZDogaWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBpZF1cbiAgKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxudmFyIGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3dhcm5pbmdzLnRzXG52YXIgYWxyZWFkeVdhcm5lZDIgPSB7fTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbiAmJiAhYWxyZWFkeVdhcm5lZDJbbWVzc2FnZV0pIHtcbiAgICBhbHJlYWR5V2FybmVkMlttZXNzYWdlXSA9IHRydWU7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9jb21wb25lbnRzLnRzeFxudmFyIEVOQUJMRV9ERVZfV0FSTklOR1MyID0gdHJ1ZTtcbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuaGFzRXJyb3JCb3VuZGFyeSB8fCByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTMikge1xuICAgICAgaWYgKHJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgQ29tcG9uZW50YCBhbmQgYGVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgQ29tcG9uZW50YCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MyKSB7XG4gICAgICBpZiAocm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBIeWRyYXRlRmFsbGJhY2tgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MyKSB7XG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYEVycm9yQm91bmRhcnlgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogb3B0cz8uZnV0dXJlLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHM/LmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzPy5pbml0aWFsSW5kZXhcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbnZhciBEZWZlcnJlZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZXNvbHZlZFwiO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHtcbiAgcm91dGVyLFxuICBmbHVzaFN5bmM6IHJlYWN0RG9tRmx1c2hTeW5jSW1wbFxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QzLnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCBbcGVuZGluZ1N0YXRlLCBzZXRQZW5kaW5nU3RhdGVdID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbdnRDb250ZXh0LCBzZXRWdENvbnRleHRdID0gUmVhY3QzLnVzZVN0YXRlKHtcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gIH0pO1xuICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0My51c2VSZWYoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUsIHsgZGVsZXRlZEZldGNoZXJzLCBmbHVzaFN5bmMsIHZpZXdUcmFuc2l0aW9uT3B0cyB9KSA9PiB7XG4gICAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IGZldGNoZXJEYXRhLmN1cnJlbnQuZGVsZXRlKGtleSkpO1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGZsdXNoU3luYyA9PT0gZmFsc2UgfHwgcmVhY3REb21GbHVzaFN5bmNJbXBsICE9IG51bGwsXG4gICAgICAgICdZb3UgcHJvdmlkZWQgdGhlIGBmbHVzaFN5bmNgIG9wdGlvbiB0byBhIHJvdXRlciB1cGRhdGUsIGJ1dCB5b3UgYXJlIG5vdCB1c2luZyB0aGUgYDxSb3V0ZXJQcm92aWRlcj5gIGZyb20gYHJlYWN0LXJvdXRlci9kb21gIHNvIGBSZWFjdERPTS5mbHVzaFN5bmMoKWAgaXMgdW5hdmFpbGFibGUuICBQbGVhc2UgdXBkYXRlIHlvdXIgYXBwIHRvIGBpbXBvcnQgeyBSb3V0ZXJQcm92aWRlciB9IGZyb20gXCJyZWFjdC1yb3V0ZXIvZG9tXCJgIGFuZCBlbnN1cmUgeW91IGhhdmUgYHJlYWN0LWRvbWAgaW5zdGFsbGVkIGFzIGEgZGVwZW5kZW5jeSB0byB1c2UgdGhlIGBmbHVzaFN5bmNgIG9wdGlvbi4nXG4gICAgICApO1xuICAgICAgbGV0IGlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUgPSByb3V0ZXIud2luZG93ICE9IG51bGwgJiYgcm91dGVyLndpbmRvdy5kb2N1bWVudCAhPSBudWxsICYmIHR5cGVvZiByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPT0gbnVsbCB8fCBpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlLFxuICAgICAgICBcIllvdSBwcm92aWRlZCB0aGUgYHZpZXdUcmFuc2l0aW9uYCBvcHRpb24gdG8gYSByb3V0ZXIgdXBkYXRlLCBidXQgeW91IGRvIG5vdCBhcHBlYXIgdG8gYmUgcnVubmluZyBpbiBhIERPTSBlbnZpcm9ubWVudCBhcyBgd2luZG93LnN0YXJ0Vmlld1RyYW5zaXRpb25gIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgICAgICk7XG4gICAgICBpZiAoIXZpZXdUcmFuc2l0aW9uT3B0cyB8fCAhaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSkge1xuICAgICAgICBpZiAocmVhY3REb21GbHVzaFN5bmNJbXBsICYmIGZsdXNoU3luYykge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFjdERvbUZsdXNoU3luY0ltcGwgJiYgZmx1c2hTeW5jKSB7XG4gICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgICAgZmx1c2hTeW5jOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdCA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVuZGVyRGZkKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRQZW5kaW5nU3RhdGUodm9pZCAwKTtcbiAgICAgICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgIHNldEludGVycnVwdGlvbih7XG4gICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLndpbmRvdywgcmVhY3REb21GbHVzaFN5bmNJbXBsLCB0cmFuc2l0aW9uLCByZW5kZXJEZmRdXG4gICk7XG4gIFJlYWN0My51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XG4gICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkKCkpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dF0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiByb3V0ZXIud2luZG93KSB7XG4gICAgICBsZXQgbmV3U3RhdGUgPSBwZW5kaW5nU3RhdGU7XG4gICAgICBsZXQgcmVuZGVyUHJvbWlzZSA9IHJlbmRlckRmZC5wcm9taXNlO1xuICAgICAgbGV0IHRyYW5zaXRpb24yID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNpdGlvbjIuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckRmZCh2b2lkIDApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHZvaWQgMCk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh2b2lkIDApO1xuICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24yKTtcbiAgICB9XG4gIH0sIFtwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiBzdGF0ZS5sb2NhdGlvbi5rZXkgPT09IHBlbmRpbmdTdGF0ZS5sb2NhdGlvbi5rZXkpIHtcbiAgICAgIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCBbcmVuZGVyRGZkLCB0cmFuc2l0aW9uLCBzdGF0ZS5sb2NhdGlvbiwgcGVuZGluZ1N0YXRlXSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShpbnRlcnJ1cHRpb24uc3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGludGVycnVwdGlvbi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogaW50ZXJydXB0aW9uLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24odm9pZCAwKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcbiAgbGV0IG5hdmlnYXRvcjIgPSBSZWFjdDMudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiAobikgPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlMiwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZTIsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgcm91dGVyLFxuICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyLFxuICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSksXG4gICAgW3JvdXRlciwgbmF2aWdhdG9yMiwgYmFzZW5hbWVdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyRGF0YS5jdXJyZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZ0Q29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcjJcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICAgIE1lbW9pemVkRGF0YVJvdXRlcyxcbiAgICAgIHtcbiAgICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9XG4gICAgKVxuICApKSkpKSwgbnVsbCk7XG59XG52YXIgTWVtb2l6ZWREYXRhUm91dGVzID0gUmVhY3QzLm1lbW8oRGF0YVJvdXRlcyk7XG5mdW5jdGlvbiBEYXRhUm91dGVzKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleFxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0My51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDMudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDMudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gTmF2aWdhdGUoe1xuICB0byxcbiAgcmVwbGFjZTogcmVwbGFjZTIsXG4gIHN0YXRlLFxuICByZWxhdGl2ZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGA8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBzdGF0aWM6IGlzU3RhdGljIH0gPSBSZWFjdDMudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIHdhcm5pbmcoXG4gICAgIWlzU3RhdGljLFxuICAgIGA8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIFRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5gXG4gICk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0My51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICB0byxcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpLFxuICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBuYXZpZ2F0ZShKU09OLnBhcnNlKGpzb25QYXRoKSwgeyByZXBsYWNlOiByZXBsYWNlMiwgc3RhdGUsIHJlbGF0aXZlIH0pO1xuICB9LCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZTIsIHN0YXRlXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gT3V0bGV0KHByb3BzKSB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5mdW5jdGlvbiBSb3V0ZShfcHJvcHMpIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBcIlBPUFwiIC8qIFBvcCAqLyxcbiAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyLFxuICAgICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgICAgZnV0dXJlOiB7fVxuICAgIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yMiwgc3RhdGljUHJvcF1cbiAgKTtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcbiAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCxcbiAgICBgPFJvdXRlciBiYXNlbmFtZT1cIiR7YmFzZW5hbWV9XCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1cIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIGJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLmBcbiAgKTtcbiAgaWYgKGxvY2F0aW9uQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwgeyBjaGlsZHJlbiwgdmFsdWU6IGxvY2F0aW9uQ29udGV4dCB9KSk7XG59XG5mdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb25cbn0pIHtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG5mdW5jdGlvbiBBd2FpdCh7XG4gIGNoaWxkcmVuLFxuICBlcnJvckVsZW1lbnQsXG4gIHJlc29sdmVcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdEVycm9yQm91bmRhcnksIHsgcmVzb2x2ZSwgZXJyb3JFbGVtZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZXNvbHZlQXdhaXQsIG51bGwsIGNoaWxkcmVuKSk7XG59XG52YXIgQXdhaXRFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDMuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IG51bGwgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiPEF3YWl0PiBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgIGxldCBzdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICBzdGF0dXMgPSAxIC8qIHN1Y2Nlc3MgKi87XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiByZXNvbHZlIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgc3RhdHVzID0gMiAvKiBlcnJvciAqLztcbiAgICAgIGxldCByZW5kZXJFcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiByZW5kZXJFcnJvciB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gXCJfZXJyb3JcIiBpbiBwcm9taXNlID8gMiAvKiBlcnJvciAqLyA6IFwiX2RhdGFcIiBpbiBwcm9taXNlID8gMSAvKiBzdWNjZXNzICovIDogMCAvKiBwZW5kaW5nICovO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oXG4gICAgICAgIChkYXRhMikgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEyIH0pLFxuICAgICAgICAoZXJyb3IpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIgLyogZXJyb3IgKi8gJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIgLyogZXJyb3IgKi8pIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9taXNlLCBjaGlsZHJlbjogZXJyb3JFbGVtZW50IH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAxIC8qIHN1Y2Nlc3MgKi8pIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9taXNlLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlc29sdmVBd2FpdCh7XG4gIGNoaWxkcmVuXG59KSB7XG4gIGxldCBkYXRhMiA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhMikgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCA9IFtdKSB7XG4gIGxldCByb3V0ZXMgPSBbXTtcbiAgUmVhY3QzLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghUmVhY3QzLmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QzLkZyYWdtZW50KSB7XG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBlbGVtZW50LnR5cGUgPT09IFJvdXRlLFxuICAgICAgYFske3R5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZX1dIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5gXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiXG4gICAgKTtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogZWxlbWVudC5wcm9wcy5oeWRyYXRlRmFsbGJhY2tFbGVtZW50LFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiBlbGVtZW50LnByb3BzLkh5ZHJhdGVGYWxsYmFjayxcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUgfHwgZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIGhhbmRsZTogZWxlbWVudC5wcm9wcy5oYW5kbGUsXG4gICAgICBsYXp5OiBlbGVtZW50LnByb3BzLmxhenlcbiAgICB9O1xuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgdHJlZVBhdGhcbiAgICAgICk7XG4gICAgfVxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG52YXIgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuO1xuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuLy8gbGliL2RvbS9saWIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDEwIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvZG9tL2RvbS50c1xudmFyIGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xudmFyIGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0ID0gXCJcIikge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vMiwga2V5KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICByZXR1cm4gbWVtbzIuY29uY2F0KFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICk7XG4gICAgfSwgW10pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG52YXIgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbnZhciBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICBcInRleHQvcGxhaW5cIlxuXSk7XG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgXCIke2VuY1R5cGV9XCIgaXMgbm90IGEgdmFsaWQgXFxgZW5jVHlwZVxcYCBmb3IgXFxgPEZvcm0+XFxgL1xcYDxmZXRjaGVyLkZvcm0+XFxgIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuY1R5cGU7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uO1xuICBsZXQgZW5jVHlwZTtcbiAgbGV0IGZvcm1EYXRhO1xuICBsZXQgYm9keTtcbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiB3aXRob3V0IGEgPGZvcm0+YFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IGAke25hbWV9LmAgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXhgLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eWAsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICBmb3JtRGF0YSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDkgZnJvbSBcInJlYWN0XCI7XG5cbi8vIGxpYi9kb20vc3NyL2ludmFyaWFudC50c1xuZnVuY3Rpb24gaW52YXJpYW50Mih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZU1vZHVsZXMudHNcbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgaWYgKHJvdXRlLmlkIGluIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgfVxuICB0cnkge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGltcG9ydChcbiAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgcm91dGUubW9kdWxlXG4gICAgKTtcbiAgICByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF0gPSByb3V0ZU1vZHVsZTtcbiAgICByZXR1cm4gcm91dGVNb2R1bGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBFcnJvciBsb2FkaW5nIHJvdXRlIG1vZHVsZSBcXGAke3JvdXRlLm1vZHVsZX1cXGAsIHJlbG9hZGluZyBwYWdlLi4uYFxuICAgICk7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgaWYgKHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCAmJiB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuaXNTcGFNb2RlICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpbXBvcnQubWV0YS5ob3QpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBsaWIvZG9tL3Nzci9saW5rcy50c1xuZnVuY3Rpb24gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCkge1xuICBsZXQgZGVzY3JpcHRvcnMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgbW9kdWxlID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiBbXG4gICAgICByb3V0ZSAmJiByb3V0ZS5jc3MgPyByb3V0ZS5jc3MubWFwKChocmVmKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmIH0pKSA6IFtdLFxuICAgICAgbW9kdWxlPy5saW5rcz8uKCkgfHwgW11cbiAgICBdO1xuICB9KS5mbGF0KDIpO1xuICBsZXQgcHJlbG9hZHMgPSBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MgJiYgIXJvdXRlTW9kdWxlLmxpbmtzIHx8ICFpc1ByZWxvYWRTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSBbXTtcbiAgaWYgKHJvdXRlLmNzcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4ucm91dGUuY3NzLm1hcCgoaHJlZikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZiB9KSkpO1xuICB9XG4gIGlmIChyb3V0ZU1vZHVsZS5saW5rcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4ucm91dGVNb2R1bGUubGlua3MoKSk7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7XG4gICAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBsZXQgbWF0Y2hpbmdMaW5rcyA9IHN0eWxlTGlua3MuZmlsdGVyKFxuICAgIChsaW5rKSA9PiAoIWxpbmsubWVkaWEgfHwgd2luZG93Lm1hdGNoTWVkaWEobGluay5tZWRpYSkubWF0Y2hlcykgJiYgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtocmVmPVwiJHtsaW5rLmhyZWZ9XCJdYClcbiAgKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hpbmdMaW5rcy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBPYmplY3QuYXNzaWduKGxpbmssIGRlc2NyaXB0b3IpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZUxpbmsoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGVhZC5jb250YWlucyhsaW5rKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5rLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGxpbmsub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNQYWdlTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnBhZ2UgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0h0bWxMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChvYmplY3QuaHJlZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iamVjdC5yZWwgPT09IFwicHJlbG9hZFwiICYmIHR5cGVvZiBvYmplY3QuaW1hZ2VTcmNTZXQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5pbWFnZVNpemVzID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0LnJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmhyZWYgPT09IFwic3RyaW5nXCI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbGlua3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBtYXRjaGVzLm1hcChhc3luYyAobWF0Y2gpID0+IHtcbiAgICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgbGV0IG1vZCA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgICAgICAgcmV0dXJuIG1vZC5saW5rcyA/IG1vZC5saW5rcygpIDogW107XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhcbiAgICBsaW5rcy5mbGF0KDEpLmZpbHRlcihpc0h0bWxMaW5rRGVzY3JpcHRvcikuZmlsdGVyKChsaW5rKSA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgbGluay5yZWwgPT09IFwicHJlbG9hZFwiKS5tYXAoXG4gICAgICAobGluaykgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiID8geyAuLi5saW5rLCByZWw6IFwicHJlZmV0Y2hcIiwgYXM6IFwic3R5bGVcIiB9IDogeyAuLi5saW5rLCByZWw6IFwicHJlZmV0Y2hcIiB9XG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKHBhZ2UsIG5leHRNYXRjaGVzLCBjdXJyZW50TWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uLCBtb2RlKSB7XG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRNYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG4gIGxldCBtYXRjaFBhdGhDaGFuZ2VkID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoPy5lbmRzV2l0aChcIipcIikgJiYgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9O1xuICBpZiAobW9kZSA9PT0gXCJhc3NldHNcIikge1xuICAgIHJldHVybiBuZXh0TWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobWF0Y2gsIGluZGV4KSA9PiBpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KVxuICAgICk7XG4gIH1cbiAgaWYgKG1vZGUgPT09IFwiZGF0YVwiKSB7XG4gICAgcmV0dXJuIG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIW1hbmlmZXN0Um91dGUgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIGxldCByb3V0ZUNob2ljZSA9IG1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoe1xuICAgICAgICAgIGN1cnJlbnRVcmw6IG5ldyBVUkwoXG4gICAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gsXG4gICAgICAgICAgICB3aW5kb3cub3JpZ2luXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50TWF0Y2hlc1swXT8ucGFyYW1zIHx8IHt9LFxuICAgICAgICAgIG5leHRVcmw6IG5ldyBVUkwocGFnZSwgd2luZG93Lm9yaWdpbiksXG4gICAgICAgICAgbmV4dFBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0UGF0Y2gpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKFxuICAgIG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IHJvdXRlID0gbWFuaWZlc3RQYXRjaC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIFtdO1xuICAgICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG4gICAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBocmVmcztcbiAgICB9KS5mbGF0KDEpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIFtdO1xuICAgICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG4gICAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBocmVmcztcbiAgICB9KS5mbGF0KDEpXG4gICk7XG59XG5mdW5jdGlvbiBkZWR1cGVIcmVmcyhocmVmcykge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoaHJlZnMpXTtcbn1cbmZ1bmN0aW9uIHNvcnRLZXlzKG9iaikge1xuICBsZXQgc29ydGVkID0ge307XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgc29ydGVkW2tleV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gc29ydGVkO1xufVxuZnVuY3Rpb24gZGVkdXBlTGlua0Rlc2NyaXB0b3JzKGRlc2NyaXB0b3JzLCBwcmVsb2Fkcykge1xuICBsZXQgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHByZWxvYWRzU2V0ID0gbmV3IFNldChwcmVsb2Fkcyk7XG4gIHJldHVybiBkZXNjcmlwdG9ycy5yZWR1Y2UoKGRlZHVwZWQsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBsZXQgYWxyZWFkeU1vZHVsZVByZWxvYWQgPSBwcmVsb2FkcyAmJiAhaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5hcyA9PT0gXCJzY3JpcHRcIiAmJiBkZXNjcmlwdG9yLmhyZWYgJiYgcHJlbG9hZHNTZXQuaGFzKGRlc2NyaXB0b3IuaHJlZik7XG4gICAgaWYgKGFscmVhZHlNb2R1bGVQcmVsb2FkKSB7XG4gICAgICByZXR1cm4gZGVkdXBlZDtcbiAgICB9XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KHNvcnRLZXlzKGRlc2NyaXB0b3IpKTtcbiAgICBpZiAoIXNldC5oYXMoa2V5KSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgZGVkdXBlZC5wdXNoKHsga2V5LCBsaW5rOiBkZXNjcmlwdG9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZDtcbiAgfSwgW10pO1xufVxudmFyIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG5mdW5jdGlvbiBpc1ByZWxvYWRTdXBwb3J0ZWQoKSB7XG4gIGlmIChfaXNQcmVsb2FkU3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gX2lzUHJlbG9hZFN1cHBvcnRlZDtcbiAgfVxuICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgX2lzUHJlbG9hZFN1cHBvcnRlZCA9IGVsLnJlbExpc3Quc3VwcG9ydHMoXCJwcmVsb2FkXCIpO1xuICBlbCA9IG51bGw7XG4gIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9tYXJrdXAudHNcbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIHsgX19odG1sOiBodG1sIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbmltcG9ydCAqIGFzIFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCJ0dXJiby1zdHJlYW1cIjtcblxuLy8gbGliL2RvbS9zc3IvZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCkge1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCB9O1xuICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICBpbml0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlIH07XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShhd2FpdCByZXF1ZXN0Lmpzb24oKSk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAmJiAvXFxidGV4dFxcL3BsYWluXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWRcXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBpbml0LmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IHJlcXVlc3QudGV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5pdDtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2luZ2xlLWZldGNoLnRzeFxudmFyIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wgPSBTeW1ib2woXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIpO1xuZnVuY3Rpb24gU3RyZWFtVHJhbnNmZXIoe1xuICBjb250ZXh0LFxuICBpZGVudGlmaWVyLFxuICByZWFkZXIsXG4gIHRleHREZWNvZGVyLFxuICBub25jZVxufSkge1xuICBpZiAoIWNvbnRleHQucmVuZGVyTWV0YSB8fCAhY29udGV4dC5yZW5kZXJNZXRhLmRpZFJlbmRlclNjcmlwdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWNvbnRleHQucmVuZGVyTWV0YS5zdHJlYW1DYWNoZSkge1xuICAgIGNvbnRleHQucmVuZGVyTWV0YS5zdHJlYW1DYWNoZSA9IHt9O1xuICB9XG4gIGxldCB7IHN0cmVhbUNhY2hlIH0gPSBjb250ZXh0LnJlbmRlck1ldGE7XG4gIGxldCBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl07XG4gIGlmICghcHJvbWlzZSkge1xuICAgIHByb21pc2UgPSBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXSA9IHJlYWRlci5yZWFkKCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5yZXN1bHQgPSB7XG4gICAgICAgIGRvbmU6IHJlc3VsdC5kb25lLFxuICAgICAgICB2YWx1ZTogdGV4dERlY29kZXIuZGVjb2RlKHJlc3VsdC52YWx1ZSwgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIH07XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdLmVycm9yID0gZTtcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbWlzZS5lcnJvcikge1xuICAgIHRocm93IHByb21pc2UuZXJyb3I7XG4gIH1cbiAgaWYgKHByb21pc2UucmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG4gIGxldCB7IGRvbmUsIHZhbHVlIH0gPSBwcm9taXNlLnJlc3VsdDtcbiAgbGV0IHNjcmlwdFRhZyA9IHZhbHVlID8gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgbm9uY2UsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKCR7ZXNjYXBlSHRtbChcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgKX0pO2BcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xuICBpZiAoZG9uZSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgIF9faHRtbDogYHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5zdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuRnJhZ21lbnQsIG51bGwsIHNjcmlwdFRhZywgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3RyZWFtVHJhbnNmZXIsXG4gICAgICB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgKyAxLFxuICAgICAgICByZWFkZXIsXG4gICAgICAgIHRleHREZWNvZGVyLFxuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICkpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZ2V0Um91dGVyKSB7XG4gIHJldHVybiBhc3luYyAoeyByZXF1ZXN0LCBtYXRjaGVzLCBmZXRjaGVyS2V5IH0pID0+IHtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaEFjdGlvblN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcktleSkge1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3koXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIGdldFJvdXRlcigpLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoZXNcbiAgICApO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb25TdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzKSB7XG4gIGxldCBhY3Rpb25NYXRjaCA9IG1hdGNoZXMuZmluZCgobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgaW52YXJpYW50MihhY3Rpb25NYXRjaCwgXCJObyBhY3Rpb24gbWF0Y2ggZm91bmRcIik7XG4gIGxldCBhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBhY3Rpb25NYXRjaC5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgaW5pdCA9IGF3YWl0IGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpO1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIHN0YXR1cyB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUodXJsLCBpbml0KTtcbiAgICAgIGFjdGlvblN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChcbiAgICAgICAgZGF0YTIsXG4gICAgICAgIGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9KTtcbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgfHwgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHtcbiAgICAgIHR5cGU6IHJlc3VsdC50eXBlLFxuICAgICAgcmVzdWx0OiBkYXRhKHJlc3VsdC5yZXN1bHQsIGFjdGlvblN0YXR1cylcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneShtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCByb3V0ZXIsIHJlcXVlc3QsIG1hdGNoZXMpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBtYXRjaGVzLm1hcCgoKSA9PiBjcmVhdGVEZWZlcnJlZDIoKSk7XG4gIGxldCByb3V0ZXNMb2FkZWRQcm9taXNlID0gUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBzaW5nbGVGZXRjaERmZCA9IGNyZWF0ZURlZmVycmVkMigpO1xuICBsZXQgdXJsID0gc3RyaXBJbmRleFBhcmFtKHNpbmdsZUZldGNoVXJsKHJlcXVlc3QudXJsKSk7XG4gIGxldCBpbml0ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIG1hdGNoZXMubWFwKFxuICAgICAgYXN5bmMgKG0sIGkpID0+IG0ucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgICAgICByb3V0ZURmZHNbaV0ucmVzb2x2ZSgpO1xuICAgICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKCFtLnNob3VsZExvYWQpIHtcbiAgICAgICAgICBpZiAoIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobS5yb3V0ZS5pZCBpbiByb3V0ZXIuc3RhdGUubG9hZGVyRGF0YSAmJiBtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmIHJvdXRlTW9kdWxlc1ttLnJvdXRlLmlkXT8uc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYW5pZmVzdFJvdXRlICYmIG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgICAgaWYgKG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaFNpbmdsZUxvYWRlcihcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICBtLnJvdXRlLmlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFuaWZlc3RSb3V0ZSAmJiBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhkYXRhMiwgbS5yb3V0ZS5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgcm91dGVzTG9hZGVkUHJvbWlzZTtcbiAgaWYgKCghcm91dGVyLnN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSAmJiAhd2luZG93Ll9fcmVhY3RSb3V0ZXJIZHJBY3RpdmUpIHtcbiAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGZvdW5kT3B0T3V0Um91dGUgJiYgcm91dGVzUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICAgIFwiX3JvdXRlc1wiLFxuICAgICAgICAgIG1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgZGF0YTIgPSBhd2FpdCBmZXRjaEFuZERlY29kZSh1cmwsIGluaXQpO1xuICAgICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZShkYXRhMi5kYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZWplY3QoZSk7XG4gICAgfVxuICB9XG4gIGF3YWl0IHJlc29sdmVQcm9taXNlO1xuICByZXR1cm4gcmVzdWx0cztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMpIHtcbiAgbGV0IGZldGNoZXJNYXRjaCA9IG1hdGNoZXMuZmluZCgobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgaW52YXJpYW50MihmZXRjaGVyTWF0Y2gsIFwiTm8gZmV0Y2hlciBtYXRjaCBmb3VuZFwiKTtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXJNYXRjaC5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHVybCA9IHN0cmlwSW5kZXhQYXJhbShzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCkpO1xuICAgIGxldCBpbml0ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCk7XG4gICAgcmV0dXJuIGZldGNoU2luZ2xlTG9hZGVyKGhhbmRsZXIsIHVybCwgaW5pdCwgZmV0Y2hlck1hdGNoLnJvdXRlLmlkKTtcbiAgfSk7XG4gIHJldHVybiB7IFtmZXRjaGVyTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbn1cbmZ1bmN0aW9uIGZldGNoU2luZ2xlTG9hZGVyKGhhbmRsZXIsIHVybCwgaW5pdCwgcm91dGVJZCkge1xuICByZXR1cm4gaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgbGV0IHNpbmdsZUxvYWRlclVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBzaW5nbGVMb2FkZXJVcmwuc2VhcmNoUGFyYW1zLnNldChcIl9yb3V0ZXNcIiwgcm91dGVJZCk7XG4gICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKHNpbmdsZUxvYWRlclVybCwgaW5pdCk7XG4gICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0cyhkYXRhMiwgcm91dGVJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHVybCkge1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNpbmdsZUZldGNoVXJsKHJlcVVybCkge1xuICBsZXQgdXJsID0gdHlwZW9mIHJlcVVybCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoXG4gICAgcmVxVXJsLFxuICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCBkdXJpbmcgdGhlIFNTUiBmbG93IHZpYSBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwgc29cbiAgICAvLyBkb24ndCBhc3N1bWUgd2luZG93IGlzIGF2YWlsYWJsZVxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlcjovL3NpbmdsZWZldGNoL1wiIDogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApIDogcmVxVXJsO1xuICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IFwiX3Jvb3QuZGF0YVwiO1xuICB9IGVsc2Uge1xuICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8kLywgXCJcIil9LmRhdGFgO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZERlY29kZSh1cmwsIGluaXQpIHtcbiAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgIXJlcy5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVzcG9uc2VcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDA0LCBcIk5vdCBGb3VuZFwiLCB0cnVlKTtcbiAgfVxuICBpbnZhcmlhbnQyKHJlcy5ib2R5LCBcIk5vIHJlc3BvbnNlIGJvZHkgdG8gZGVjb2RlXCIpO1xuICB0cnkge1xuICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0ocmVzLmJvZHksIHdpbmRvdyk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiBkZWNvZGVkLnZhbHVlIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHR1cmJvLXN0cmVhbSByZXNwb25zZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVmlhVHVyYm9TdHJlYW0oYm9keSwgZ2xvYmFsMikge1xuICByZXR1cm4gZGVjb2RlKGJvZHksIHtcbiAgICBwbHVnaW5zOiBbXG4gICAgICAodHlwZSwgLi4ucmVzdCkgPT4ge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJTYW5pdGl6ZWRFcnJvclwiKSB7XG4gICAgICAgICAgbGV0IFtuYW1lLCBtZXNzYWdlLCBzdGFja10gPSByZXN0O1xuICAgICAgICAgIGxldCBDb25zdHJ1Y3RvciA9IEVycm9yO1xuICAgICAgICAgIGlmIChuYW1lICYmIG5hbWUgaW4gZ2xvYmFsMiAmJiB0eXBlb2YgZ2xvYmFsMltuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbDJbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBDb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIkVycm9yUmVzcG9uc2VcIikge1xuICAgICAgICAgIGxldCBbZGF0YTIsIHN0YXR1cywgc3RhdHVzVGV4dF0gPSByZXN0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeyBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3RbMF0gfSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoQ2xhc3NJbnN0YW5jZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3RbMF0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHRzKHJlc3VsdHMsIHJvdXRlSWQpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IHJlc3VsdHNbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF07XG4gIGlmIChyZWRpcmVjdDIpIHtcbiAgICByZXR1cm4gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQocmVkaXJlY3QyLCByb3V0ZUlkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0c1tyb3V0ZUlkXSAhPT0gdm9pZCAwID8gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQocmVzdWx0c1tyb3V0ZUlkXSwgcm91dGVJZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQocmVzdWx0LCByb3V0ZUlkKSB7XG4gIGlmIChcImVycm9yXCIgaW4gcmVzdWx0KSB7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9IGVsc2UgaWYgKFwicmVkaXJlY3RcIiBpbiByZXN1bHQpIHtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIGlmIChyZXN1bHQucmV2YWxpZGF0ZSkge1xuICAgICAgaGVhZGVyc1tcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiXSA9IFwieWVzXCI7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucmVsb2FkKSB7XG4gICAgICBoZWFkZXJzW1wiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIl0gPSBcInllc1wiO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnJlcGxhY2UpIHtcbiAgICAgIGhlYWRlcnNbXCJYLVJlbWl4LVJlcGxhY2VcIl0gPSBcInllc1wiO1xuICAgIH1cbiAgICB0aHJvdyByZWRpcmVjdChyZXN1bHQucmVkaXJlY3QsIHsgc3RhdHVzOiByZXN1bHQuc3RhdHVzLCBoZWFkZXJzIH0pO1xuICB9IGVsc2UgaWYgKFwiZGF0YVwiIGluIHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc3BvbnNlIGZvdW5kIGZvciByb3V0ZUlkIFwiJHtyb3V0ZUlkfVwiYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkMigpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAgIHJlcyh2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlamVjdCA9IGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgcmVqKGVycm9yKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXNvbHZlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mb2ctb2Ytd2FyLnRzXG5pbXBvcnQgKiBhcyBSZWFjdDggZnJvbSBcInJlYWN0XCI7XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0NyBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3IvZXJyb3JCb3VuZGFyaWVzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q1IGZyb20gXCJyZWFjdFwiO1xudmFyIFJlbWl4RXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3Q1LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLCBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24gfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LFxuICAgICAgICB7XG4gICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgaXNPdXRzaWRlUmVtaXhBcHA6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvcixcbiAgaXNPdXRzaWRlUmVtaXhBcHBcbn0pIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIGxldCBoZXlEZXZlbG9wZXIgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGBcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfS4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL2Vycm9ycyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgYFxuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJVbmhhbmRsZWQgVGhyb3duIFJlc3BvbnNlIVwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMjRweFwiIH0gfSwgZXJyb3Iuc3RhdHVzLCBcIiBcIiwgZXJyb3Iuc3RhdHVzVGV4dCksIGhleURldmVsb3Blcik7XG4gIH1cbiAgbGV0IGVycm9ySW5zdGFuY2U7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgZXJyb3JJbnN0YW5jZSA9IGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGxldCBlcnJvclN0cmluZyA9IGVycm9yID09IG51bGwgPyBcIlVua25vd24gRXJyb3JcIiA6IHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInRvU3RyaW5nXCIgaW4gZXJyb3IgPyBlcnJvci50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgIGVycm9ySW5zdGFuY2UgPSBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgQm91bmRhcnlTaGVsbCxcbiAgICB7XG4gICAgICB0aXRsZTogXCJBcHBsaWNhdGlvbiBFcnJvciFcIixcbiAgICAgIGlzT3V0c2lkZVJlbWl4QXBwXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiBcIjI0cHhcIiB9IH0sIFwiQXBwbGljYXRpb24gRXJyb3JcIiksXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJwcmVcIixcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcImhzbGEoMTAsIDUwJSwgNTAlLCAwLjEpXCIsXG4gICAgICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcnJvckluc3RhbmNlLnN0YWNrXG4gICAgKSxcbiAgICBoZXlEZXZlbG9wZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIEJvdW5kYXJ5U2hlbGwoe1xuICB0aXRsZSxcbiAgcmVuZGVyU2NyaXB0cyxcbiAgaXNPdXRzaWRlUmVtaXhBcHAsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGxldCB7IHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBpZiAocm91dGVNb2R1bGVzLnJvb3Q/LkxheW91dCAmJiAhaXNPdXRzaWRlUmVtaXhBcHApIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgeyBsYW5nOiBcImVuXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsgY2hhclNldDogXCJ1dGYtOFwiIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJtZXRhXCIsXG4gICAge1xuICAgICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gICAgfVxuICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCB0aXRsZSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcIm1haW5cIiwgeyBzdHlsZTogeyBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLCBwYWRkaW5nOiBcIjJyZW1cIiB9IH0sIGNoaWxkcmVuLCByZW5kZXJTY3JpcHRzID8gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFNjcmlwdHMsIG51bGwpIDogbnVsbCkpKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZmFsbGJhY2sudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDYgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KEJvdW5kYXJ5U2hlbGwsIHsgdGl0bGU6IFwiTG9hZGluZy4uLlwiLCByZW5kZXJTY3JpcHRzOiB0cnVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJ3aGVuIHlvdXIgYXBwIGlzIGxvYWRpbmcgSlMgbW9kdWxlcyBhbmQvb3IgcnVubmluZyBcXGBjbGllbnRMb2FkZXJcXGAgXCIgK1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vcm91dGUvaHlkcmF0ZS1mYWxsYmFjayBcIiArXG4gICAgICAgICAgICAgICAgXCJmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgICAgfVxuICAgIH1cbiAgKSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy50c3hcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCkge1xuICBsZXQgcm91dGVzID0ge307XG4gIE9iamVjdC52YWx1ZXMobWFuaWZlc3QpLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBsZXQgcGFyZW50SWQgPSByb3V0ZS5wYXJlbnRJZCB8fCBcIlwiO1xuICAgICAgaWYgKCFyb3V0ZXNbcGFyZW50SWRdKSB7XG4gICAgICAgIHJvdXRlc1twYXJlbnRJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlc1twYXJlbnRJZF0ucHVzaChyb3V0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbmZ1bmN0aW9uIGdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSkge1xuICBsZXQgQ29tcG9uZW50NCA9IGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKTtcbiAgbGV0IEh5ZHJhdGVGYWxsYmFjayA9IHJvdXRlTW9kdWxlLkh5ZHJhdGVGYWxsYmFjayAmJiAoIWlzU3BhTW9kZSB8fCByb3V0ZS5pZCA9PT0gXCJyb290XCIpID8gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrIDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gUmVtaXhSb290RGVmYXVsdEh5ZHJhdGVGYWxsYmFjayA6IHZvaWQgMDtcbiAgbGV0IEVycm9yQm91bmRhcnkgPSByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5ID8gcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSA6IHJvdXRlLmlkID09PSBcInJvb3RcIiA/ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgeyBlcnJvcjogdXNlUm91dGVFcnJvcigpIH0pIDogdm9pZCAwO1xuICBpZiAocm91dGUuaWQgPT09IFwicm9vdFwiICYmIHJvdXRlTW9kdWxlLkxheW91dCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5Db21wb25lbnQ0ID8ge1xuICAgICAgICBlbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50NCwgbnVsbCkpXG4gICAgICB9IDogeyBDb21wb25lbnQ6IENvbXBvbmVudDQgfSxcbiAgICAgIC4uLkVycm9yQm91bmRhcnkgPyB7XG4gICAgICAgIGVycm9yRWxlbWVudDogLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KHJvdXRlTW9kdWxlLkxheW91dCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwpKVxuICAgICAgfSA6IHsgRXJyb3JCb3VuZGFyeSB9LFxuICAgICAgLi4uSHlkcmF0ZUZhbGxiYWNrID8ge1xuICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoSHlkcmF0ZUZhbGxiYWNrLCBudWxsKSlcbiAgICAgIH0gOiB7IEh5ZHJhdGVGYWxsYmFjayB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBDb21wb25lbnQ6IENvbXBvbmVudDQsIEVycm9yQm91bmRhcnksIEh5ZHJhdGVGYWxsYmFjayB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmVyUm91dGVzKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGZ1dHVyZSwgaXNTcGFNb2RlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLCBzcGFNb2RlTGF6eVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoeyBDb21wb25lbnQ6ICgpID0+IG51bGwgfSkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4ge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF07XG4gICAgaW52YXJpYW50MihcbiAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSB0byBjcmVhdGUgc2VydmVyIHJvdXRlc1wiXG4gICAgKTtcbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgLi4uZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaGFuZGxlOiByb3V0ZU1vZHVsZS5oYW5kbGUsXG4gICAgICAvLyBGb3IgU1BBIE1vZGUsIGFsbCByb3V0ZXMgYXJlIGxhenkgZXhjZXB0IHJvb3QuICBIb3dldmVyIHdlIHRlbGwgdGhlXG4gICAgICAvLyByb3V0ZXIgcm9vdCBpcyBhbHNvIGxhenkgaGVyZSB0b28gc2luY2Ugd2UgZG9uJ3QgbmVlZCBhIGZ1bGxcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIC0gd2UganVzdCBuZWVkIGEgYGxhenlgIHByb3AgdG8gdGVsbCB0aGUgUlIgcmVuZGVyaW5nXG4gICAgICAvLyB3aGVyZSB0byBzdG9wIHdoaWNoIGlzIGFsd2F5cyBhdCB0aGUgcm9vdCByb3V0ZSBpbiBTUEEgbW9kZVxuICAgICAgbGF6eTogaXNTcGFNb2RlID8gKCkgPT4gc3BhTW9kZUxhenlQcm9taXNlIDogdm9pZCAwLFxuICAgICAgLy8gRm9yIHBhcnRpYWwgaHlkcmF0aW9uIHJlbmRlcmluZywgd2UgbmVlZCB0byBpbmRpY2F0ZSB3aGVuIHRoZSByb3V0ZVxuICAgICAgLy8gaGFzIGEgbG9hZGVyL2NsaWVudExvYWRlciwgYnV0IGl0IHdvbid0IGV2ZXIgYmUgY2FsbGVkIGR1cmluZyB0aGUgc3RhdGljXG4gICAgICAvLyByZW5kZXIsIHNvIGp1c3QgZ2l2ZSBpdCBhIG5vLW9wIGZ1bmN0aW9uIHNvIHdlIGNhbiByZW5kZXIgZG93biB0byB0aGVcbiAgICAgIC8vIHByb3BlciBmYWxsYmFja1xuICAgICAgbG9hZGVyOiByb3V0ZS5oYXNMb2FkZXIgfHwgcm91dGUuaGFzQ2xpZW50TG9hZGVyID8gKCkgPT4gbnVsbCA6IHZvaWQgMFxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhY3Rpb24vc2hvdWxkUmV2YWxpZGF0ZSBvbiB0aGVzZSByb3V0ZXMgc2luY2UgdGhleSdyZVxuICAgICAgLy8gZm9yIGEgc3RhdGljIHJlbmRlclxuICAgIH07XG4gICAgbGV0IGNoaWxkcmVuID0gY3JlYXRlU2VydmVyUm91dGVzKFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBmdXR1cmUsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICByb3V0ZS5pZCxcbiAgICAgIHJvdXRlc0J5UGFyZW50SWQsXG4gICAgICBzcGFNb2RlTGF6eVByb21pc2VcbiAgICApO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSBkYXRhUm91dGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gZGF0YVJvdXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQobmVlZHNSZXZhbGlkYXRpb24sIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgaW5pdGlhbFN0YXRlLCBmdXR1cmUsIGlzU3BhTW9kZSkge1xuICByZXR1cm4gY3JlYXRlQ2xpZW50Um91dGVzKFxuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlTW9kdWxlc0NhY2hlLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBpc1NwYU1vZGUsXG4gICAgXCJcIixcbiAgICBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLFxuICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICk7XG59XG5mdW5jdGlvbiBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKHR5cGUsIHJvdXRlLCBpc1NwYU1vZGUpIHtcbiAgaWYgKGlzU3BhTW9kZSkge1xuICAgIGxldCBmbjIgPSB0eXBlID09PSBcImFjdGlvblwiID8gXCJzZXJ2ZXJBY3Rpb24oKVwiIDogXCJzZXJ2ZXJMb2FkZXIoKVwiO1xuICAgIGxldCBtc2cyID0gYFlvdSBjYW5ub3QgY2FsbCAke2ZuMn0gaW4gU1BBIE1vZGUgKHJvdXRlSWQ6IFwiJHtyb3V0ZS5pZH1cIilgO1xuICAgIGNvbnNvbGUuZXJyb3IobXNnMik7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnMiksIHRydWUpO1xuICB9XG4gIGxldCBmbiA9IHR5cGUgPT09IFwiYWN0aW9uXCIgPyBcInNlcnZlckFjdGlvbigpXCIgOiBcInNlcnZlckxvYWRlcigpXCI7XG4gIGxldCBtc2cgPSBgWW91IGFyZSB0cnlpbmcgdG8gY2FsbCAke2ZufSBvbiBhIHJvdXRlIHRoYXQgZG9lcyBub3QgaGF2ZSBhIHNlcnZlciAke3R5cGV9IChyb3V0ZUlkOiBcIiR7cm91dGUuaWR9XCIpYDtcbiAgaWYgKHR5cGUgPT09IFwibG9hZGVyXCIgJiYgIXJvdXRlLmhhc0xvYWRlciB8fCB0eXBlID09PSBcImFjdGlvblwiICYmICFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQWN0aW9uRGVmaW5lZEVycm9yKHR5cGUsIHJvdXRlSWQpIHtcbiAgbGV0IGFydGljbGUgPSB0eXBlID09PSBcImNsaWVudEFjdGlvblwiID8gXCJhXCIgOiBcImFuXCI7XG4gIGxldCBtc2cgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgaGF2ZSAke2FydGljbGV9ICR7dHlwZX0sIGJ1dCB5b3UgYXJlIHRyeWluZyB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkICR7YXJ0aWNsZX0gXFxgJHt0eXBlfVxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDUsIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsIG5ldyBFcnJvcihtc2cpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgaXNTcGFNb2RlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCkge1xuICAgICAgaW52YXJpYW50MihcbiAgICAgICAgdHlwZW9mIHNpbmdsZUZldGNoID09PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTm8gc2luZ2xlIGZldGNoIGZ1bmN0aW9uIGF2YWlsYWJsZSBmb3Igcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0xvYWRlcikgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybiBmZXRjaFNlcnZlckhhbmRsZXIoc2luZ2xlRmV0Y2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCkge1xuICAgICAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJhY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgbGV0IGNhY2hlZE1vZHVsZSA9IHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgICAgIGxldCBsaW5rUHJlZmV0Y2hQcm9taXNlID0gY2FjaGVkTW9kdWxlID8gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCBjYWNoZWRNb2R1bGUpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgbGlua1ByZWZldGNoUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGFSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGhcbiAgICB9O1xuICAgIGlmIChyb3V0ZU1vZHVsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhUm91dGUsIHtcbiAgICAgICAgLi4uZGF0YVJvdXRlLFxuICAgICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc0luaXRpYWxEYXRhID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhO1xuICAgICAgbGV0IGluaXRpYWxEYXRhID0gaGFzSW5pdGlhbERhdGEgPyBpbml0aWFsU3RhdGU/LmxvYWRlckRhdGE/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaGFzSW5pdGlhbEVycm9yID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5lcnJvcnMgJiYgcm91dGUuaWQgaW4gaW5pdGlhbFN0YXRlLmVycm9ycztcbiAgICAgIGxldCBpbml0aWFsRXJyb3IgPSBoYXNJbml0aWFsRXJyb3IgPyBpbml0aWFsU3RhdGU/LmVycm9ycz8uW3JvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGxldCBpc0h5ZHJhdGlvblJlcXVlc3QgPSBuZWVkc1JldmFsaWRhdGlvbiA9PSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXI/Lmh5ZHJhdGUgPT09IHRydWUgfHwgIXJvdXRlLmhhc0xvYWRlcik7XG4gICAgICBkYXRhUm91dGUubG9hZGVyID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zIH0sIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGxvYWRlclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGlzU3BhTW9kZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyKHtcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICBhc3luYyBzZXJ2ZXJMb2FkZXIoKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSwgaXNTcGFNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNIeWRyYXRpb25SZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkYXRhUm91dGUubG9hZGVyLmh5ZHJhdGUgPSBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlLFxuICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgaXNTcGFNb2RlXG4gICAgICApO1xuICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9ICh7IHJlcXVlc3QsIHBhcmFtcyB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSBmb3IgY3JpdGljYWwtcm91dGUgYWN0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImFjdGlvblwiLCByb3V0ZSwgaXNTcGFNb2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgICAgICBkYXRhUm91dGUubG9hZGVyID0gKHsgcmVxdWVzdCB9LCBzaW5nbGVGZXRjaCkgPT4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhTW9kZSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50QWN0aW9uKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5hY3Rpb24gPSAoeyByZXF1ZXN0IH0sIHNpbmdsZUZldGNoKSA9PiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImNsaWVudEFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YVJvdXRlLmxhenkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhcbiAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICByb3V0ZU1vZHVsZXNDYWNoZVxuICAgICAgICApO1xuICAgICAgICBsZXQgbGF6eVJvdXRlID0geyAuLi5tb2QgfTtcbiAgICAgICAgaWYgKG1vZC5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICBsZXQgY2xpZW50TG9hZGVyID0gbW9kLmNsaWVudExvYWRlcjtcbiAgICAgICAgICBsYXp5Um91dGUubG9hZGVyID0gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBjbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSwgaXNTcGFNb2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kLmNsaWVudEFjdGlvbikge1xuICAgICAgICAgIGxldCBjbGllbnRBY3Rpb24gPSBtb2QuY2xpZW50QWN0aW9uO1xuICAgICAgICAgIGxhenlSb3V0ZS5hY3Rpb24gPSAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudEFjdGlvbih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlLCBpc1NwYU1vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubGF6eVJvdXRlLmxvYWRlciA/IHsgbG9hZGVyOiBsYXp5Um91dGUubG9hZGVyIH0gOiB7fSxcbiAgICAgICAgICAuLi5sYXp5Um91dGUuYWN0aW9uID8geyBhY3Rpb246IGxhenlSb3V0ZS5hY3Rpb24gfSA6IHt9LFxuICAgICAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGxhenlSb3V0ZS5oYXNFcnJvckJvdW5kYXJ5LFxuICAgICAgICAgIHNob3VsZFJldmFsaWRhdGU6IGdldFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbihcbiAgICAgICAgICAgIGxhenlSb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICAgICAgICApLFxuICAgICAgICAgIGhhbmRsZTogbGF6eVJvdXRlLmhhbmRsZSxcbiAgICAgICAgICAvLyBObyBuZWVkIHRvIHdyYXAgdGhlc2UgaW4gbGF5b3V0IHNpbmNlIHRoZSByb290IHJvdXRlIGlzIG5ldmVyXG4gICAgICAgICAgLy8gbG9hZGVkIHZpYSByb3V0ZS5sYXp5KClcbiAgICAgICAgICBDb21wb25lbnQ6IGxhenlSb3V0ZS5Db21wb25lbnQsXG4gICAgICAgICAgRXJyb3JCb3VuZGFyeTogbGF6eVJvdXRlLkVycm9yQm91bmRhcnlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICByb3V0ZS5pZCxcbiAgICAgIHJvdXRlc0J5UGFyZW50SWQsXG4gICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKHJvdXRlLCByb3V0ZUlkLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICBpZiAobmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgICByZXR1cm4gd3JhcFNob3VsZFJldmFsaWRhdGVGb3JIZHIoXG4gICAgICByb3V0ZUlkLFxuICAgICAgcm91dGUuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAocm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgcmV0dXJuIChvcHRzKSA9PiBmbih7IC4uLm9wdHMsIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xufVxuZnVuY3Rpb24gd3JhcFNob3VsZFJldmFsaWRhdGVGb3JIZHIocm91dGVJZCwgcm91dGVTaG91bGRSZXZhbGlkYXRlLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICBsZXQgaGFuZGxlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICByZXR1cm4gKGFyZykgPT4ge1xuICAgIGlmICghaGFuZGxlZFJldmFsaWRhdGlvbikge1xuICAgICAgaGFuZGxlZFJldmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm4gbmVlZHNSZXZhbGlkYXRpb24uaGFzKHJvdXRlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVTaG91bGRSZXZhbGlkYXRlID8gcm91dGVTaG91bGRSZXZhbGlkYXRlKGFyZykgOiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgYXdhaXQgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSk7XG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSksXG4gICAgRXJyb3JCb3VuZGFyeTogcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSxcbiAgICBjbGllbnRBY3Rpb246IHJvdXRlTW9kdWxlLmNsaWVudEFjdGlvbixcbiAgICBjbGllbnRMb2FkZXI6IHJvdXRlTW9kdWxlLmNsaWVudExvYWRlcixcbiAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICBsaW5rczogcm91dGVNb2R1bGUubGlua3MsXG4gICAgbWV0YTogcm91dGVNb2R1bGUubWV0YSxcbiAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZU1vZHVsZS5zaG91bGRSZXZhbGlkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSkge1xuICBpZiAocm91dGVNb2R1bGUuZGVmYXVsdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICBsZXQgaXNFbXB0eU9iamVjdCA9IHR5cGVvZiByb3V0ZU1vZHVsZS5kZWZhdWx0ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHJvdXRlTW9kdWxlLmRlZmF1bHQpLmxlbmd0aCA9PT0gMDtcbiAgaWYgKCFpc0VtcHR5T2JqZWN0KSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlLmRlZmF1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSkge1xuICByZXR1cm4gaXNTcGFNb2RlICYmIHJvdXRlLmlkICE9PSBcInJvb3RcIiB8fCByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIgIT0gbnVsbCAmJiAocm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLmh5ZHJhdGUgPT09IHRydWUgfHwgcm91dGUuaGFzTG9hZGVyICE9PSB0cnVlKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIG5leHRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSA9IDFlMztcbnZhciBkaXNjb3ZlcmVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIFVSTF9MSU1JVCA9IDc2ODA7XG5mdW5jdGlvbiBpc0ZvZ09mV2FyRW5hYmxlZChpc1NwYU1vZGUpIHtcbiAgcmV0dXJuICFpc1NwYU1vZGU7XG59XG5mdW5jdGlvbiBnZXRQYXJ0aWFsTWFuaWZlc3QobWFuaWZlc3QsIHJvdXRlcikge1xuICBsZXQgcm91dGVJZHMgPSBuZXcgU2V0KHJvdXRlci5zdGF0ZS5tYXRjaGVzLm1hcCgobSkgPT4gbS5yb3V0ZS5pZCkpO1xuICBsZXQgc2VnbWVudHMgPSByb3V0ZXIuc3RhdGUubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IHBhdGhzID0gW1wiL1wiXTtcbiAgc2VnbWVudHMucG9wKCk7XG4gIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcGF0aHMucHVzaChgLyR7c2VnbWVudHMuam9pbihcIi9cIil9YCk7XG4gICAgc2VnbWVudHMucG9wKCk7XG4gIH1cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGF0aCwgcm91dGVyLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKChtKSA9PiByb3V0ZUlkcy5hZGQobS5yb3V0ZS5pZCkpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBpbml0aWFsUm91dGVzID0gWy4uLnJvdXRlSWRzXS5yZWR1Y2UoXG4gICAgKGFjYywgaWQpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFtpZF06IG1hbmlmZXN0LnJvdXRlc1tpZF0gfSksXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYW5pZmVzdCxcbiAgICByb3V0ZXM6IGluaXRpYWxSb3V0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24obWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgaXNTcGFNb2RlLCBiYXNlbmFtZSkge1xuICBpZiAoIWlzRm9nT2ZXYXJFbmFibGVkKGlzU3BhTW9kZSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhc3luYyAoeyBwYXRoLCBwYXRjaCB9KSA9PiB7XG4gICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhcbiAgICAgIFtwYXRoXSxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBwYXRjaFxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiB1c2VGb2dPRldhckRpc2NvdmVyeShyb3V0ZXIsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGlzU3BhTW9kZSkge1xuICBSZWFjdDgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzRm9nT2ZXYXJFbmFibGVkKGlzU3BhTW9kZSkgfHwgbmF2aWdhdG9yLmNvbm5lY3Rpb24/LnNhdmVEYXRhID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudChlbCkge1xuICAgICAgbGV0IHBhdGggPSBlbC50YWdOYW1lID09PSBcIkZPUk1cIiA/IGVsLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSA6IGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocGF0aCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgICBpZiAoIWRpc2NvdmVyZWRQYXRocy5oYXModXJsLnBhdGhuYW1lKSkge1xuICAgICAgICBuZXh0UGF0aHMuYWRkKHVybC5wYXRobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoUGF0Y2hlcygpIHtcbiAgICAgIGxldCBsYXp5UGF0aHMgPSBBcnJheS5mcm9tKG5leHRQYXRocy5rZXlzKCkpLmZpbHRlcigocGF0aCkgPT4ge1xuICAgICAgICBpZiAoZGlzY292ZXJlZFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgICAgIG5leHRQYXRocy5kZWxldGUocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBpZiAobGF6eVBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKFxuICAgICAgICAgIGxhenlQYXRocyxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgICAgaXNTcGFNb2RlLFxuICAgICAgICAgIHJvdXRlci5iYXNlbmFtZSxcbiAgICAgICAgICByb3V0ZXIucGF0Y2hSb3V0ZXNcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYW5pZmVzdCBwYXRjaGVzXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCJhW2RhdGEtZGlzY292ZXJdLCBmb3JtW2RhdGEtZGlzY292ZXJdXCIpLmZvckVhY2goKGVsKSA9PiByZWdpc3RlckVsZW1lbnQoZWwpKTtcbiAgICBmZXRjaFBhdGNoZXMoKTtcbiAgICBsZXQgZGVib3VuY2VkRmV0Y2hQYXRjaGVzID0gZGVib3VuY2UoZmV0Y2hQYXRjaGVzLCAxMDApO1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gICAgfVxuICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiB7XG4gICAgICBsZXQgZWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgcmVjb3Jkcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIFtyLnRhcmdldCwgLi4uci5hZGRlZE5vZGVzXS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0VsZW1lbnQobm9kZSkpIHJldHVybjtcbiAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkFcIiAmJiBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGlzY292ZXJcIikpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmFkZChub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJGT1JNXCIgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpc2NvdmVyXCIpKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5hZGQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgIT09IFwiQVwiKSB7XG4gICAgICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhW2RhdGEtZGlzY292ZXJdLCBmb3JtW2RhdGEtZGlzY292ZXJdXCIpLmZvckVhY2goKGVsKSA9PiBlbGVtZW50cy5hZGQoZWwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4gcmVnaXN0ZXJFbGVtZW50KGVsKSk7XG4gICAgICBkZWJvdW5jZWRGZXRjaFBhdGNoZXMoKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImRhdGEtZGlzY292ZXJcIiwgXCJocmVmXCIsIFwiYWN0aW9uXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW2lzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgcm91dGVyXSk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKHBhdGhzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBpc1NwYU1vZGUsIGJhc2VuYW1lLCBwYXRjaFJvdXRlcykge1xuICBsZXQgbWFuaWZlc3RQYXRoID0gYCR7YmFzZW5hbWUgIT0gbnVsbCA/IGJhc2VuYW1lIDogXCIvXCJ9L19fbWFuaWZlc3RgLnJlcGxhY2UoXG4gICAgL1xcLysvZyxcbiAgICBcIi9cIlxuICApO1xuICBsZXQgdXJsID0gbmV3IFVSTChtYW5pZmVzdFBhdGgsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICBwYXRocy5zb3J0KCkuZm9yRWFjaCgocGF0aCkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJwXCIsIHBhdGgpKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIG1hbmlmZXN0LnZlcnNpb24pO1xuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fWApO1xuICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlcy50ZXh0KCkpO1xuICB9XG4gIGxldCBzZXJ2ZXJQYXRjaGVzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgbGV0IGtub3duUm91dGVzID0gbmV3IFNldChPYmplY3Qua2V5cyhtYW5pZmVzdC5yb3V0ZXMpKTtcbiAgbGV0IHBhdGNoZXMgPSBPYmplY3QudmFsdWVzKHNlcnZlclBhdGNoZXMpLnJlZHVjZSgoYWNjLCByb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSAmJiAha25vd25Sb3V0ZXMuaGFzKHJvdXRlLmlkKSkge1xuICAgICAgYWNjW3JvdXRlLmlkXSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIE9iamVjdC5hc3NpZ24obWFuaWZlc3Qucm91dGVzLCBwYXRjaGVzKTtcbiAgcGF0aHMuZm9yRWFjaCgocCkgPT4gYWRkVG9GaWZvUXVldWUocCwgZGlzY292ZXJlZFBhdGhzKSk7XG4gIGxldCBwYXJlbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBPYmplY3QudmFsdWVzKHBhdGNoZXMpLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgaWYgKHBhdGNoICYmICghcGF0Y2gucGFyZW50SWQgfHwgIXBhdGNoZXNbcGF0Y2gucGFyZW50SWRdKSkge1xuICAgICAgcGFyZW50SWRzLmFkZChwYXRjaC5wYXJlbnRJZCk7XG4gICAgfVxuICB9KTtcbiAgcGFyZW50SWRzLmZvckVhY2goXG4gICAgKHBhcmVudElkKSA9PiBwYXRjaFJvdXRlcyhcbiAgICAgIHBhcmVudElkIHx8IG51bGwsXG4gICAgICBjcmVhdGVDbGllbnRSb3V0ZXMocGF0Y2hlcywgcm91dGVNb2R1bGVzLCBudWxsLCBpc1NwYU1vZGUsIHBhcmVudElkKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRmlmb1F1ZXVlKHBhdGgsIHF1ZXVlKSB7XG4gIGlmIChxdWV1ZS5zaXplID49IGRpc2NvdmVyZWRQYXRoc01heFNpemUpIHtcbiAgICBsZXQgZmlyc3QgPSBxdWV1ZS52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgcXVldWUuZGVsZXRlKGZpcnN0KTtcbiAgfVxuICBxdWV1ZS5hZGQocGF0aCk7XG59XG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgd2FpdCkge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soLi4uYXJncyksIHdhaXQpO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9jb21wb25lbnRzLnRzeFxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQyKCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0OS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBGcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbkZyYW1ld29ya0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZyYW1ld29ya0NvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZUZyYW1ld29ya0NvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPEh5ZHJhdGVkUm91dGVyPiBlbGVtZW50XCJcbiAgKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgZnJhbWV3b3JrQ29udGV4dCA9IFJlYWN0OS51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3Q5LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgc2V0U2hvdWxkUHJlZmV0Y2hdID0gUmVhY3Q5LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IHsgb25Gb2N1cywgb25CbHVyLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25Ub3VjaFN0YXJ0IH0gPSB0aGVpckVsZW1lbnRQcm9wcztcbiAgbGV0IHJlZiA9IFJlYWN0OS51c2VSZWYobnVsbCk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJ2aWV3cG9ydFwiKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2goZW50cnkuaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2ssIHsgdGhyZXNob2xkOiAwLjUgfSk7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIG9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtwcmVmZXRjaF0pO1xuICBSZWFjdDkudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWF5YmVQcmVmZXRjaCkge1xuICAgICAgbGV0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFNob3VsZFByZWZldGNoKHRydWUpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW21heWJlUHJlZmV0Y2hdKTtcbiAgbGV0IHNldEludGVudCA9ICgpID0+IHtcbiAgICBzZXRNYXliZVByZWZldGNoKHRydWUpO1xuICB9O1xuICBsZXQgY2FuY2VsSW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIHNldFNob3VsZFByZWZldGNoKGZhbHNlKTtcbiAgfTtcbiAgaWYgKCFmcmFtZXdvcmtDb250ZXh0KSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgcmVmLCB7fV07XG4gIH1cbiAgaWYgKHByZWZldGNoICE9PSBcImludGVudFwiKSB7XG4gICAgcmV0dXJuIFtzaG91bGRQcmVmZXRjaCwgcmVmLCB7fV07XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBzaG91bGRQcmVmZXRjaCxcbiAgICByZWYsXG4gICAge1xuICAgICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25CbHVyLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Nb3VzZUVudGVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbk1vdXNlRW50ZXIsIHNldEludGVudCksXG4gICAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICAgIG9uVG91Y2hTdGFydDogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Ub3VjaFN0YXJ0LCBzZXRJbnRlbnQpXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICB0aGVpckhhbmRsZXIgJiYgdGhlaXJIYW5kbGVyKGV2ZW50KTtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZU1hdGNoZXMobWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpIHtcbiAgaWYgKGlzU3BhTW9kZSAmJiAhaXNIeWRyYXRlZCkge1xuICAgIHJldHVybiBbbWF0Y2hlc1swXV07XG4gIH1cbiAgaWYgKGVycm9ycykge1xuICAgIGxldCBlcnJvcklkeCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMCk7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgZXJyb3JJZHggKyAxKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQgeyBpc1NwYU1vZGUsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGNyaXRpY2FsQ3NzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGVycm9ycywgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQga2V5ZWRMaW5rcyA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldEtleWVkTGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpLFxuICAgIFttYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0XVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgY3JpdGljYWxDc3MgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3JpdGljYWxDc3MgfSB9KSA6IG51bGwsIGtleWVkTGlua3MubWFwKFxuICAgICh7IGtleSwgbGluayB9KSA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywgeyBrZXksIC4uLmxpbmsgfSkgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5LCAuLi5saW5rIH0pXG4gICkpO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3Moe1xuICBwYWdlLFxuICAuLi5kYXRhTGlua1Byb3BzXG59KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQyKCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGFnZSwgcm91dGVyLmJhc2VuYW1lKSxcbiAgICBbcm91dGVyLnJvdXRlcywgcGFnZSwgcm91dGVyLmJhc2VuYW1lXVxuICApO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzSW1wbCwgeyBwYWdlLCBtYXRjaGVzLCAuLi5kYXRhTGlua1Byb3BzIH0pO1xufVxuZnVuY3Rpb24gdXNlS2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMpIHtcbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgW2tleWVkUHJlZmV0Y2hMaW5rcywgc2V0S2V5ZWRQcmVmZXRjaExpbmtzXSA9IFJlYWN0OS51c2VTdGF0ZShbXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgIHZvaWQgZ2V0S2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMpLnRoZW4oXG4gICAgICAobGlua3MpID0+IHtcbiAgICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkge1xuICAgICAgICAgIHNldEtleWVkUHJlZmV0Y2hMaW5rcyhsaW5rcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW21hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXNdKTtcbiAgcmV0dXJuIGtleWVkUHJlZmV0Y2hMaW5rcztcbn1cbmZ1bmN0aW9uIFByZWZldGNoUGFnZUxpbmtzSW1wbCh7XG4gIHBhZ2UsXG4gIG1hdGNoZXM6IG5leHRNYXRjaGVzLFxuICAuLi5saW5rUHJvcHNcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgeyBsb2FkZXJEYXRhLCBtYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBuZXdNYXRjaGVzRm9yRGF0YSA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhcbiAgICAgIHBhZ2UsXG4gICAgICBuZXh0TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgXCJkYXRhXCJcbiAgICApLFxuICAgIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uXVxuICApO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckFzc2V0cyA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhcbiAgICAgIHBhZ2UsXG4gICAgICBuZXh0TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgXCJhc3NldHNcIlxuICAgICksXG4gICAgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb25dXG4gICk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdDkudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBhZ2UgPT09IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgcm91dGVzUGFyYW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRPcHRPdXRSb3V0ZSA9IGZhbHNlO1xuICAgIG5leHRNYXRjaGVzLmZvckVhY2goKG0pID0+IHtcbiAgICAgIGxldCBtYW5pZmVzdFJvdXRlID0gbWFuaWZlc3Qucm91dGVzW20ucm91dGUuaWRdO1xuICAgICAgaWYgKCFtYW5pZmVzdFJvdXRlIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW5ld01hdGNoZXNGb3JEYXRhLnNvbWUoKG0yKSA9PiBtMi5yb3V0ZS5pZCA9PT0gbS5yb3V0ZS5pZCkgJiYgbS5yb3V0ZS5pZCBpbiBsb2FkZXJEYXRhICYmIHJvdXRlTW9kdWxlc1ttLnJvdXRlLmlkXT8uc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobWFuaWZlc3RSb3V0ZS5oYXNDbGllbnRMb2FkZXIpIHtcbiAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXNQYXJhbXMuYWRkKG0ucm91dGUuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyb3V0ZXNQYXJhbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdXJsID0gc2luZ2xlRmV0Y2hVcmwocGFnZSk7XG4gICAgaWYgKGZvdW5kT3B0T3V0Um91dGUgJiYgcm91dGVzUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgICAgXCJfcm91dGVzXCIsXG4gICAgICAgIG5leHRNYXRjaGVzLmZpbHRlcigobSkgPT4gcm91dGVzUGFyYW1zLmhhcyhtLnJvdXRlLmlkKSkubWFwKChtKSA9PiBtLnJvdXRlLmlkKS5qb2luKFwiLFwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFt1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoXTtcbiAgfSwgW1xuICAgIGxvYWRlckRhdGEsXG4gICAgbG9jYXRpb24sXG4gICAgbWFuaWZlc3QsXG4gICAgbmV3TWF0Y2hlc0ZvckRhdGEsXG4gICAgbmV4dE1hdGNoZXMsXG4gICAgcGFnZSxcbiAgICByb3V0ZU1vZHVsZXNcbiAgXSk7XG4gIGxldCBtb2R1bGVIcmVmcyA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksXG4gICAgW25ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0XVxuICApO1xuICBsZXQga2V5ZWRQcmVmZXRjaExpbmtzID0gdXNlS2V5ZWRQcmVmZXRjaExpbmtzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgZGF0YUhyZWZzLm1hcCgoaHJlZikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZiwgcmVsOiBcInByZWZldGNoXCIsIGFzOiBcImZldGNoXCIsIGhyZWYsIC4uLmxpbmtQcm9wcyB9KSksIG1vZHVsZUhyZWZzLm1hcCgoaHJlZikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZiwgcmVsOiBcIm1vZHVsZXByZWxvYWRcIiwgaHJlZiwgLi4ubGlua1Byb3BzIH0pKSwga2V5ZWRQcmVmZXRjaExpbmtzLm1hcCgoeyBrZXksIGxpbmsgfSkgPT4gKFxuICAgIC8vIHRoZXNlIGRvbid0IHNwcmVhZCBgbGlua1Byb3BzYCBiZWNhdXNlIHRoZXkgYXJlIGZ1bGwgbGluayBkZXNjcmlwdG9yc1xuICAgIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5LCAuLi5saW5rIH0pXG4gICkpKTtcbn1cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgZXJyb3JzLFxuICAgIG1hdGNoZXM6IHJvdXRlck1hdGNoZXMsXG4gICAgbG9hZGVyRGF0YVxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgX21hdGNoZXMgPSBnZXRBY3RpdmVNYXRjaGVzKHJvdXRlck1hdGNoZXMsIGVycm9ycywgaXNTcGFNb2RlKTtcbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgaWYgKGVycm9ycykge1xuICAgIGVycm9yID0gZXJyb3JzW19tYXRjaGVzW19tYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmlkXTtcbiAgfVxuICBsZXQgbWV0YSA9IFtdO1xuICBsZXQgbGVhZk1ldGEgPSBudWxsO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IF9tYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IF9tYXRjaCA9IF9tYXRjaGVzW2ldO1xuICAgIGxldCByb3V0ZUlkID0gX21hdGNoLnJvdXRlLmlkO1xuICAgIGxldCBkYXRhMiA9IGxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgbGV0IHBhcmFtcyA9IF9tYXRjaC5wYXJhbXM7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlSWRdO1xuICAgIGxldCByb3V0ZU1ldGEgPSBbXTtcbiAgICBsZXQgbWF0Y2ggPSB7XG4gICAgICBpZDogcm91dGVJZCxcbiAgICAgIGRhdGE6IGRhdGEyLFxuICAgICAgbWV0YTogW10sXG4gICAgICBwYXJhbXM6IF9tYXRjaC5wYXJhbXMsXG4gICAgICBwYXRobmFtZTogX21hdGNoLnBhdGhuYW1lLFxuICAgICAgaGFuZGxlOiBfbWF0Y2gucm91dGUuaGFuZGxlLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICAgIG1hdGNoZXNbaV0gPSBtYXRjaDtcbiAgICBpZiAocm91dGVNb2R1bGU/Lm1ldGEpIHtcbiAgICAgIHJvdXRlTWV0YSA9IHR5cGVvZiByb3V0ZU1vZHVsZS5tZXRhID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5tZXRhKHtcbiAgICAgICAgZGF0YTogZGF0YTIsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGVycm9yXG4gICAgICB9KSA6IEFycmF5LmlzQXJyYXkocm91dGVNb2R1bGUubWV0YSkgPyBbLi4ucm91dGVNb2R1bGUubWV0YV0gOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgIH0gZWxzZSBpZiAobGVhZk1ldGEpIHtcbiAgICAgIHJvdXRlTWV0YSA9IFsuLi5sZWFmTWV0YV07XG4gICAgfVxuICAgIHJvdXRlTWV0YSA9IHJvdXRlTWV0YSB8fCBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocm91dGVNZXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSByb3V0ZSBhdCBcIiArIF9tYXRjaC5yb3V0ZS5wYXRoICsgXCIgcmV0dXJucyBhbiBpbnZhbGlkIHZhbHVlLiBBbGwgcm91dGUgbWV0YSBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgbWV0YSBvYmplY3RzLlxcblxcblRvIHJlZmVyZW5jZSB0aGUgbWV0YSBmdW5jdGlvbiBBUEksIHNlZSBodHRwczovL3JlbWl4LnJ1bi9yb3V0ZS9tZXRhXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG1hdGNoLm1ldGEgPSByb3V0ZU1ldGE7XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIG1ldGEgPSBbLi4ucm91dGVNZXRhXTtcbiAgICBsZWFmTWV0YSA9IG1ldGE7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChSZWFjdDkuRnJhZ21lbnQsIG51bGwsIG1ldGEuZmxhdCgpLm1hcCgobWV0YVByb3BzKSA9PiB7XG4gICAgaWYgKCFtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJ0YWdOYW1lXCIgaW4gbWV0YVByb3BzKSB7XG4gICAgICBsZXQgeyB0YWdOYW1lLCAuLi5yZXN0IH0gPSBtZXRhUHJvcHM7XG4gICAgICBpZiAoIWlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQSBtZXRhIG9iamVjdCB1c2VzIGFuIGludmFsaWQgdGFnTmFtZTogJHt0YWdOYW1lfS4gRXhwZWN0ZWQgZWl0aGVyICdsaW5rJyBvciAnbWV0YSdgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IENvbXAgPSB0YWdOYW1lO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChDb21wLCB7IGtleTogSlNPTi5zdHJpbmdpZnkocmVzdCksIC4uLnJlc3QgfSk7XG4gICAgfVxuICAgIGlmIChcInRpdGxlXCIgaW4gbWV0YVByb3BzKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgeyBrZXk6IFwidGl0bGVcIiB9LCBTdHJpbmcobWV0YVByb3BzLnRpdGxlKSk7XG4gICAgfVxuICAgIGlmIChcImNoYXJzZXRcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIG1ldGFQcm9wcy5jaGFyU2V0ID8/IChtZXRhUHJvcHMuY2hhclNldCA9IG1ldGFQcm9wcy5jaGFyc2V0KTtcbiAgICAgIGRlbGV0ZSBtZXRhUHJvcHMuY2hhcnNldDtcbiAgICB9XG4gICAgaWYgKFwiY2hhclNldFwiIGluIG1ldGFQcm9wcyAmJiBtZXRhUHJvcHMuY2hhclNldCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1ldGFQcm9wcy5jaGFyU2V0ID09PSBcInN0cmluZ1wiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGtleTogXCJjaGFyU2V0XCIsIGNoYXJTZXQ6IG1ldGFQcm9wcy5jaGFyU2V0IH0pIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKFwic2NyaXB0OmxkK2pzb25cIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkobWV0YVByb3BzW1wic2NyaXB0OmxkK2pzb25cIl0pO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic2NyaXB0XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBgc2NyaXB0OmxkK2pzb246JHtqc29ufWAsXG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2xkK2pzb25cIixcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDoganNvbiB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGtleTogSlNPTi5zdHJpbmdpZnkobWV0YVByb3BzKSwgLi4ubWV0YVByb3BzIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0YVRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgdGFnTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXihtZXRhfGxpbmspJC8udGVzdCh0YWdOYW1lKTtcbn1cbnZhciBpc0h5ZHJhdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBTY3JpcHRzKHByb3BzKSB7XG4gIGxldCB7IG1hbmlmZXN0LCBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLCBpc1NwYU1vZGUsIHJlbmRlck1ldGEgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgcm91dGVyLCBzdGF0aWM6IGlzU3RhdGljLCBzdGF0aWNDb250ZXh0IH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IHsgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgZW5hYmxlRm9nT2ZXYXIgPSBpc0ZvZ09mV2FyRW5hYmxlZChpc1NwYU1vZGUpO1xuICBpZiAocmVuZGVyTWV0YSkge1xuICAgIHJlbmRlck1ldGEuZGlkUmVuZGVyU2NyaXB0cyA9IHRydWU7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBnZXRBY3RpdmVNYXRjaGVzKHJvdXRlck1hdGNoZXMsIG51bGwsIGlzU3BhTW9kZSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzSHlkcmF0ZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGxldCBpbml0aWFsU2NyaXB0cyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc3RyZWFtU2NyaXB0ID0gXCJ3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChjb250cm9sbGVyKXt3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7fX0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcIjtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHN0YXRpY0NvbnRleHQgPyBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTske3N0cmVhbVNjcmlwdH1gIDogXCIgXCI7XG4gICAgbGV0IHJvdXRlTW9kdWxlc1NjcmlwdCA9ICFpc1N0YXRpYyA/IFwiIFwiIDogYCR7bWFuaWZlc3QuaG1yPy5ydW50aW1lID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0Lmhtci5ydW50aW1lKX07YCA6IFwiXCJ9JHshZW5hYmxlRm9nT2ZXYXIgPyBgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QudXJsKX1gIDogXCJcIn07XG4ke21hdGNoZXMubWFwKFxuICAgICAgKG1hdGNoLCBpbmRleCkgPT4gYGltcG9ydCAqIGFzIHJvdXRlJHtpbmRleH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLm1vZHVsZVxuICAgICAgKX07YFxuICAgICkuam9pbihcIlxcblwiKX1cbiAgJHtlbmFibGVGb2dPZldhciA/IChcbiAgICAgIC8vIElubGluZSBhIG1pbmltYWwgbWFuaWZlc3Qgd2l0aCB0aGUgU1NSIG1hdGNoZXNcbiAgICAgIGB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0ID0gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZ2V0UGFydGlhbE1hbmlmZXN0KG1hbmlmZXN0LCByb3V0ZXIpLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfTtgXG4gICAgKSA6IFwiXCJ9XG4gIHdpbmRvdy5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtcblxuaW1wb3J0KCR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QuZW50cnkubW9kdWxlKX0pO2A7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChSZWFjdDkuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKGNvbnRleHRTY3JpcHQpLFxuICAgICAgICB0eXBlOiB2b2lkIDBcbiAgICAgIH1cbiAgICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgICB0eXBlOiBcIm1vZHVsZVwiLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgICAgfVxuICAgICkpO1xuICB9LCBbXSk7XG4gIGxldCByb3V0ZVByZWxvYWRzID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gcm91dGUgPyAocm91dGUuaW1wb3J0cyB8fCBbXSkuY29uY2F0KFtyb3V0ZS5tb2R1bGVdKSA6IFtdO1xuICB9KS5mbGF0KDEpO1xuICBsZXQgcHJlbG9hZHMgPSBpc0h5ZHJhdGVkID8gW10gOiBtYW5pZmVzdC5lbnRyeS5pbXBvcnRzLmNvbmNhdChyb3V0ZVByZWxvYWRzKTtcbiAgcmV0dXJuIGlzSHlkcmF0ZWQgPyBudWxsIDogLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgIWVuYWJsZUZvZ09mV2FyID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGlua1wiLFxuICAgIHtcbiAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICBocmVmOiBtYW5pZmVzdC51cmwsXG4gICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW5cbiAgICB9XG4gICkgOiBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpblxuICAgIH1cbiAgKSwgZGVkdXBlKHByZWxvYWRzKS5tYXAoKHBhdGgpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICBrZXk6IHBhdGgsXG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogcGF0aCxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpblxuICAgIH1cbiAgKSksIGluaXRpYWxTY3JpcHRzKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xudHJ5IHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyVmVyc2lvbiA9IFwiNy4xLjNcIjtcbiAgfVxufSBjYXRjaCAoZSkge1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogb3B0cz8uZnV0dXJlLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbixcbiAgICB3aW5kb3c6IG9wdHM/LndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvdzogd2luZG93MlxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0MTAudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiB3aW5kb3cyLCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdzogd2luZG93MiB9KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaGlzdG9yeVxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWDIgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgTGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoe1xuICAgIG9uQ2xpY2ssXG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIHByZWZldGNoID0gXCJub25lXCIsXG4gICAgcmVsYXRpdmUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgdGFyZ2V0LFxuICAgIHRvLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICAuLi5yZXN0XG4gIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc0Fic29sdXRlID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdCh0byk7XG4gICAgbGV0IGFic29sdXRlSHJlZjtcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XG4gICAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYDxMaW5rIHRvPVwiJHt0b31cIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBbc2hvdWxkUHJlZmV0Y2gsIHByZWZldGNoUmVmLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IoXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIHJlc3RcbiAgICApO1xuICAgIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB2aWV3VHJhbnNpdGlvblxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxpbmsgPSAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImFcIixcbiAgICAgICAge1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgLi4ucHJlZmV0Y2hIYW5kbGVycyxcbiAgICAgICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZixcbiAgICAgICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgICAgIHJlZjogbWVyZ2VSZWZzKGZvcndhcmRlZFJlZiwgcHJlZmV0Y2hSZWYpLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gc2hvdWxkUHJlZmV0Y2ggJiYgIWlzQWJzb2x1dGUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFJlYWN0MTAuRnJhZ21lbnQsIG51bGwsIGxpbmssIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHsgcGFnZTogaHJlZiB9KSkgOiBsaW5rO1xuICB9XG4pO1xuTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xudmFyIE5hdkxpbmsgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICBlbmQgPSBmYWxzZSxcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIHRvLFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSB7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmUgfSk7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyLCBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJiAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB2aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvcjIuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IyLmVuY29kZUxvY2F0aW9uKHBhdGgpLnBhdGhuYW1lIDogcGF0aC5wYXRobmFtZTtcbiAgICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGxldCBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWUgOiBudWxsO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgPyBuZXh0TG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChuZXh0TG9jYXRpb25QYXRobmFtZSAmJiBiYXNlbmFtZSkge1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvblBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uUGF0aG5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGVuZFNsYXNoUG9zaXRpb24gPSB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUubGVuZ3RoIC0gMSA6IHRvUGF0aG5hbWUubGVuZ3RoO1xuICAgIGxldCBpc0FjdGl2ZSA9IGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQoZW5kU2xhc2hQb3NpdGlvbikgPT09IFwiL1wiO1xuICAgIGxldCBpc1BlbmRpbmcgPSBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgIGlzQWN0aXZlLFxuICAgICAgaXNQZW5kaW5nLFxuICAgICAgaXNUcmFuc2l0aW9uaW5nXG4gICAgfTtcbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHZvaWQgMDtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHJlbmRlclByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NOYW1lID0gW1xuICAgICAgICBjbGFzc05hbWVQcm9wLFxuICAgICAgICBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLFxuICAgICAgICBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsXG4gICAgICAgIGlzVHJhbnNpdGlvbmluZyA/IFwidHJhbnNpdGlvbmluZ1wiIDogbnVsbFxuICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGxldCBzdHlsZSA9IHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcChyZW5kZXJQcm9wcykgOiBzdHlsZVByb3A7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBMaW5rLFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZWYsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICB0byxcbiAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgIH0sXG4gICAgICB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHJlbmRlclByb3BzKSA6IGNoaWxkcmVuXG4gICAgKTtcbiAgfVxuKTtcbk5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbnZhciBGb3JtID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGRpc2NvdmVyID0gXCJyZW5kZXJcIixcbiAgICBmZXRjaGVyS2V5LFxuICAgIG5hdmlnYXRlLFxuICAgIHJlbG9hZERvY3VtZW50LFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgIHN0YXRlLFxuICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXG4gICAgYWN0aW9uLFxuICAgIG9uU3VibWl0LFxuICAgIHJlbGF0aXZlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICAuLi5wcm9wc1xuICB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0KCk7XG4gICAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgeyByZWxhdGl2ZSB9KTtcbiAgICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGxldCBpc0Fic29sdXRlID0gdHlwZW9mIGFjdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgyLnRlc3QoYWN0aW9uKTtcbiAgICBsZXQgc3VibWl0SGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgc3VibWl0dGVyID0gZXZlbnQubmF0aXZlRXZlbnQuc3VibWl0dGVyO1xuICAgICAgbGV0IHN1Ym1pdE1ldGhvZCA9IHN1Ym1pdHRlcj8uZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBtZXRob2Q7XG4gICAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgZmV0Y2hlcktleSxcbiAgICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICAgIG5hdmlnYXRlLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJmb3JtXCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICAgICAgb25TdWJtaXQ6IHJlbG9hZERvY3VtZW50ID8gb25TdWJtaXQgOiBzdWJtaXRIYW5kbGVyLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgXCJkYXRhLWRpc2NvdmVyXCI6ICFpc0Fic29sdXRlICYmIGRpc2NvdmVyID09PSBcInJlbmRlclwiID8gXCJ0cnVlXCIgOiB2b2lkIDBcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXksXG4gIC4uLnByb3BzXG59KSB7XG4gIGxldCByZW1peENvbnRleHQgPSBSZWFjdDEwLnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oeyBnZXRLZXksIHN0b3JhZ2VLZXkgfSk7XG4gIGxldCBzc3JLZXkgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKCFyZW1peENvbnRleHQgfHwgIWdldEtleSkgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgdXNlcktleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGdldEtleVxuICAgICAgKTtcbiAgICAgIHJldHVybiB1c2VyS2V5ICE9PSBsb2NhdGlvbi5rZXkgPyB1c2VyS2V5IDogbnVsbDtcbiAgICB9LFxuICAgIC8vIE5haCwgd2Ugb25seSBuZWVkIHRoaXMgdGhlIGZpcnN0IHRpbWUgZm9yIHRoZSBTU1IgcmVuZGVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdXG4gICk7XG4gIGlmICghcmVtaXhDb250ZXh0IHx8IHJlbWl4Q29udGV4dC5pc1NwYU1vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgcmVzdG9yZVNjcm9sbCA9ICgoc3RvcmFnZUtleTIsIHJlc3RvcmVLZXkpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8ICF3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXkpIHtcbiAgICAgIGxldCBrZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDMyKS5zbGljZSgyKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleSB9LCBcIlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleTIpIHx8IFwie31cIik7XG4gICAgICBsZXQgc3RvcmVkWSA9IHBvc2l0aW9uc1tyZXN0b3JlS2V5IHx8IHdpbmRvdy5oaXN0b3J5LnN0YXRlLmtleV07XG4gICAgICBpZiAodHlwZW9mIHN0b3JlZFkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHN0b3JlZFkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleTIpO1xuICAgIH1cbiAgfSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYCgke3Jlc3RvcmVTY3JvbGx9KSgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICl9LCAke0pTT04uc3RyaW5naWZ5KHNzcktleSl9KWBcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5TY3JvbGxSZXN0b3JhdGlvbi5kaXNwbGF5TmFtZSA9IFwiU2Nyb2xsUmVzdG9yYXRpb25cIjtcbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyKGhvb2tOYW1lKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2VuL21haW4vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dDMoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0MTAudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUyKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0MTAudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gIHRhcmdldCxcbiAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gIHN0YXRlLFxuICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gIHJlbGF0aXZlLFxuICB2aWV3VHJhbnNpdGlvblxufSA9IHt9KSB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuICByZXR1cm4gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCByZXBsYWNlMiA9IHJlcGxhY2VQcm9wICE9PSB2b2lkIDAgPyByZXBsYWNlUHJvcCA6IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuICAgICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICBwYXRoLFxuICAgICAgcmVwbGFjZVByb3AsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB2aWV3VHJhbnNpdGlvblxuICAgIF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xuICB3YXJuaW5nKFxuICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgYFlvdSBjYW5ub3QgdXNlIHRoZSBcXGB1c2VTZWFyY2hQYXJhbXNcXGAgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IEV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIGh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtcy5gXG4gICk7XG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QxMC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdDEwLnVzZVJlZihmYWxzZSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4gKFxuICAgICAgLy8gT25seSBtZXJnZSBpbiB0aGUgZGVmYXVsdHMgaWYgd2UgaGF2ZW4ndCB5ZXQgY2FsbGVkIHNldFNlYXJjaFBhcmFtcy5cbiAgICAgIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XG4gICAgICAvLyByZW1vdmUgYSBwYXJhbSB3aXRoIHNldFNlYXJjaFBhcmFtcyh7fSkgaWYgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWVcbiAgICAgIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKFxuICAgICAgICBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudFxuICAgICAgKVxuICAgICksXG4gICAgW2xvY2F0aW9uLnNlYXJjaF1cbiAgKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgdHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXRcbiAgICAgICk7XG4gICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXVxuICApO1xuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cbnZhciBmZXRjaGVySWQgPSAwO1xudmFyIGdldFVuaXF1ZUZldGNoZXJJZCA9ICgpID0+IGBfXyR7U3RyaW5nKCsrZmV0Y2hlcklkKX1fX2A7XG5mdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlU3VibWl0XCIgLyogVXNlU3VibWl0ICovKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBjdXJyZW50Um91dGVJZCA9IHVzZVJvdXRlSWQoKTtcbiAgcmV0dXJuIFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRhcmdldCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBsZXQgeyBhY3Rpb24sIG1ldGhvZCwgZW5jVHlwZSwgZm9ybURhdGEsIGJvZHkgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBiYXNlbmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChvcHRpb25zLm5hdmlnYXRlID09PSBmYWxzZSkge1xuICAgICAgICBsZXQga2V5ID0gb3B0aW9ucy5mZXRjaGVyS2V5IHx8IGdldFVuaXF1ZUZldGNoZXJJZCgpO1xuICAgICAgICBhd2FpdCByb3V0ZXIuZmV0Y2goa2V5LCBjdXJyZW50Um91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgICAgZmx1c2hTeW5jOiBvcHRpb25zLmZsdXNoU3luY1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHJvdXRlci5uYXZpZ2F0ZShvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkLFxuICAgICAgICAgIGZsdXNoU3luYzogb3B0aW9ucy5mbHVzaFN5bmMsXG4gICAgICAgICAgdmlld1RyYW5zaXRpb246IG9wdGlvbnMudmlld1RyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBiYXNlbmFtZSwgY3VycmVudFJvdXRlSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgeyByZWxhdGl2ZSB9ID0ge30pIHtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdDEwLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlQ29udGV4dCwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIik7XG4gIGxldCBbbWF0Y2hdID0gcm91dGVDb250ZXh0Lm1hdGNoZXMuc2xpY2UoLTEpO1xuICBsZXQgcGF0aCA9IHsgLi4udXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7IHJlbGF0aXZlIH0pIH07XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICBsZXQgaW5kZXhWYWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gICAgbGV0IGhhc05ha2VkSW5kZXhQYXJhbSA9IGluZGV4VmFsdWVzLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xuICAgIGlmIChoYXNOYWtlZEluZGV4UGFyYW0pIHtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIGluZGV4VmFsdWVzLmZpbHRlcigodikgPT4gdikuZm9yRWFjaCgodikgPT4gcGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHYpKTtcbiAgICAgIGxldCBxcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBxcyA/IGA/JHtxc31gIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoZXIoe1xuICBrZXlcbn0gPSB7fSkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZUZldGNoZXJcIiAvKiBVc2VGZXRjaGVyICovKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlMihcInVzZUZldGNoZXJcIiAvKiBVc2VGZXRjaGVyICovKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QxMC51c2VDb250ZXh0KEZldGNoZXJzQ29udGV4dCk7XG4gIGxldCByb3V0ZSA9IFJlYWN0MTAudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVJZCA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXT8ucm91dGUuaWQ7XG4gIGludmFyaWFudChmZXRjaGVyRGF0YSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIEZldGNoZXJzQ29udGV4dGApO1xuICBpbnZhcmlhbnQocm91dGUsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRgKTtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlSWQgIT0gbnVsbCxcbiAgICBgdXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuICBsZXQgZGVmYXVsdEtleSA9IFJlYWN0MTAudXNlSWQoKTtcbiAgbGV0IFtmZXRjaGVyS2V5LCBzZXRGZXRjaGVyS2V5XSA9IFJlYWN0MTAudXNlU3RhdGUoa2V5IHx8IGRlZmF1bHRLZXkpO1xuICBpZiAoa2V5ICYmIGtleSAhPT0gZmV0Y2hlcktleSkge1xuICAgIHNldEZldGNoZXJLZXkoa2V5KTtcbiAgfVxuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcm91dGVyLmdldEZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVGZXRjaGVyKGZldGNoZXJLZXkpO1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG4gIGxldCBsb2FkID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAoaHJlZiwgb3B0cykgPT4ge1xuICAgICAgaW52YXJpYW50KHJvdXRlSWQsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpO1xuICAgIH0sXG4gICAgW2ZldGNoZXJLZXksIHJvdXRlSWQsIHJvdXRlcl1cbiAgKTtcbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRhcmdldCwgb3B0cykgPT4ge1xuICAgICAgYXdhaXQgc3VibWl0SW1wbCh0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCBzdWJtaXRJbXBsXVxuICApO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdDEwLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybTIgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChGb3JtLCB7IC4uLnByb3BzLCBuYXZpZ2F0ZTogZmFsc2UsIGZldGNoZXJLZXksIHJlZiB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIEZldGNoZXJGb3JtMi5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgcmV0dXJuIEZldGNoZXJGb3JtMjtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YTIgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgICAgc3VibWl0LFxuICAgICAgbG9hZCxcbiAgICAgIC4uLmZldGNoZXIsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH0pLFxuICAgIFtGZXRjaGVyRm9ybSwgc3VibWl0LCBsb2FkLCBmZXRjaGVyLCBkYXRhMl1cbiAgKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlcnNcIiAvKiBVc2VGZXRjaGVycyAqLyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleVxuICB9KSk7XG59XG52YXIgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xudmFyIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG5mdW5jdGlvbiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSkge1xuICBsZXQga2V5ID0gbnVsbDtcbiAgaWYgKGdldEtleSkge1xuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIGtleSA9IGdldEtleShcbiAgICAgICAge1xuICAgICAgICAgIC4uLmxvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAga2V5ID0gbG9jYXRpb24ua2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqLyk7XG4gIGxldCB7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0IH0gPSB1c2VEYXRhUm91dGVyU3RhdGUyKFxuICAgIFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqL1xuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QxMC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgZ2V0S2V5KTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYEZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5ICgke2Vycm9yfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9LCBbbmF2aWdhdGlvbi5zdGF0ZSwgZ2V0S2V5LCBiYXNlbmFtZSwgbG9jYXRpb24sIG1hdGNoZXMsIHN0b3JhZ2VLZXldKVxuICApO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXkgPyAobG9jYXRpb24yLCBtYXRjaGVzMikgPT4gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24yLCBtYXRjaGVzMiwgYmFzZW5hbWUsIGdldEtleSkgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2Vcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIG9wdHMgPSB7fSkge1xuICBsZXQgdnRDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gIGludmFyaWFudChcbiAgICB2dENvbnRleHQgIT0gbnVsbCxcbiAgICBcImB1c2VWaWV3VHJhbnNpdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgd2l0aGluIGByZWFjdC1yb3V0ZXItZG9tYCdzIGBSb3V0ZXJQcm92aWRlcmAuICBEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXG4gICAgXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCIgLyogdXNlVmlld1RyYW5zaXRpb25TdGF0ZSAqL1xuICApO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogb3B0cy5yZWxhdGl2ZSB9KTtcbiAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjdXJyZW50UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWU7XG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuXG4vLyBsaWIvZG9tL3NlcnZlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTEgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AgPSBcIi9cIlxufSkge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxvY2F0aW9uID0ge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblByb3AucGF0aG5hbWUgfHwgXCIvXCIsXG4gICAgc2VhcmNoOiBsb2NhdGlvblByb3Auc2VhcmNoIHx8IFwiXCIsXG4gICAgaGFzaDogbG9jYXRpb25Qcm9wLmhhc2ggfHwgXCJcIixcbiAgICBzdGF0ZTogbG9jYXRpb25Qcm9wLnN0YXRlICE9IG51bGwgPyBsb2NhdGlvblByb3Auc3RhdGUgOiBudWxsLFxuICAgIGtleTogbG9jYXRpb25Qcm9wLmtleSB8fCBcImRlZmF1bHRcIlxuICB9O1xuICBsZXQgc3RhdGljTmF2aWdhdG9yID0gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IHRydWVcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBTdGF0aWNSb3V0ZXJQcm92aWRlcih7XG4gIGNvbnRleHQsXG4gIHJvdXRlcixcbiAgaHlkcmF0ZSA9IHRydWUsXG4gIG5vbmNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXIgJiYgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYHJvdXRlcmAgYW5kIGBjb250ZXh0YCB0byA8U3RhdGljUm91dGVyUHJvdmlkZXI+XCJcbiAgKTtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0ge1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3I6IGdldFN0YXRlbGVzc05hdmlnYXRvcigpLFxuICAgIHN0YXRpYzogdHJ1ZSxcbiAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0LFxuICAgIGJhc2VuYW1lOiBjb250ZXh0LmJhc2VuYW1lIHx8IFwiL1wiXG4gIH07XG4gIGxldCBmZXRjaGVyc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaHlkcmF0ZVNjcmlwdCA9IFwiXCI7XG4gIGlmIChoeWRyYXRlICE9PSBmYWxzZSkge1xuICAgIGxldCBkYXRhMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07XG4gICAgbGV0IGpzb24gPSBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEyKSkpO1xuICAgIGh5ZHJhdGVTY3JpcHQgPSBgd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSA9IEpTT04ucGFyc2UoJHtqc29ufSk7YDtcbiAgfVxuICBsZXQgeyBzdGF0ZSB9ID0gZGF0YVJvdXRlckNvbnRleHQucm91dGVyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChSZWFjdDExLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyc0NvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICAgIERhdGFSb3V0ZXMyLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBoeWRyYXRlU2NyaXB0ID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBoeWRyYXRlU2NyaXB0IH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMyKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi52YWwubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogdmFsLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIHtcbiAgICAuLi5vcHRzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQsIG9wdHMgPSB7fSkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttYXRjaC5yb3V0ZS5pZF0gfHwgbWF0Y2gucm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgcm91dGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IG1zZyA9IChtZXRob2QpID0+IGBZb3UgY2Fubm90IHVzZSByb3V0ZXIuJHttZXRob2R9KCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50YDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRzPy5mdXR1cmVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaXN0b3J5QWN0aW9uOiBcIlBPUFwiIC8qIFBvcCAqLyxcbiAgICAgICAgbG9jYXRpb246IGNvbnRleHQubG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgICBlcnJvcnM6IGNvbnRleHQuZXJyb3JzLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IG51bGwsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIGZldGNoZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcImluaXRpYWxpemVcIik7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJzdWJzY3JpYmVcIik7XG4gICAgfSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgICAgIHRocm93IG1zZyhcImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uXCIpO1xuICAgIH0sXG4gICAgbmF2aWdhdGUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJuYXZpZ2F0ZVwiKTtcbiAgICB9LFxuICAgIGZldGNoKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZmV0Y2hcIik7XG4gICAgfSxcbiAgICByZXZhbGlkYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwicmV2YWxpZGF0ZVwiKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgZ2V0RmV0Y2hlcigpIHtcbiAgICAgIHJldHVybiBJRExFX0ZFVENIRVI7XG4gICAgfSxcbiAgICBkZWxldGVGZXRjaGVyKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGVsZXRlRmV0Y2hlclwiKTtcbiAgICB9LFxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkaXNwb3NlXCIpO1xuICAgIH0sXG4gICAgZ2V0QmxvY2tlcigpIHtcbiAgICAgIHJldHVybiBJRExFX0JMT0NLRVI7XG4gICAgfSxcbiAgICBkZWxldGVCbG9ja2VyKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGVsZXRlQmxvY2tlclwiKTtcbiAgICB9LFxuICAgIHBhdGNoUm91dGVzKCkge1xuICAgICAgdGhyb3cgbXNnKFwicGF0Y2hSb3V0ZXNcIik7XG4gICAgfSxcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIF9pbnRlcm5hbFNldFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcIl9pbnRlcm5hbFNldFJvdXRlc1wiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xufVxuZnVuY3Rpb24gZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICBsZXQgZW5jb2RlZCA9IEFCU09MVVRFX1VSTF9SRUdFWDMudGVzdChocmVmKSA/IG5ldyBVUkwoaHJlZikgOiBuZXcgVVJMKGhyZWYsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogZW5jb2RlZC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IGVuY29kZWQuc2VhcmNoLFxuICAgIGhhc2g6IGVuY29kZWQuaGFzaFxuICB9O1xufVxudmFyIEFCU09MVVRFX1VSTF9SRUdFWDMgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgRVNDQVBFX0xPT0tVUDIgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVgyID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkVHRVgyLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVAyW21hdGNoXSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3NlcnZlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTIgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBTZXJ2ZXJSb3V0ZXIoe1xuICBjb250ZXh0LFxuICB1cmwsXG4gIG5vbmNlXG59KSB7XG4gIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICB9XG4gIGxldCB7IG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGNyaXRpY2FsQ3NzLCBzZXJ2ZXJIYW5kb2ZmU3RyaW5nIH0gPSBjb250ZXh0O1xuICBsZXQgcm91dGVzID0gY3JlYXRlU2VydmVyUm91dGVzKFxuICAgIG1hbmlmZXN0LnJvdXRlcyxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgY29udGV4dC5mdXR1cmUsXG4gICAgY29udGV4dC5pc1NwYU1vZGVcbiAgKTtcbiAgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5sb2FkZXJEYXRhID0ge1xuICAgIC4uLmNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YVxuICB9O1xuICBmb3IgKGxldCBtYXRjaCBvZiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0Lm1hdGNoZXMpIHtcbiAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGxldCByb3V0ZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcbiAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IGNvbnRleHQubWFuaWZlc3Qucm91dGVzW3JvdXRlSWRdO1xuICAgIGlmIChyb3V0ZSAmJiBtYW5pZmVzdFJvdXRlICYmIHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihtYW5pZmVzdFJvdXRlLCByb3V0ZSwgY29udGV4dC5pc1NwYU1vZGUpICYmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSkge1xuICAgICAgZGVsZXRlIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlciA9IGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZWFjdDEyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFxuICAgIEZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgY3JpdGljYWxDc3MsXG4gICAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmcsXG4gICAgICAgIGZ1dHVyZTogY29udGV4dC5mdXR1cmUsXG4gICAgICAgIGlzU3BhTW9kZTogY29udGV4dC5pc1NwYU1vZGUsXG4gICAgICAgIHNlcmlhbGl6ZUVycm9yOiBjb250ZXh0LnNlcmlhbGl6ZUVycm9yLFxuICAgICAgICByZW5kZXJNZXRhOiBjb250ZXh0LnJlbmRlck1ldGFcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7IGxvY2F0aW9uOiByb3V0ZXIuc3RhdGUubG9jYXRpb24gfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0YXRpY1JvdXRlclByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQsXG4gICAgICAgIGh5ZHJhdGU6IGZhbHNlXG4gICAgICB9XG4gICAgKSlcbiAgKSwgY29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyZWFtID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZWFjdDEyLlN1c3BlbnNlLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFxuICAgIFN0cmVhbVRyYW5zZmVyLFxuICAgIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBpZGVudGlmaWVyOiAwLFxuICAgICAgcmVhZGVyOiBjb250ZXh0LnNlcnZlckhhbmRvZmZTdHJlYW0uZ2V0UmVhZGVyKCksXG4gICAgICB0ZXh0RGVjb2RlcjogbmV3IFRleHREZWNvZGVyKCksXG4gICAgICBub25jZVxuICAgIH1cbiAgKSkgOiBudWxsKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLXRlc3Qtc3R1Yi50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTMgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNTdHViKHJvdXRlcywgY29udGV4dCA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSb3V0ZXNUZXN0U3R1Yih7XG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGh5ZHJhdGlvbkRhdGEsXG4gICAgZnV0dXJlXG4gIH0pIHtcbiAgICBsZXQgcm91dGVyUmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBsZXQgcmVtaXhDb250ZXh0UmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBpZiAocm91dGVyUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGZ1dHVyZToge30sXG4gICAgICAgIG1hbmlmZXN0OiB7XG4gICAgICAgICAgcm91dGVzOiB7fSxcbiAgICAgICAgICBlbnRyeTogeyBpbXBvcnRzOiBbXSwgbW9kdWxlOiBcIlwiIH0sXG4gICAgICAgICAgdXJsOiBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgcm91dGVNb2R1bGVzOiB7fSxcbiAgICAgICAgaXNTcGFNb2RlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBwYXRjaGVkID0gcHJvY2Vzc1JvdXRlcyhcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb2FkZXIvYWN0aW9uIGNvbnRleHQgdHlwZXMgZG9uJ3QgbWF0Y2ggOi9cbiAgICAgICAgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMsIChyKSA9PiByKSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQubWFuaWZlc3QsXG4gICAgICAgIHJlbWl4Q29udGV4dFJlZi5jdXJyZW50LnJvdXRlTW9kdWxlc1xuICAgICAgKTtcbiAgICAgIHJvdXRlclJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5Um91dGVyKHBhdGNoZWQsIHtcbiAgICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgaHlkcmF0aW9uRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KEZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJlbWl4Q29udGV4dFJlZi5jdXJyZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoUm91dGVyUHJvdmlkZXIsIHsgcm91dGVyOiByb3V0ZXJSZWYuY3VycmVudCB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVzKHJvdXRlcywgY29udGV4dCwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgcGFyZW50SWQpIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlKSA9PiB7XG4gICAgaWYgKCFyb3V0ZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgcm91dGUuaWQgaW4gQHJlbWl4LXJ1bi90ZXN0aW5nIHByb2Nlc3NSb3V0ZXMoKSBmdW5jdGlvblwiXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXIsIGFjdGlvbiB9ID0gcm91dGU7XG4gICAgbGV0IG5ld1JvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIENvbXBvbmVudDogcm91dGUuQ29tcG9uZW50LFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiByb3V0ZS5IeWRyYXRlRmFsbGJhY2ssXG4gICAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5LFxuICAgICAgYWN0aW9uOiBhY3Rpb24gPyAoYXJncykgPT4gYWN0aW9uKHsgLi4uYXJncywgY29udGV4dCB9KSA6IHZvaWQgMCxcbiAgICAgIGxvYWRlcjogbG9hZGVyID8gKGFyZ3MpID0+IGxvYWRlcih7IC4uLmFyZ3MsIGNvbnRleHQgfSkgOiB2b2lkIDAsXG4gICAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlLnNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGxldCBlbnRyeVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhcmVudElkLFxuICAgICAgaGFzQWN0aW9uOiByb3V0ZS5hY3Rpb24gIT0gbnVsbCxcbiAgICAgIGhhc0xvYWRlcjogcm91dGUubG9hZGVyICE9IG51bGwsXG4gICAgICAvLyBXaGVuIHRlc3Rpbmcgcm91dGVzLCB5b3Ugc2hvdWxkIGp1c3QgYmUgc3R1YmJpbmcgbG9hZGVyL2FjdGlvbiwgbm90XG4gICAgICAvLyB0cnlpbmcgdG8gcmUtaW1wbGVtZW50IHRoZSBmdWxsIGxvYWRlci9jbGllbnRMb2FkZXIvU1NSL2h5ZHJhdGlvbiBmbG93LlxuICAgICAgLy8gVGhhdCBpcyBiZXR0ZXIgdGVzdGVkIHZpYSBFMkUgdGVzdHMuXG4gICAgICBoYXNDbGllbnRBY3Rpb246IGZhbHNlLFxuICAgICAgaGFzQ2xpZW50TG9hZGVyOiBmYWxzZSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCxcbiAgICAgIG1vZHVsZTogXCJidWlsZC9zdHViLXBhdGgtdG8tbW9kdWxlLmpzXCJcbiAgICAgIC8vIGFueSBuZWVkIGZvciB0aGlzP1xuICAgIH07XG4gICAgbWFuaWZlc3Qucm91dGVzW25ld1JvdXRlLmlkXSA9IGVudHJ5Um91dGU7XG4gICAgcm91dGVNb2R1bGVzW3JvdXRlLmlkXSA9IHtcbiAgICAgIGRlZmF1bHQ6IHJvdXRlLkNvbXBvbmVudCB8fCBPdXRsZXQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICAgICAgbGlua3M6IHJvdXRlLmxpbmtzLFxuICAgICAgbWV0YTogcm91dGUubWV0YSxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlLnNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgbmV3Um91dGUuY2hpbGRyZW4gPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICByb3V0ZS5jaGlsZHJlbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgbmV3Um91dGUuaWRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXdSb3V0ZTtcbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jb29raWVzLnRzXG5pbXBvcnQgeyBwYXJzZSwgc2VyaWFsaXplIH0gZnJvbSBcImNvb2tpZVwiO1xuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY3J5cHRvLnRzXG52YXIgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xudmFyIHNpZ24gPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBsZXQgZGF0YTIgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhd2FpdCBjcmVhdGVLZXkyKHNlY3JldCwgW1wic2lnblwiXSk7XG4gIGxldCBzaWduYXR1cmUgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oXCJITUFDXCIsIGtleSwgZGF0YTIpO1xuICBsZXQgaGFzaCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSkucmVwbGFjZShcbiAgICAvPSskLyxcbiAgICBcIlwiXG4gICk7XG4gIHJldHVybiB2YWx1ZSArIFwiLlwiICsgaGFzaDtcbn07XG52YXIgdW5zaWduID0gYXN5bmMgKGNvb2tpZSwgc2VjcmV0KSA9PiB7XG4gIGxldCBpbmRleCA9IGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gIGxldCB2YWx1ZSA9IGNvb2tpZS5zbGljZSgwLCBpbmRleCk7XG4gIGxldCBoYXNoID0gY29va2llLnNsaWNlKGluZGV4ICsgMSk7XG4gIGxldCBkYXRhMiA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IGtleSA9IGF3YWl0IGNyZWF0ZUtleTIoc2VjcmV0LCBbXCJ2ZXJpZnlcIl0pO1xuICBsZXQgc2lnbmF0dXJlID0gYnl0ZVN0cmluZ1RvVWludDhBcnJheShhdG9iKGhhc2gpKTtcbiAgbGV0IHZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoXCJITUFDXCIsIGtleSwgc2lnbmF0dXJlLCBkYXRhMik7XG4gIHJldHVybiB2YWxpZCA/IHZhbHVlIDogZmFsc2U7XG59O1xudmFyIGNyZWF0ZUtleTIgPSBhc3luYyAoc2VjcmV0LCB1c2FnZXMpID0+IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICBcInJhd1wiLFxuICBlbmNvZGVyLmVuY29kZShzZWNyZXQpLFxuICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICBmYWxzZSxcbiAgdXNhZ2VzXG4pO1xuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvVWludDhBcnJheShieXRlU3RyaW5nKSB7XG4gIGxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY29va2llcy50c1xudmFyIGNyZWF0ZUNvb2tpZSA9IChuYW1lLCBjb29raWVPcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHsgc2VjcmV0cyA9IFtdLCAuLi5vcHRpb25zIH0gPSB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgc2FtZVNpdGU6IFwibGF4XCIsXG4gICAgLi4uY29va2llT3B0aW9uc1xuICB9O1xuICB3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZShuYW1lLCBvcHRpb25zLmV4cGlyZXMpO1xuICByZXR1cm4ge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcbiAgICBnZXQgaXNTaWduZWQoKSB7XG4gICAgICByZXR1cm4gc2VjcmV0cy5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgZ2V0IGV4cGlyZXMoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMWUzKSA6IG9wdGlvbnMuZXhwaXJlcztcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlKGNvb2tpZUhlYWRlciwgcGFyc2VPcHRpb25zKSB7XG4gICAgICBpZiAoIWNvb2tpZUhlYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgY29va2llcyA9IHBhcnNlKGNvb2tpZUhlYWRlciwgeyAuLi5vcHRpb25zLCAuLi5wYXJzZU9wdGlvbnMgfSk7XG4gICAgICBpZiAobmFtZSBpbiBjb29raWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvb2tpZXNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICBsZXQgZGVjb2RlZCA9IGF3YWl0IGRlY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKTtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBzZXJpYWxpemUodmFsdWUsIHNlcmlhbGl6ZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlID09PSBcIlwiID8gXCJcIiA6IGF3YWl0IGVuY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uc2VyaWFsaXplT3B0aW9uc1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgaXNDb29raWUgPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0Lm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5pc1NpZ25lZCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIG9iamVjdC5wYXJzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3Quc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCI7XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgbGV0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHZhbHVlKTtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGVuY29kZWQgPSBhd2FpdCBzaWduKGVuY29kZWQsIHNlY3JldHNbMF0pO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHNlY3JldCBvZiBzZWNyZXRzKSB7XG4gICAgICBsZXQgdW5zaWduZWRWYWx1ZSA9IGF3YWl0IHVuc2lnbih2YWx1ZSwgc2VjcmV0KTtcbiAgICAgIGlmICh1bnNpZ25lZFZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlRGF0YSh1bnNpZ25lZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGRlY29kZURhdGEodmFsdWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh2YWx1ZSkge1xuICByZXR1cm4gYnRvYShteVVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVEYXRhKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KG15RXNjYXBlKGF0b2IodmFsdWUpKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuZnVuY3Rpb24gbXlFc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBjb2RlO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoL1tcXHcqK1xcLS4vQF0vLmV4ZWMoY2hyKSkge1xuICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJVwiICsgaGV4KGNvZGUsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJXVcIiArIGhleChjb2RlLCA0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGV4KGNvZGUsIGxlbmd0aCkge1xuICBsZXQgcmVzdWx0ID0gY29kZS50b1N0cmluZygxNik7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoKSByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG15VW5lc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBwYXJ0O1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoY2hyID09PSBcIiVcIikge1xuICAgICAgaWYgKHN0ci5jaGFyQXQoaW5kZXgpID09PSBcInVcIikge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4ICsgMSwgaW5kZXggKyA1KTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17NH0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17Mn0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgKz0gY2hyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZShuYW1lLCBleHBpcmVzKSB7XG4gIHdhcm5PbmNlKFxuICAgICFleHBpcmVzLFxuICAgIGBUaGUgXCIke25hbWV9XCIgY29va2llIGhhcyBhbiBcImV4cGlyZXNcIiBwcm9wZXJ0eSBzZXQuIFRoaXMgd2lsbCBjYXVzZSB0aGUgZXhwaXJlcyB2YWx1ZSB0byBub3QgYmUgdXBkYXRlZCB3aGVuIHRoZSBzZXNzaW9uIGlzIGNvbW1pdHRlZC4gSW5zdGVhZCwgeW91IHNob3VsZCBzZXQgdGhlIGV4cGlyZXMgdmFsdWUgd2hlbiBzZXJpYWxpemluZyB0aGUgY29va2llLiBZb3UgY2FuIHVzZSBcXGBjb21taXRTZXNzaW9uKHNlc3Npb24sIHsgZXhwaXJlcyB9KVxcYCBpZiB1c2luZyBhIHNlc3Npb24gc3RvcmFnZSBvYmplY3QsIG9yIFxcYGNvb2tpZS5zZXJpYWxpemUoXCJ2YWx1ZVwiLCB7IGV4cGlyZXMgfSlcXGAgaWYgeW91J3JlIHVzaW5nIHRoZSBjb29raWUgZGlyZWN0bHkuYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZW50cnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKG1hbmlmZXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkucmVkdWNlKChtZW1vMiwgcm91dGVJZCkgPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbWVtbzJbcm91dGVJZF0gPSByb3V0ZS5tb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBtZW1vMjtcbiAgfSwge30pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvbW9kZS50c1xudmFyIFNlcnZlck1vZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNb2RlMikgPT4ge1xuICBTZXJ2ZXJNb2RlMltcIkRldmVsb3BtZW50XCJdID0gXCJkZXZlbG9wbWVudFwiO1xuICBTZXJ2ZXJNb2RlMltcIlByb2R1Y3Rpb25cIl0gPSBcInByb2R1Y3Rpb25cIjtcbiAgU2VydmVyTW9kZTJbXCJUZXN0XCJdID0gXCJ0ZXN0XCI7XG4gIHJldHVybiBTZXJ2ZXJNb2RlMjtcbn0pKFNlcnZlck1vZGUgfHwge30pO1xuZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovIHx8IHZhbHVlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovIHx8IHZhbHVlID09PSBcInRlc3RcIiAvKiBUZXN0ICovO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZXJyb3JzLnRzXG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIHNlcnZlck1vZGUgIT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLykge1xuICAgIGxldCBzYW5pdGl6ZWQgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiKTtcbiAgICBzYW5pdGl6ZWQuc3RhY2sgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHNhbml0aXplZDtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9ycyhlcnJvcnMsIHNlcnZlck1vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGVycm9ycykucmVkdWNlKChhY2MsIFtyb3V0ZUlkLCBlcnJvcl0pID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW3JvdXRlSWRdOiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB9KTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgIHN0YWNrOiBzYW5pdGl6ZWQuc3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yczIoZXJyb3JzLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIiB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUVycm9yKHZhbCwgc2VydmVyTW9kZSk7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7XG4gICAgICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgICAgICBzdGFjazogc2FuaXRpemVkLnN0YWNrLFxuICAgICAgICBfX3R5cGU6IFwiRXJyb3JcIixcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN1YmNsYXNzIChpLmUuLCBSZWZlcmVuY2VFcnJvciksIHNlbmQgdXAgdGhlIHR5cGUgc28gd2VcbiAgICAgICAgLy8gY2FuIHJlLWNyZWF0ZSB0aGUgc2FtZSB0eXBlIGR1cmluZyBoeWRyYXRpb24uICBUaGlzIHdpbGwgb25seSBhcHBseVxuICAgICAgICAvLyBpbiBkZXYgbW9kZSBzaW5jZSBhbGwgcHJvZHVjdGlvbiBlcnJvcnMgYXJlIHNhbml0aXplZCB0byBub3JtYWxcbiAgICAgICAgLy8gRXJyb3IgaW5zdGFuY2VzXG4gICAgICAgIC4uLnNhbml0aXplZC5uYW1lICE9PSBcIkVycm9yXCIgPyB7XG4gICAgICAgICAgX19zdWJUeXBlOiBzYW5pdGl6ZWQubmFtZVxuICAgICAgICB9IDoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZU1hdGNoaW5nLnRzXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBwYXRobmFtZSxcbiAgICBiYXNlbmFtZVxuICApO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlSGFuZGxlcihoYW5kbGVyLCBhcmdzKSB7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKHtcbiAgICByZXF1ZXN0OiBzdHJpcFJvdXRlc1BhcmFtKHN0cmlwSW5kZXhQYXJhbTIoYXJncy5yZXF1ZXN0KSksXG4gICAgcGFyYW1zOiBhcmdzLnBhcmFtcyxcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHRcbiAgfSk7XG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkgJiYgcmVzdWx0LmluaXQgJiYgcmVzdWx0LmluaXQuc3RhdHVzICYmIGlzUmVkaXJlY3RTdGF0dXNDb2RlKHJlc3VsdC5pbml0LnN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwgcmVzdWx0LmluaXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0yKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHN0cmlwUm91dGVzUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX3JvdXRlc1wiKTtcbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2ludmFyaWFudC50c1xuZnVuY3Rpb24gaW52YXJpYW50Myh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlRoZSBmb2xsb3dpbmcgZXJyb3IgaXMgYSBidWcgaW4gUmVhY3QgUm91dGVyOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSEgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzL25ldy9jaG9vc2VcIlxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZXMudHNcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpIHtcbiAgbGV0IHJvdXRlcyA9IHt9O1xuICBPYmplY3QudmFsdWVzKG1hbmlmZXN0KS5mb3JFYWNoKChyb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbGV0IHBhcmVudElkID0gcm91dGUucGFyZW50SWQgfHwgXCJcIjtcbiAgICAgIGlmICghcm91dGVzW3BhcmVudElkXSkge1xuICAgICAgICByb3V0ZXNbcGFyZW50SWRdID0gW107XG4gICAgICB9XG4gICAgICByb3V0ZXNbcGFyZW50SWRdLnB1c2gocm91dGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+ICh7XG4gICAgLi4ucm91dGUsXG4gICAgY2hpbGRyZW46IGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcm91dGUuaWQsIHJvdXRlc0J5UGFyZW50SWQpXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKG1hbmlmZXN0LCBmdXR1cmUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgY29tbW9uUm91dGUgPSB7XG4gICAgICAvLyBBbHdheXMgaW5jbHVkZSByb290IGR1ZSB0byBkZWZhdWx0IGJvdW5kYXJpZXNcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmlkID09PSBcInJvb3RcIiB8fCByb3V0ZS5tb2R1bGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIC8vIE5lZWQgdG8gdXNlIFJSJ3MgdmVyc2lvbiBpbiB0aGUgcGFyYW0gdHlwZWQgaGVyZSB0byBwZXJtaXQgdGhlIG9wdGlvbmFsXG4gICAgICAvLyBjb250ZXh0IGV2ZW4gdGhvdWdoIHdlIGtub3cgaXQnbGwgYWx3YXlzIGJlIHByb3ZpZGVkIGluIHJlbWl4XG4gICAgICBsb2FkZXI6IHJvdXRlLm1vZHVsZS5sb2FkZXIgPyBhc3luYyAoYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5yZXF1ZXN0LmhlYWRlcnMuaGFzKFwiWC1SZWFjdC1Sb3V0ZXItUHJlcmVuZGVyLURhdGFcIikpIHtcbiAgICAgICAgICBjb25zdCBwcmVSZW5kZXJlZERhdGEgPSBhcmdzLnJlcXVlc3QuaGVhZGVycy5nZXQoXG4gICAgICAgICAgICBcIlgtUmVhY3QtUm91dGVyLVByZXJlbmRlci1EYXRhXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBlbmNvZGVkID0gcHJlUmVuZGVyZWREYXRhID8gZGVjb2RlVVJJKHByZVJlbmRlcmVkRGF0YSkgOiBwcmVSZW5kZXJlZERhdGE7XG4gICAgICAgICAgaW52YXJpYW50MyhlbmNvZGVkLCBcIk1pc3NpbmcgcHJlcmVuZGVyZWQgZGF0YSBmb3Igcm91dGVcIik7XG4gICAgICAgICAgbGV0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZW5jb2RlZCk7XG4gICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh1aW50OGFycmF5KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0oc3RyZWFtLCBnbG9iYWwpO1xuICAgICAgICAgIGxldCBkYXRhMiA9IGRlY29kZWQudmFsdWU7XG4gICAgICAgICAgaW52YXJpYW50MyhcbiAgICAgICAgICAgIGRhdGEyICYmIHJvdXRlLmlkIGluIGRhdGEyLFxuICAgICAgICAgICAgXCJVbmFibGUgdG8gZGVjb2RlIHByZXJlbmRlcmVkIGRhdGFcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGRhdGEyW3JvdXRlLmlkXTtcbiAgICAgICAgICBpbnZhcmlhbnQzKFwiZGF0YVwiIGluIHJlc3VsdCwgXCJVbmFibGUgdG8gcHJvY2VzcyBwcmVyZW5kZXJlZCBkYXRhXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsID0gYXdhaXQgY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUubG9hZGVyLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gOiB2b2lkIDAsXG4gICAgICBhY3Rpb246IHJvdXRlLm1vZHVsZS5hY3Rpb24gPyAoYXJncykgPT4gY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUuYWN0aW9uLCBhcmdzKSA6IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUubW9kdWxlLmhhbmRsZVxuICAgIH07XG4gICAgcmV0dXJuIHJvdXRlLmluZGV4ID8ge1xuICAgICAgaW5kZXg6IHRydWUsXG4gICAgICAuLi5jb21tb25Sb3V0ZVxuICAgIH0gOiB7XG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgY2hpbGRyZW46IGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZnV0dXJlLFxuICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgcm91dGVzQnlQYXJlbnRJZFxuICAgICAgKSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tYXJrdXAudHNcbnZhciBFU0NBUEVfTE9PS1VQMyA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xudmFyIEVTQ0FQRV9SRUdFWDMgPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbDIoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKEVTQ0FQRV9SRUdFWDMsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUDNbbWF0Y2hdKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlckhhbmRvZmYudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICByZXR1cm4gZXNjYXBlSHRtbDIoSlNPTi5zdHJpbmdpZnkoc2VydmVySGFuZG9mZikpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGV2LnRzXG52YXIgZ2xvYmFsRGV2U2VydmVySG9va3NLZXkgPSBcIl9fcmVhY3RSb3V0ZXJEZXZTZXJ2ZXJIb29rc1wiO1xuZnVuY3Rpb24gc2V0RGV2U2VydmVySG9va3MoZGV2U2VydmVySG9va3MpIHtcbiAgZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV0gPSBkZXZTZXJ2ZXJIb29rcztcbn1cbmZ1bmN0aW9uIGdldERldlNlcnZlckhvb2tzKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV07XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zaW5nbGUtZmV0Y2gudHNcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJ0dXJiby1zdHJlYW1cIjtcblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2hlYWRlcnMudHNcbmltcG9ydCB7IHNwbGl0Q29va2llc1N0cmluZyB9IGZyb20gXCJzZXQtY29va2llLXBhcnNlclwiO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KSB7XG4gIGxldCBib3VuZGFyeUlkeCA9IGNvbnRleHQuZXJyb3JzID8gY29udGV4dC5tYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gY29udGV4dC5lcnJvcnNbbS5yb3V0ZS5pZF0pIDogLTE7XG4gIGxldCBtYXRjaGVzID0gYm91bmRhcnlJZHggPj0gMCA/IGNvbnRleHQubWF0Y2hlcy5zbGljZSgwLCBib3VuZGFyeUlkeCArIDEpIDogY29udGV4dC5tYXRjaGVzO1xuICBsZXQgZXJyb3JIZWFkZXJzO1xuICBpZiAoYm91bmRhcnlJZHggPj0gMCkge1xuICAgIGxldCB7IGFjdGlvbkhlYWRlcnMsIGFjdGlvbkRhdGEsIGxvYWRlckhlYWRlcnMsIGxvYWRlckRhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5tYXRjaGVzLnNsaWNlKGJvdW5kYXJ5SWR4KS5zb21lKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICBpZiAoYWN0aW9uSGVhZGVyc1tpZF0gJiYgKCFhY3Rpb25EYXRhIHx8ICFhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGlkKSkpIHtcbiAgICAgICAgZXJyb3JIZWFkZXJzID0gYWN0aW9uSGVhZGVyc1tpZF07XG4gICAgICB9IGVsc2UgaWYgKGxvYWRlckhlYWRlcnNbaWRdICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBsb2FkZXJIZWFkZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckhlYWRlcnMgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpZHgpID0+IHtcbiAgICBsZXQgeyBpZCB9ID0gbWF0Y2gucm91dGU7XG4gICAgbGV0IHJvdXRlID0gYnVpbGQucm91dGVzW2lkXTtcbiAgICBpbnZhcmlhbnQzKHJvdXRlLCBgUm91dGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kIGluIGJ1aWxkYCk7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGUubW9kdWxlO1xuICAgIGxldCBsb2FkZXJIZWFkZXJzID0gY29udGV4dC5sb2FkZXJIZWFkZXJzW2lkXSB8fCBuZXcgSGVhZGVycygpO1xuICAgIGxldCBhY3Rpb25IZWFkZXJzID0gY29udGV4dC5hY3Rpb25IZWFkZXJzW2lkXSB8fCBuZXcgSGVhZGVycygpO1xuICAgIGxldCBpbmNsdWRlRXJyb3JIZWFkZXJzID0gZXJyb3JIZWFkZXJzICE9IG51bGwgJiYgaWR4ID09PSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGluY2x1ZGVFcnJvckNvb2tpZXMgPSBpbmNsdWRlRXJyb3JIZWFkZXJzICYmIGVycm9ySGVhZGVycyAhPT0gbG9hZGVySGVhZGVycyAmJiBlcnJvckhlYWRlcnMgIT09IGFjdGlvbkhlYWRlcnM7XG4gICAgaWYgKHJvdXRlTW9kdWxlLmhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgbGV0IGhlYWRlcnMyID0gbmV3IEhlYWRlcnMocGFyZW50SGVhZGVycyk7XG4gICAgICBpZiAoaW5jbHVkZUVycm9yQ29va2llcykge1xuICAgICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIH1cbiAgICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHJldHVybiBoZWFkZXJzMjtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhcbiAgICAgIHJvdXRlTW9kdWxlLmhlYWRlcnMgPyB0eXBlb2Ygcm91dGVNb2R1bGUuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUuaGVhZGVycyh7XG4gICAgICAgIGxvYWRlckhlYWRlcnMsXG4gICAgICAgIHBhcmVudEhlYWRlcnMsXG4gICAgICAgIGFjdGlvbkhlYWRlcnMsXG4gICAgICAgIGVycm9ySGVhZGVyczogaW5jbHVkZUVycm9ySGVhZGVycyA/IGVycm9ySGVhZGVycyA6IHZvaWQgMFxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5oZWFkZXJzIDogdm9pZCAwXG4gICAgKTtcbiAgICBpZiAoaW5jbHVkZUVycm9yQ29va2llcykge1xuICAgICAgcHJlcGVuZENvb2tpZXMoZXJyb3JIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICB9XG4gICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVycyk7XG4gICAgcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgaGVhZGVycyk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIG5ldyBIZWFkZXJzKCkpO1xufVxuZnVuY3Rpb24gcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgY2hpbGRIZWFkZXJzKSB7XG4gIGxldCBwYXJlbnRTZXRDb29raWVTdHJpbmcgPSBwYXJlbnRIZWFkZXJzLmdldChcIlNldC1Db29raWVcIik7XG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9IHNwbGl0Q29va2llc1N0cmluZyhwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGNvb2tpZXMuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgICBjaGlsZEhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zaW5nbGUtZmV0Y2gudHNcbnZhciBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTID0gMjAyO1xuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kyKHtcbiAgaXNBY3Rpb25EYXRhUmVxdWVzdCxcbiAgbG9hZFJvdXRlSWRzXG59ID0ge30pIHtcbiAgcmV0dXJuIGFzeW5jICh7IHJlcXVlc3QsIG1hdGNoZXMgfSkgPT4ge1xuICAgIGlmIChpc0FjdGlvbkRhdGFSZXF1ZXN0ICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gbG9hZFJvdXRlSWRzID8gbWF0Y2hlcy5maWx0ZXIoKG0pID0+IGxvYWRSb3V0ZUlkcy5pbmNsdWRlcyhtLnJvdXRlLmlkKSkgOiBtYXRjaGVzO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBtYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+IG1hdGNoLnJlc29sdmUoKSlcbiAgICApO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZShcbiAgICAgIChhY2MsIHJlc3VsdCwgaSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW21hdGNoZXNUb0xvYWRbaV0ucm91dGUuaWRdOiByZXN1bHQgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaEFjdGlvbihidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgICAuLi5yZXF1ZXN0LmJvZHkgPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIGRhdGFTdHJhdGVneTogZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kyKHtcbiAgICAgICAgaXNBY3Rpb25EYXRhUmVxdWVzdDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICApLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY29udGV4dCA9IHJlc3VsdDtcbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgaWYgKGlzUmVkaXJlY3RTdGF0dXNDb2RlKGNvbnRleHQuc3RhdHVzQ29kZSkgJiYgaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJ1aWxkLmJhc2VuYW1lXG4gICAgICAgICksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKS5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGxldCBzaW5nbGVGZXRjaFJlc3VsdDtcbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIHNpbmdsZUZldGNoUmVzdWx0ID0geyBlcnJvcjogT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycylbMF0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7IGRhdGE6IE9iamVjdC52YWx1ZXMoY29udGV4dC5hY3Rpb25EYXRhIHx8IHt9KVswXSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBzaW5nbGVGZXRjaFJlc3VsdCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHsgZXJyb3IgfSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgICBzdGF0dXM6IDUwMFxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVycyhidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGxldCBsb2FkUm91dGVJZHMgPSBuZXcgVVJMKHJlcXVlc3QudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiX3JvdXRlc1wiKT8uc3BsaXQoXCIsXCIpIHx8IHZvaWQgMDtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShoYW5kbGVyUmVxdWVzdCwge1xuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IHRydWUsXG4gICAgICBkYXRhU3RyYXRlZ3k6IGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5Mih7XG4gICAgICAgIGxvYWRSb3V0ZUlkc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHQgPSByZXN1bHQ7XG4gICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICAgIGlmIChpc1JlZGlyZWN0U3RhdHVzQ29kZShjb250ZXh0LnN0YXR1c0NvZGUpICYmIGhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgICBsZXQgbG9hZGVkTWF0Y2hlcyA9IGxvYWRSb3V0ZUlkcyA/IGNvbnRleHQubWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5sb2FkZXIgJiYgbG9hZFJvdXRlSWRzLmluY2x1ZGVzKG0ucm91dGUuaWQpXG4gICAgKSA6IGNvbnRleHQubWF0Y2hlcztcbiAgICBsb2FkZWRNYXRjaGVzLmZvckVhY2goKG0pID0+IHtcbiAgICAgIGxldCB7IGlkIH0gPSBtLnJvdXRlO1xuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzICYmIGNvbnRleHQuZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICByZXN1bHRzW2lkXSA9IHsgZXJyb3I6IGNvbnRleHQuZXJyb3JzW2lkXSB9O1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHJlc3VsdHNbaWRdID0geyBkYXRhOiBjb250ZXh0LmxvYWRlckRhdGFbaWRdIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHsgcm9vdDogeyBlcnJvciB9IH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KHN0YXR1cywgaGVhZGVycywgYmFzZW5hbWUpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGlmIChiYXNlbmFtZSkge1xuICAgIHJlZGlyZWN0MiA9IHN0cmlwQmFzZW5hbWUocmVkaXJlY3QyLCBiYXNlbmFtZSkgfHwgcmVkaXJlY3QyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkaXJlY3Q6IHJlZGlyZWN0MixcbiAgICBzdGF0dXMsXG4gICAgcmV2YWxpZGF0ZTogKFxuICAgICAgLy8gVGVjaG5pY2FsbHkgWC1SZW1peC1SZXZhbGlkYXRlIGlzbid0IG5lZWRlZCBoZXJlIC0gdGhhdCB3YXMgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGRldGFpbCBvZiA/X2RhdGEgcmVxdWVzdHMgYXMgb3VyIHdheSB0byB0ZWxsIHRoZSBmcm9udCBlbmQgdG8gcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSBhIHJlc3BvbnNlIGJvZHkgdG8gaW5jbHVkZSB0aGF0IGluZm9ybWF0aW9uIGluLlxuICAgICAgLy8gV2l0aCBzaW5nbGUgZmV0Y2gsIHdlIHRlbGwgdGhlIGZyb250IGVuZCB2aWEgdGhpcyByZXZhbGlkYXRlIGJvb2xlYW4gZmllbGQuXG4gICAgICAvLyBIb3dldmVyLCB3ZSdyZSByZXNwZWN0aW5nIGl0IGZvciBub3cgYmVjYXVzZSBpdCBtYXkgYmUgc29tZXRoaW5nIGZvbGtzIGhhdmVcbiAgICAgIC8vIHVzZWQgaW4gdGhlaXIgb3duIHJlc3BvbnNlc1xuICAgICAgLy8gVE9ETyh2Myk6IENvbnNpZGVyIHJlbW92aW5nIG9yIG1ha2luZyB0aGlzIG9mZmljaWFsIHB1YmxpYyBBUElcbiAgICAgIGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpIHx8IGhlYWRlcnMuaGFzKFwiU2V0LUNvb2tpZVwiKVxuICAgICksXG4gICAgcmVsb2FkOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpLFxuICAgIHJlcGxhY2U6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVWaWFUdXJib1N0cmVhbShkYXRhMiwgcmVxdWVzdFNpZ25hbCwgc3RyZWFtVGltZW91dCwgc2VydmVyTW9kZSkge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgKCkgPT4gY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJTZXJ2ZXIgVGltZW91dFwiKSksXG4gICAgdHlwZW9mIHN0cmVhbVRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyBzdHJlYW1UaW1lb3V0IDogNDk1MFxuICApO1xuICByZXF1ZXN0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG4gIHJldHVybiBlbmNvZGUoZGF0YTIsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxldCB7IG5hbWUsIG1lc3NhZ2UsIHN0YWNrIH0gPSBzZXJ2ZXJNb2RlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovID8gc2FuaXRpemVFcnJvcih2YWx1ZSwgc2VydmVyTW9kZSkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiU2FuaXRpemVkRXJyb3JcIiwgbmFtZSwgbWVzc2FnZSwgc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yUmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIFtcIkVycm9yUmVzcG9uc2VcIiwgZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIlNpbmdsZUZldGNoUmVkaXJlY3RcIiwgdmFsdWVbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBwb3N0UGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBbXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCJdXG4gICAgXVxuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlci50c1xuZnVuY3Rpb24gZGVyaXZlKGJ1aWxkLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhidWlsZC5yb3V0ZXMsIGJ1aWxkLmZ1dHVyZSk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi87XG4gIGxldCBzdGF0aWNIYW5kbGVyID0gY3JlYXRlU3RhdGljSGFuZGxlcihkYXRhUm91dGVzLCB7XG4gICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lXG4gIH0pO1xuICBsZXQgZXJyb3JIYW5kbGVyID0gYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZUVycm9yIHx8ICgoZXJyb3IsIHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFwidGVzdFwiIC8qIFRlc3QgKi8gJiYgIXJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSAmJiBlcnJvci5lcnJvciA/IGVycm9yLmVycm9yIDogZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXMsXG4gICAgZGF0YVJvdXRlcyxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyXG4gIH07XG59XG52YXIgY3JlYXRlUmVxdWVzdEhhbmRsZXIgPSAoYnVpbGQsIG1vZGUpID0+IHtcbiAgbGV0IF9idWlsZDtcbiAgbGV0IHJvdXRlcztcbiAgbGV0IHNlcnZlck1vZGU7XG4gIGxldCBzdGF0aWNIYW5kbGVyO1xuICBsZXQgZXJyb3JIYW5kbGVyO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgbG9hZENvbnRleHQgPSB7fSkge1xuICAgIF9idWlsZCA9IHR5cGVvZiBidWlsZCA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgYnVpbGQoKSA6IGJ1aWxkO1xuICAgIGlmICh0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9IGVsc2UgaWYgKCFyb3V0ZXMgfHwgIXNlcnZlck1vZGUgfHwgIXN0YXRpY0hhbmRsZXIgfHwgIWVycm9ySGFuZGxlcikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8pIHtcbiAgICAgICAgZ2V0RGV2U2VydmVySG9va3MoKT8ucHJvY2Vzc1JlcXVlc3RFcnJvcj8uKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGVycm9ySGFuZGxlcihlcnJvciwge1xuICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxldCBtYW5pZmVzdFVybCA9IGAke19idWlsZC5iYXNlbmFtZSA/PyBcIi9cIn0vX19tYW5pZmVzdGAucmVwbGFjZShcbiAgICAgIC9cXC8rL2csXG4gICAgICBcIi9cIlxuICAgICk7XG4gICAgaWYgKHVybC5wYXRobmFtZSA9PT0gbWFuaWZlc3RVcmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoX2J1aWxkLCByb3V0ZXMsIHVybCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIiwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHVybC5wYXRobmFtZSwgX2J1aWxkLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBtYXRjaGVzWzBdLnBhcmFtcyk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZTtcbiAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgIGxldCBoYW5kbGVyVXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBoYW5kbGVyVXJsLnBhdGhuYW1lID0gaGFuZGxlclVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC5kYXRhJC8sIFwiXCIpLnJlcGxhY2UoL15cXC9fcm9vdCQvLCBcIi9cIik7XG4gICAgICBsZXQgc2luZ2xlRmV0Y2hNYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgaGFuZGxlclVybC5wYXRobmFtZSxcbiAgICAgICAgX2J1aWxkLmJhc2VuYW1lXG4gICAgICApO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgaGFuZGxlclVybCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yXG4gICAgICApO1xuICAgICAgaWYgKF9idWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLCB7XG4gICAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgICAgcGFyYW1zOiBzaW5nbGVGZXRjaE1hdGNoZXMgPyBzaW5nbGVGZXRjaE1hdGNoZXNbMF0ucGFyYW1zIDoge30sXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICBfYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgICAgICBfYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5kZWZhdWx0ID09IG51bGwgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ID09IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBzdGF0aWNIYW5kbGVyLFxuICAgICAgICBtYXRjaGVzLnNsaWNlKC0xKVswXS5yb3V0ZS5pZCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3JpdGljYWxDc3MgPSBtb2RlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8gPyBhd2FpdCBnZXREZXZTZXJ2ZXJIb29rcygpPy5nZXRDcml0aWNhbENzcz8uKF9idWlsZCwgdXJsLnBhdGhuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgY3JpdGljYWxDc3NcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoYnVpbGQsIHJvdXRlcywgdXJsKSB7XG4gIGxldCBwYXRjaGVzID0ge307XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcInBcIikpIHtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwicFwiKSkge1xuICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGgsIGJ1aWxkLmJhc2VuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgICAgIGxldCByb3V0ZSA9IGJ1aWxkLmFzc2V0cy5yb3V0ZXNbcm91dGVJZF07XG4gICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBwYXRjaGVzW3JvdXRlSWRdID0gcm91dGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZS5qc29uKHBhdGNoZXMsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwicHVibGljLCBtYXgtYWdlPTMxNTM2MDAwLCBpbW11dGFibGVcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCJJbnZhbGlkIFJlcXVlc3RcIiwgeyBzdGF0dXM6IDQwMCB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNpbmdsZUZldGNoUmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIGxldCB7IHJlc3VsdCwgaGVhZGVycywgc3RhdHVzIH0gPSByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIiA/IGF3YWl0IHNpbmdsZUZldGNoQWN0aW9uKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKSA6IGF3YWl0IHNpbmdsZUZldGNoTG9hZGVycyhcbiAgICBidWlsZCxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgcmVxdWVzdCxcbiAgICBoYW5kbGVyVXJsLFxuICAgIGxvYWRDb250ZXh0LFxuICAgIGhhbmRsZUVycm9yXG4gICk7XG4gIGxldCByZXN1bHRIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gIHJlc3VsdEhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXNwb25zZVwiLCBcInllc1wiKTtcbiAgaWYgKHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMzA0LCBoZWFkZXJzOiByZXN1bHRIZWFkZXJzIH0pO1xuICB9XG4gIHJlc3VsdEhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94LXNjcmlwdFwiKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICBzZXJ2ZXJNb2RlXG4gICAgKSxcbiAgICB7XG4gICAgICBzdGF0dXM6IHN0YXR1cyB8fCAyMDAsXG4gICAgICBoZWFkZXJzOiByZXN1bHRIZWFkZXJzXG4gICAgfVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHNlcnZlck1vZGUsIGJ1aWxkLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IsIGNyaXRpY2FsQ3NzKSB7XG4gIGxldCBjb250ZXh0O1xuICB0cnkge1xuICAgIGNvbnRleHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KHJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoY29udGV4dCkpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gIGlmIChjb250ZXh0LnN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDMwNCwgaGVhZGVycyB9KTtcbiAgfVxuICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKS5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgfVxuICBsZXQgc3RhdGUgPSB7XG4gICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9yczIoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gIH07XG4gIGxldCBlbnRyeUNvbnRleHQgPSB7XG4gICAgbWFuaWZlc3Q6IGJ1aWxkLmFzc2V0cyxcbiAgICByb3V0ZU1vZHVsZXM6IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyksXG4gICAgc3RhdGljSGFuZGxlckNvbnRleHQ6IGNvbnRleHQsXG4gICAgY3JpdGljYWxDc3MsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyh7XG4gICAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWUsXG4gICAgICBjcml0aWNhbENzcyxcbiAgICAgIGZ1dHVyZTogYnVpbGQuZnV0dXJlLFxuICAgICAgaXNTcGFNb2RlOiBidWlsZC5pc1NwYU1vZGVcbiAgICB9KSxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyZWFtOiBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgIHN0YXRlLFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgIHNlcnZlck1vZGVcbiAgICApLFxuICAgIHJlbmRlck1ldGE6IHt9LFxuICAgIGZ1dHVyZTogYnVpbGQuZnV0dXJlLFxuICAgIGlzU3BhTW9kZTogYnVpbGQuaXNTcGFNb2RlLFxuICAgIHNlcmlhbGl6ZUVycm9yOiAoZXJyKSA9PiBzZXJpYWxpemVFcnJvcihlcnIsIHNlcnZlck1vZGUpXG4gIH07XG4gIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbiA9IGJ1aWxkLmVudHJ5Lm1vZHVsZS5kZWZhdWx0O1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW50cnlDb250ZXh0LFxuICAgICAgbG9hZENvbnRleHRcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICBsZXQgZXJyb3JGb3JTZWNvbmRSZW5kZXIgPSBlcnJvcjtcbiAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBkYXRhMiA9IGF3YWl0IHVud3JhcFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgZXJyb3JGb3JTZWNvbmRSZW5kZXIgPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgIGVycm9yLnN0YXR1c1RleHQsXG4gICAgICAgICAgZGF0YTJcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dCA9IGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gICAgICBzdGF0aWNIYW5kbGVyLmRhdGFSb3V0ZXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgZXJyb3JGb3JTZWNvbmRSZW5kZXJcbiAgICApO1xuICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGxldCBzdGF0ZTIgPSB7XG4gICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9yczIoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gICAgfTtcbiAgICBlbnRyeUNvbnRleHQgPSB7XG4gICAgICAuLi5lbnRyeUNvbnRleHQsXG4gICAgICBzdGF0aWNIYW5kbGVyQ29udGV4dDogY29udGV4dCxcbiAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmc6IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoe1xuICAgICAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWUsXG4gICAgICAgIGZ1dHVyZTogYnVpbGQuZnV0dXJlLFxuICAgICAgICBpc1NwYU1vZGU6IGJ1aWxkLmlzU3BhTW9kZVxuICAgICAgfSksXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyZWFtOiBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgc3RhdGUyLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAgYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICAgIHNlcnZlck1vZGVcbiAgICAgICksXG4gICAgICByZW5kZXJNZXRhOiB7fVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGV4dC5zdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBlbnRyeUNvbnRleHQsXG4gICAgICAgIGxvYWRDb250ZXh0XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IyKTtcbiAgICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvcjIsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHNlcnZlck1vZGUsIHN0YXRpY0hhbmRsZXIsIHJvdXRlSWQsIHJlcXVlc3QsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICB0cnkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHN0YXRpY0hhbmRsZXIucXVlcnlSb3V0ZShyZXF1ZXN0LCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0XG4gICAgfSk7XG4gICAgaW52YXJpYW50MyhcbiAgICAgIGlzUmVzcG9uc2UocmVzcG9uc2UpLFxuICAgICAgXCJFeHBlY3RlZCBhIFJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGZyb20gcmVzb3VyY2Ugcm91dGUgaGFuZGxlclwiXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JSZXNwb25zZVRvSnNvbihlcnJvciwgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IsIHNlcnZlck1vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvclJlc3BvbnNlVG9Kc29uKGVycm9yUmVzcG9uc2UsIHNlcnZlck1vZGUpIHtcbiAgcmV0dXJuIFJlc3BvbnNlLmpzb24oXG4gICAgc2VyaWFsaXplRXJyb3IoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgaXMgXCJwcml2YXRlXCIgZnJvbSB1c2VycyBidXQgaW50ZW5kZWQgZm9yIGludGVybmFsIHVzZVxuICAgICAgZXJyb3JSZXNwb25zZS5lcnJvciB8fCBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiKSxcbiAgICAgIHNlcnZlck1vZGVcbiAgICApLFxuICAgIHtcbiAgICAgIHN0YXR1czogZXJyb3JSZXNwb25zZS5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBlcnJvclJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiWC1SZW1peC1FcnJvclwiOiBcInllc1wiXG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG4gIGlmIChzZXJ2ZXJNb2RlICE9PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovKSB7XG4gICAgbWVzc2FnZSArPSBgXG5cbiR7U3RyaW5nKGVycm9yKX1gO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2UobWVzc2FnZSwge1xuICAgIHN0YXR1czogNTAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVud3JhcFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICByZXR1cm4gY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkgPyByZXNwb25zZS5ib2R5ID09IG51bGwgPyBudWxsIDogcmVzcG9uc2UuanNvbigpIDogcmVzcG9uc2UudGV4dCgpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMudHNcbmZ1bmN0aW9uIGZsYXNoKG5hbWUpIHtcbiAgcmV0dXJuIGBfX2ZsYXNoXyR7bmFtZX1fX2A7XG59XG52YXIgY3JlYXRlU2Vzc2lvbiA9IChpbml0aWFsRGF0YSA9IHt9LCBpZCA9IFwiXCIpID0+IHtcbiAgbGV0IG1hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaW5pdGlhbERhdGEpKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobWFwKTtcbiAgICB9LFxuICAgIGhhcyhuYW1lKSB7XG4gICAgICByZXR1cm4gbWFwLmhhcyhuYW1lKSB8fCBtYXAuaGFzKGZsYXNoKG5hbWUpKTtcbiAgICB9LFxuICAgIGdldChuYW1lKSB7XG4gICAgICBpZiAobWFwLmhhcyhuYW1lKSkgcmV0dXJuIG1hcC5nZXQobmFtZSk7XG4gICAgICBsZXQgZmxhc2hOYW1lID0gZmxhc2gobmFtZSk7XG4gICAgICBpZiAobWFwLmhhcyhmbGFzaE5hbWUpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoZmxhc2hOYW1lKTtcbiAgICAgICAgbWFwLmRlbGV0ZShmbGFzaE5hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBtYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9LFxuICAgIGZsYXNoKG5hbWUsIHZhbHVlKSB7XG4gICAgICBtYXAuc2V0KGZsYXNoKG5hbWUpLCB2YWx1ZSk7XG4gICAgfSxcbiAgICB1bnNldChuYW1lKSB7XG4gICAgICBtYXAuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgaXNTZXNzaW9uID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5pZCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmRhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG9iamVjdC5oYXMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3Quc2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5mbGFzaCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QudW5zZXQgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5mdW5jdGlvbiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gIGNvb2tpZTogY29va2llQXJnLFxuICBjcmVhdGVEYXRhLFxuICByZWFkRGF0YSxcbiAgdXBkYXRlRGF0YSxcbiAgZGVsZXRlRGF0YVxufSkge1xuICBsZXQgY29va2llID0gaXNDb29raWUoY29va2llQXJnKSA/IGNvb2tpZUFyZyA6IGNyZWF0ZUNvb2tpZShjb29raWVBcmc/Lm5hbWUgfHwgXCJfX3Nlc3Npb25cIiwgY29va2llQXJnKTtcbiAgd2Fybk9uY2VBYm91dFNpZ25pbmdTZXNzaW9uQ29va2llKGNvb2tpZSk7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgZ2V0U2Vzc2lvbihjb29raWVIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICAgIGxldCBpZCA9IGNvb2tpZUhlYWRlciAmJiBhd2FpdCBjb29raWUucGFyc2UoY29va2llSGVhZGVyLCBvcHRpb25zKTtcbiAgICAgIGxldCBkYXRhMiA9IGlkICYmIGF3YWl0IHJlYWREYXRhKGlkKTtcbiAgICAgIHJldHVybiBjcmVhdGVTZXNzaW9uKGRhdGEyIHx8IHt9LCBpZCB8fCBcIlwiKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgbGV0IHsgaWQsIGRhdGE6IGRhdGEyIH0gPSBzZXNzaW9uO1xuICAgICAgbGV0IGV4cGlyZXMgPSBvcHRpb25zPy5tYXhBZ2UgIT0gbnVsbCA/IG5ldyBEYXRlKERhdGUubm93KCkgKyBvcHRpb25zLm1heEFnZSAqIDFlMykgOiBvcHRpb25zPy5leHBpcmVzICE9IG51bGwgPyBvcHRpb25zLmV4cGlyZXMgOiBjb29raWUuZXhwaXJlcztcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBhd2FpdCB1cGRhdGVEYXRhKGlkLCBkYXRhMiwgZXhwaXJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IGF3YWl0IGNyZWF0ZURhdGEoZGF0YTIsIGV4cGlyZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoaWQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgZGVzdHJveVNlc3Npb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgYXdhaXQgZGVsZXRlRGF0YShzZXNzaW9uLmlkKTtcbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKFwiXCIsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiB2b2lkIDAsXG4gICAgICAgIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gd2Fybk9uY2VBYm91dFNpZ25pbmdTZXNzaW9uQ29va2llKGNvb2tpZSkge1xuICB3YXJuT25jZShcbiAgICBjb29raWUuaXNTaWduZWQsXG4gICAgYFRoZSBcIiR7Y29va2llLm5hbWV9XCIgY29va2llIGlzIG5vdCBzaWduZWQsIGJ1dCBzZXNzaW9uIGNvb2tpZXMgc2hvdWxkIGJlIHNpZ25lZCB0byBwcmV2ZW50IHRhbXBlcmluZyBvbiB0aGUgY2xpZW50IGJlZm9yZSB0aGV5IGFyZSBzZW50IGJhY2sgdG8gdGhlIHNlcnZlci4gU2VlIGh0dHBzOi8vcmVtaXgucnVuL3V0aWxzL2Nvb2tpZXMjc2lnbmluZy1jb29raWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zL2Nvb2tpZVN0b3JhZ2UudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlKHsgY29va2llOiBjb29raWVBcmcgfSA9IHt9KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oXG4gICAgICAgIGNvb2tpZUhlYWRlciAmJiBhd2FpdCBjb29raWUucGFyc2UoY29va2llSGVhZGVyLCBvcHRpb25zKSB8fCB7fVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRDb29raWUgPSBhd2FpdCBjb29raWUuc2VyaWFsaXplKHNlc3Npb24uZGF0YSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc2VyaWFsaXplZENvb2tpZS5sZW5ndGggPiA0MDk2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvb2tpZSBsZW5ndGggd2lsbCBleGNlZWQgYnJvd3NlciBtYXhpbXVtLiBMZW5ndGg6IFwiICsgc2VyaWFsaXplZENvb2tpZS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkQ29va2llO1xuICAgIH0sXG4gICAgYXN5bmMgZGVzdHJveVNlc3Npb24oX3Nlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKFwiXCIsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiB2b2lkIDAsXG4gICAgICAgIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvbWVtb3J5U3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UoeyBjb29raWUgfSA9IHt9KSB7XG4gIGxldCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICAgIGNvb2tpZSxcbiAgICBhc3luYyBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKSB7XG4gICAgICBsZXQgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGFzeW5jIHJlYWREYXRhKGlkKSB7XG4gICAgICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSA9IG1hcC5nZXQoaWQpO1xuICAgICAgICBpZiAoIWV4cGlyZXMgfHwgZXhwaXJlcyA+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzKSBtYXAuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgYXN5bmMgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIG1hcC5zZXQoaWQsIHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSk7XG4gICAgfSxcbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBtYXAuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9lcnJvcnMudHNcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzMihlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbmV4cG9ydCB7XG4gIEFjdGlvbixcbiAgY3JlYXRlQnJvd3Nlckhpc3RvcnksXG4gIGludmFyaWFudCxcbiAgY3JlYXRlUGF0aCxcbiAgcGFyc2VQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFBhdGgsXG4gIHJlc29sdmVQYXRoLFxuICBkYXRhLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVwbGFjZSxcbiAgRXJyb3JSZXNwb25zZUltcGwsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBJRExFX05BVklHQVRJT04sXG4gIElETEVfRkVUQ0hFUixcbiAgSURMRV9CTE9DS0VSLFxuICBjcmVhdGVSb3V0ZXIsXG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBWaWV3VHJhbnNpdGlvbkNvbnRleHQsXG4gIEZldGNoZXJzQ29udGV4dCxcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VNYXRjaGVzLFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUJsb2NrZXIsXG4gIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgY3JlYXRlTWVtb3J5Um91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIEF3YWl0LFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sLFxuICBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneSxcbiAgZGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gIFJlbWl4RXJyb3JCb3VuZGFyeSxcbiAgY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgY3JlYXRlQ2xpZW50Um91dGVzLFxuICBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIHVzZUZvZ09GV2FyRGlzY292ZXJ5LFxuICBGcmFtZXdvcmtDb250ZXh0LFxuICBMaW5rcyxcbiAgUHJlZmV0Y2hQYWdlTGlua3MsXG4gIE1ldGEsXG4gIFNjcmlwdHMsXG4gIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsXG4gIGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIEJyb3dzZXJSb3V0ZXIsXG4gIEhhc2hSb3V0ZXIsXG4gIEhpc3RvcnlSb3V0ZXIsXG4gIExpbmssXG4gIE5hdkxpbmssXG4gIEZvcm0sXG4gIFNjcm9sbFJlc3RvcmF0aW9uLFxuICB1c2VMaW5rQ2xpY2tIYW5kbGVyLFxuICB1c2VTZWFyY2hQYXJhbXMsXG4gIHVzZVN1Ym1pdCxcbiAgdXNlRm9ybUFjdGlvbixcbiAgdXNlRmV0Y2hlcixcbiAgdXNlRmV0Y2hlcnMsXG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZVByb21wdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSxcbiAgU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgY3JlYXRlU3RhdGljSGFuZGxlcjIgYXMgY3JlYXRlU3RhdGljSGFuZGxlcixcbiAgY3JlYXRlU3RhdGljUm91dGVyLFxuICBTZXJ2ZXJSb3V0ZXIsXG4gIGNyZWF0ZVJvdXRlc1N0dWIsXG4gIGNyZWF0ZUNvb2tpZSxcbiAgaXNDb29raWUsXG4gIFNlcnZlck1vZGUsXG4gIHNldERldlNlcnZlckhvb2tzLFxuICBjcmVhdGVSZXF1ZXN0SGFuZGxlcixcbiAgY3JlYXRlU2Vzc2lvbixcbiAgaXNTZXNzaW9uLFxuICBjcmVhdGVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlLFxuICBkZXNlcmlhbGl6ZUVycm9yczIgYXMgZGVzZXJpYWxpemVFcnJvcnNcbn07XG4iLCIvLyBzcmMvdXRpbHMudHNcbnZhciBIT0xFID0gLTE7XG52YXIgTkFOID0gLTI7XG52YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSAtMztcbnZhciBORUdBVElWRV9aRVJPID0gLTQ7XG52YXIgTlVMTCA9IC01O1xudmFyIFBPU0lUSVZFX0lORklOSVRZID0gLTY7XG52YXIgVU5ERUZJTkVEID0gLTc7XG52YXIgVFlQRV9CSUdJTlQgPSBcIkJcIjtcbnZhciBUWVBFX0RBVEUgPSBcIkRcIjtcbnZhciBUWVBFX0VSUk9SID0gXCJFXCI7XG52YXIgVFlQRV9NQVAgPSBcIk1cIjtcbnZhciBUWVBFX05VTExfT0JKRUNUID0gXCJOXCI7XG52YXIgVFlQRV9QUk9NSVNFID0gXCJQXCI7XG52YXIgVFlQRV9SRUdFWFAgPSBcIlJcIjtcbnZhciBUWVBFX1NFVCA9IFwiU1wiO1xudmFyIFRZUEVfU1lNQk9MID0gXCJZXCI7XG52YXIgVFlQRV9VUkwgPSBcIlVcIjtcbnZhciBUWVBFX1BSRVZJT1VTX1JFU09MVkVEID0gXCJaXCI7XG52YXIgRGVmZXJyZWQgPSBjbGFzcyB7XG4gIHByb21pc2U7XG4gIHJlc29sdmU7XG4gIHJlamVjdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlTGluZVNwbGl0dGluZ1RyYW5zZm9ybSgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgbGVmdG92ZXIgPSBcIlwiO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzdHIgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICBjb25zdCBwYXJ0cyA9IChsZWZ0b3ZlciArIHN0cikuc3BsaXQoXCJcXG5cIik7XG4gICAgICBsZWZ0b3ZlciA9IHBhcnRzLnBvcCgpIHx8IFwiXCI7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgaWYgKGxlZnRvdmVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShsZWZ0b3Zlcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2ZsYXR0ZW4udHNcbmZ1bmN0aW9uIGZsYXR0ZW4oaW5wdXQpIHtcbiAgY29uc3QgeyBpbmRpY2VzIH0gPSB0aGlzO1xuICBjb25zdCBleGlzdGluZyA9IGluZGljZXMuZ2V0KGlucHV0KTtcbiAgaWYgKGV4aXN0aW5nKVxuICAgIHJldHVybiBbZXhpc3RpbmddO1xuICBpZiAoaW5wdXQgPT09IHZvaWQgMClcbiAgICByZXR1cm4gVU5ERUZJTkVEO1xuICBpZiAoaW5wdXQgPT09IG51bGwpXG4gICAgcmV0dXJuIE5VTEw7XG4gIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKVxuICAgIHJldHVybiBOQU47XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgIHJldHVybiBQT1NJVElWRV9JTkZJTklUWTtcbiAgaWYgKGlucHV0ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICAgcmV0dXJuIE5FR0FUSVZFX0lORklOSVRZO1xuICBpZiAoaW5wdXQgPT09IDAgJiYgMSAvIGlucHV0IDwgMClcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVSTztcbiAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gIGluZGljZXMuc2V0KGlucHV0LCBpbmRleCk7XG4gIHN0cmluZ2lmeS5jYWxsKHRoaXMsIGlucHV0LCBpbmRleCk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCwgaW5kZXgpIHtcbiAgY29uc3QgeyBkZWZlcnJlZCwgcGx1Z2lucywgcG9zdFBsdWdpbnMgfSA9IHRoaXM7XG4gIGNvbnN0IHN0ciA9IHRoaXMuc3RyaW5naWZpZWQ7XG4gIGNvbnN0IHN0YWNrID0gW1tpbnB1dCwgaW5kZXhdXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5wdXQyLCBpbmRleDJdID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGFydHNGb3JPYmogPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLm1hcCgoaykgPT4gYFwiXyR7ZmxhdHRlbi5jYWxsKHRoaXMsIGspfVwiOiR7ZmxhdHRlbi5jYWxsKHRoaXMsIG9ialtrXSl9YCkuam9pbihcIixcIik7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dDIpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9CSUdJTlR9XCIsXCIke2lucHV0Mn1cIl1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjoge1xuICAgICAgICBjb25zdCBrZXlGb3IgPSBTeW1ib2wua2V5Rm9yKGlucHV0Mik7XG4gICAgICAgIGlmICgha2V5Rm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBlbmNvZGUgc3ltYm9sIHVubGVzcyBjcmVhdGVkIHdpdGggU3ltYm9sLmZvcigpXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TWU1CT0x9XCIsJHtKU09OLnN0cmluZ2lmeShrZXlGb3IpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaW5wdXQyKSB7XG4gICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtOVUxMfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlzQXJyYXkgPyBcIltcIiA6IFwie1wiO1xuICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Mi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IChpID8gXCIsXCIgOiBcIlwiKSArIChpIGluIGlucHV0MiA/IGZsYXR0ZW4uY2FsbCh0aGlzLCBpbnB1dDJbaV0pIDogSE9MRSk7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGAke3Jlc3VsdH1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9EQVRFfVwiLCR7aW5wdXQyLmdldFRpbWUoKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1VSTH1cIiwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5ocmVmKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1JFR0VYUH1cIiwke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBpbnB1dDIuc291cmNlXG4gICAgICAgICAgICApfSwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5mbGFncyl9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1NFVH1cIiwke1suLi5pbnB1dDJdLm1hcCgodmFsKSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdmFsKSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU0VUfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX01BUH1cIiwke1suLi5pbnB1dDJdLmZsYXRNYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4uY2FsbCh0aGlzLCBrKSxcbiAgICAgICAgICAgICAgICBmbGF0dGVuLmNhbGwodGhpcywgdilcbiAgICAgICAgICAgICAgXSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTUFQfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfUFJPTUlTRX1cIiwke2luZGV4Mn1dYDtcbiAgICAgICAgICAgIGRlZmVycmVkW2luZGV4Ml0gPSBpbnB1dDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX0VSUk9SfVwiLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm1lc3NhZ2UpfWA7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLm5hbWUgIT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm5hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dDIpID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTlVMTF9PQkpFQ1R9XCIseyR7cGFydHNGb3JPYmooaW5wdXQyKX19XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGlucHV0MikpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYHske3BhcnRzRm9yT2JqKGlucHV0Mil9fWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGVuY29kZSBvYmplY3Qgd2l0aCBwcm90b3R5cGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnB1dDIpO1xuICAgICAgICBsZXQgcGx1Z2luSGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgcGx1Z2lucykge1xuICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmVzdWx0KSkge1xuICAgICAgICAgICAgICBwbHVnaW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbJHtKU09OLnN0cmluZ2lmeShwbHVnaW5JZGVudGlmaWVyKX1gO1xuICAgICAgICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbkhhbmRsZWQpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgZnVuY3Rpb24gb3IgdW5leHBlY3RlZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwb3N0UGx1Z2lucykge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwb3N0UGx1Z2lucykge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIG9iamVjdFByb3RvTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5zb3J0KCkuam9pbihcIlxcMFwiKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodGhpbmcpIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuICByZXR1cm4gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLnNvcnQoKS5qb2luKFwiXFwwXCIpID09PSBvYmplY3RQcm90b05hbWVzO1xufVxuXG4vLyBzcmMvdW5mbGF0dGVuLnRzXG52YXIgZ2xvYmFsT2JqID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHZvaWQgMDtcbmZ1bmN0aW9uIHVuZmxhdHRlbihwYXJzZWQpIHtcbiAgY29uc3QgeyBoeWRyYXRlZCwgdmFsdWVzIH0gPSB0aGlzO1xuICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gaHlkcmF0ZS5jYWxsKHRoaXMsIHBhcnNlZCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWQpIHx8ICFwYXJzZWQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBwYXJzZWQpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgaHlkcmF0ZWQubGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGh5ZHJhdGUuY2FsbCh0aGlzLCBzdGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoaW5kZXgpIHtcbiAgY29uc3QgeyBoeWRyYXRlZCwgdmFsdWVzLCBkZWZlcnJlZCwgcGx1Z2lucyB9ID0gdGhpcztcbiAgbGV0IHJlc3VsdDtcbiAgY29uc3Qgc3RhY2sgPSBbXG4gICAgW1xuICAgICAgaW5kZXgsXG4gICAgICAodikgPT4ge1xuICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgfVxuICAgIF1cbiAgXTtcbiAgbGV0IHBvc3RSdW4gPSBbXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5kZXgyLCBzZXRdID0gc3RhY2sucG9wKCk7XG4gICAgc3dpdGNoIChpbmRleDIpIHtcbiAgICAgIGNhc2UgVU5ERUZJTkVEOlxuICAgICAgICBzZXQodm9pZCAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5VTEw6XG4gICAgICAgIHNldChudWxsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5BTjpcbiAgICAgICAgc2V0KE5hTik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBQT1NJVElWRV9JTkZJTklUWTpcbiAgICAgICAgc2V0KEluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX0lORklOSVRZOlxuICAgICAgICBzZXQoLUluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX1pFUk86XG4gICAgICAgIHNldCgtMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaHlkcmF0ZWRbaW5kZXgyXSkge1xuICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4Ml07XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSB2YWx1ZTtcbiAgICAgIHNldCh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBiLCBjXSA9IHZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfREFURTpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IERhdGUoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1VSTDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFVSTChiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfQklHSU5UOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBCaWdJbnQoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1JFR0VYUDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFJlZ0V4cChiLCBjKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfU1lNQk9MOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBTeW1ib2wuZm9yKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9TRVQ6XG4gICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG5ld1NldDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBzZXQobmV3U2V0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9NQVA6XG4gICAgICAgICAgICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG1hcDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpICsgMV0sXG4gICAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoclswXSwgclsxXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0KG1hcCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTF9PQkpFQ1Q6XG4gICAgICAgICAgICBjb25zdCBvYmogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBvYmo7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhiKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICBiW2tleV0sXG4gICAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIE51bWJlcihrZXkuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9ialtyWzBdXSA9IHJbMV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0KG9iaik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfUFJPTUlTRTpcbiAgICAgICAgICAgIGlmIChoeWRyYXRlZFtiXSkge1xuICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGh5ZHJhdGVkW2JdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWRbYl0gPSBkO1xuICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGQucHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfRVJST1I6XG4gICAgICAgICAgICBjb25zdCBbLCBtZXNzYWdlLCBlcnJvclR5cGVdID0gdmFsdWU7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBlcnJvclR5cGUgJiYgZ2xvYmFsT2JqICYmIGdsb2JhbE9ialtlcnJvclR5cGVdID8gbmV3IGdsb2JhbE9ialtlcnJvclR5cGVdKG1lc3NhZ2UpIDogbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGVycm9yO1xuICAgICAgICAgICAgc2V0KGVycm9yKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9QUkVWSU9VU19SRVNPTFZFRDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gaHlkcmF0ZWRbYl0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgdmFscyA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsc1tpXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAodjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IHYyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IHBsdWdpbih2YWx1ZVswXSwgLi4ucik7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IHJlc3VsdDIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGFycmF5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHZhbHVlW2ldO1xuICAgICAgICAgIGlmIChuICE9PSBIT0xFKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXQoYXJyYXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBoeWRyYXRlZFtpbmRleDJdID0gb2JqZWN0O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpLnJldmVyc2UoKSkge1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIHZhbHVlW2tleV0sXG4gICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIE51bWJlcihrZXkuc2xpY2UoMSkpLFxuICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgIG9iamVjdFtyWzBdXSA9IHJbMV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2V0KG9iamVjdCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHBvc3RSdW4ubGVuZ3RoID4gMCkge1xuICAgIHBvc3RSdW4ucG9wKCkoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdHVyYm8tc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBkZWNvZGUocmVhZGFibGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBwbHVnaW5zIH0gPSBvcHRpb25zID8/IHt9O1xuICBjb25zdCBkb25lID0gbmV3IERlZmVycmVkKCk7XG4gIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSB7XG4gICAgdmFsdWVzOiBbXSxcbiAgICBoeWRyYXRlZDogW10sXG4gICAgZGVmZXJyZWQ6IHt9LFxuICAgIHBsdWdpbnNcbiAgfTtcbiAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IGRlY29kZUluaXRpYWwuY2FsbChkZWNvZGVyLCByZWFkZXIpO1xuICBsZXQgZG9uZVByb21pc2UgPSBkb25lLnByb21pc2U7XG4gIGlmIChkZWNvZGVkLmRvbmUpIHtcbiAgICBkb25lLnJlc29sdmUoKTtcbiAgfSBlbHNlIHtcbiAgICBkb25lUHJvbWlzZSA9IGRlY29kZURlZmVycmVkLmNhbGwoZGVjb2RlciwgcmVhZGVyKS50aGVuKGRvbmUucmVzb2x2ZSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgZm9yIChjb25zdCBkZWZlcnJlZCBvZiBPYmplY3QudmFsdWVzKGRlY29kZXIuZGVmZXJyZWQpKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgfVxuICAgICAgZG9uZS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IGRvbmVQcm9taXNlLnRoZW4oKCkgPT4gcmVhZGVyLmNsb3NlZCksXG4gICAgdmFsdWU6IGRlY29kZWQudmFsdWVcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZUluaXRpYWwocmVhZGVyKSB7XG4gIGNvbnN0IHJlYWQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICBpZiAoIXJlYWQudmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgfVxuICBsZXQgbGluZTtcbiAgdHJ5IHtcbiAgICBsaW5lID0gSlNPTi5wYXJzZShyZWFkLnZhbHVlKTtcbiAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkb25lOiByZWFkLmRvbmUsXG4gICAgdmFsdWU6IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGxpbmUpXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVEZWZlcnJlZChyZWFkZXIpIHtcbiAgbGV0IHJlYWQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICB3aGlsZSAoIXJlYWQuZG9uZSkge1xuICAgIGlmICghcmVhZC52YWx1ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGxpbmUgPSByZWFkLnZhbHVlO1xuICAgIHN3aXRjaCAobGluZVswXSkge1xuICAgICAgY2FzZSBUWVBFX1BST01JU0U6IHtcbiAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkSWQgPSBOdW1iZXIobGluZS5zbGljZSgxLCBjb2xvbkluZGV4KSk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZFtkZWZlcnJlZElkXTtcbiAgICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVmZXJyZWQgSUQgJHtkZWZlcnJlZElkfSBub3QgZm91bmQgaW4gc3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZURhdGEgPSBsaW5lLnNsaWNlKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgbGV0IGpzb25MaW5lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGpzb25MaW5lID0gSlNPTi5wYXJzZShsaW5lRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuLmNhbGwodGhpcywganNvbkxpbmUpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRZUEVfRVJST1I6IHtcbiAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkSWQgPSBOdW1iZXIobGluZS5zbGljZSgxLCBjb2xvbkluZGV4KSk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZFtkZWZlcnJlZElkXTtcbiAgICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVmZXJyZWQgSUQgJHtkZWZlcnJlZElkfSBub3QgZm91bmQgaW4gc3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZURhdGEgPSBsaW5lLnNsaWNlKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgbGV0IGpzb25MaW5lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGpzb25MaW5lID0gSlNPTi5wYXJzZShsaW5lRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuLmNhbGwodGhpcywganNvbkxpbmUpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgIH1cbiAgICByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGx1Z2lucywgcG9zdFBsdWdpbnMsIHNpZ25hbCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgZW5jb2RlciA9IHtcbiAgICBkZWZlcnJlZDoge30sXG4gICAgaW5kZXg6IDAsXG4gICAgaW5kaWNlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBzdHJpbmdpZmllZDogW10sXG4gICAgcGx1Z2lucyxcbiAgICBwb3N0UGx1Z2lucyxcbiAgICBzaWduYWxcbiAgfTtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGxhc3RTZW50SW5kZXggPSAwO1xuICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgaWQgPSBmbGF0dGVuLmNhbGwoZW5jb2RlciwgaW5wdXQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZCA8IDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShgJHtpZH1cbmApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoYFske2VuY29kZXIuc3RyaW5naWZpZWQuam9pbihcIixcIil9XVxuYClcbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFNlbnRJbmRleCA9IGVuY29kZXIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZW5Qcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGVuY29kZXIuZGVmZXJyZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBbZGVmZXJyZWRJZCwgZGVmZXJyZWRdIG9mIE9iamVjdC5lbnRyaWVzKGVuY29kZXIuZGVmZXJyZWQpKSB7XG4gICAgICAgICAgaWYgKHNlZW5Qcm9taXNlcy5oYXMoZGVmZXJyZWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgc2VlblByb21pc2VzLmFkZChcbiAgICAgICAgICAgIGVuY29kZXIuZGVmZXJyZWRbTnVtYmVyKGRlZmVycmVkSWQpXSA9IHJhY2VTaWduYWwoXG4gICAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgICBlbmNvZGVyLnNpZ25hbFxuICAgICAgICAgICAgKS50aGVuKFxuICAgICAgICAgICAgICAocmVzb2x2ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZDIgPSBmbGF0dGVuLmNhbGwoZW5jb2RlciwgcmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVuY29kZXIuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OiR7aWQyfVxuYClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGVuY29kZXIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyLnN0cmluZ2lmaWVkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWFzb24gfHwgdHlwZW9mIHJlYXNvbiAhPT0gXCJvYmplY3RcIiB8fCAhKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgcmVhc29uID0gbmV3IEVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaWQyID0gZmxhdHRlbi5jYWxsKGVuY29kZXIsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQyKSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVuY29kZXIuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfToke2lkMn1cbmApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBlbmNvZGVyLnN0cmluZ2lmaWVkLnNsaWNlKGxhc3RTZW50SW5kZXggKyAxKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfTpbJHt2YWx1ZXN9XVxuYFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbGFzdFNlbnRJbmRleCA9IGVuY29kZXIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbmNvZGVyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKE9iamVjdC52YWx1ZXMoZW5jb2Rlci5kZWZlcnJlZCkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyhlbmNvZGVyLmRlZmVycmVkKSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlYWRhYmxlO1xufVxuZnVuY3Rpb24gcmFjZVNpZ25hbChwcm9taXNlLCBzaWduYWwpIHtcbiAgaWYgKCFzaWduYWwpXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2lnbmFsLnJlYXNvbiB8fCBuZXcgRXJyb3IoXCJTaWduYWwgd2FzIGFib3J0ZWQuXCIpKTtcbiAgY29uc3QgYWJvcnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHJlamVjdChzaWduYWwucmVhc29uIHx8IG5ldyBFcnJvcihcIlNpZ25hbCB3YXMgYWJvcnRlZC5cIikpO1xuICAgIH0pO1xuICAgIHByb21pc2UudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICB9KTtcbiAgYWJvcnQuY2F0Y2goKCkgPT4ge1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbYWJvcnQsIHByb21pc2VdKTtcbn1cbmV4cG9ydCB7XG4gIGRlY29kZSxcbiAgZW5jb2RlXG59O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubmMgPSB1bmRlZmluZWQ7IiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZVJvb3QgfSBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiO1xuaW1wb3J0IEFwcCBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgfSBmcm9tIFwicmVhY3Qtcm91dGVyLWRvbVwiO1xudmFyIHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKTtcbnZhciByb290ID0gY3JlYXRlUm9vdChyb290RWxlbWVudCk7XG5yb290LnJlbmRlcihfanN4KEJyb3dzZXJSb3V0ZXIsIHsgY2hpbGRyZW46IF9qc3goQXBwLCB7fSkgfSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9